# Generated by API Builder - https://www.apibuilder.io
# Service version: 0.3.46

require 'cgi'
require 'net/http'
require 'net/https'
require 'uri'
require 'base64'

require 'date'
require 'rubygems'
require 'json'
require 'bigdecimal'

module Io
  module Apibuilder
    module Example
      module Union
        module Types
          module V0

            class Client

              module Constants

                NAMESPACE = 'io.apibuilder.example.union.types.v0' unless defined?(Constants::NAMESPACE)
                USER_AGENT = 'apibuilder-play_2x_client-unknown' unless defined?(Constants::USER_AGENT)
                VERSION = '0.3.46' unless defined?(Constants::VERSION)
                VERSION_MAJOR = 0 unless defined?(VERSION_MAJOR)

              end

              attr_reader :url

              def initialize(url, opts={})
                @url = HttpClient::Preconditions.assert_class('url', url, String)
                @base_url = URI(url)
                @authorization = HttpClient::Preconditions.assert_class_or_nil('authorization', opts.delete(:authorization), HttpClient::Authorization)
                @default_headers = HttpClient::Preconditions.assert_class('default_headers', opts.delete(:default_headers) || {}, Hash)
                @http_handler = opts.delete(:http_handler) || HttpClient::DefaultHttpHandler.new

                HttpClient::Preconditions.assert_empty_opts(opts)
                HttpClient::Preconditions.check_state(url.match(/http.+/i), "URL[%s] must start with http" % url)
              end

              def request(path=nil)
                HttpClient::Preconditions.assert_class_or_nil('path', path, String)
                request = HttpClient::Request.new(@http_handler, @base_url, path.to_s).with_header('User-Agent', Constants::USER_AGENT).with_header('X-Apidoc-Version', Constants::VERSION).with_header('X-Apidoc-Version-Major', Constants::VERSION_MAJOR)

                @default_headers.each do |key, value|
                  request = request.with_header(key, value)
                end

                if @authorization
                  request = request.with_auth(@authorization)
                end

                request
              end

              def users
                @users ||= ::Io::Apibuilder::Example::Union::Types::V0::Clients::Users.new(self)
              end
            end

            module Clients

              class Users

                def initialize(client)
                  @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Apibuilder::Example::Union::Types::V0::Client)
                end

                def get
                  r = @client.request("/users").get
                  r.map { |x| ::Io::Apibuilder::Example::Union::Types::V0::Models::User.from_json(x) }
                end

                def get_by_guid(guid)
                  HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(guid), String)
                  r = @client.request("/users/#{guid}").get
                  ::Io::Apibuilder::Example::Union::Types::V0::Models::User.from_json(r)
                end

                def post(user)
                  (x = user; x.is_a?(::Io::Apibuilder::Example::Union::Types::V0::Models::User) ? x : ::Io::Apibuilder::Example::Union::Types::V0::Models::User.from_json(x))
                  r = @client.request("/users").with_json(user.to_json).post
                  ::Io::Apibuilder::Example::Union::Types::V0::Models::User.from_json(r)
                end

              end

            end

            module Models

              class Foobar

                module Types
                  FOO = 'foo' unless defined?(FOO)
                  BAR = 'bar' unless defined?(BAR)
                end

                attr_reader :__discriminator__

                def initialize(incoming={})
                  opts = HttpClient::Helper.symbolize_keys(incoming)
                  @__discriminator__ = opts[:__discriminator__] ||'foobar'
                end

                def subtype_to_hash
                  raise 'Cannot serialize an instance of foobar directly - must use one of the specific types: foo, bar'
                end

                def to_hash
                  { @__discriminator__ => subtype_to_hash }
                end

                def Foobar.from_json(hash)
                  HttpClient::Preconditions.assert_class('hash', hash, Hash)
                  hash.map do |union_type_name, data|
                    case union_type_name
                      when Types::FOO; Foo.new(data)
                      when Types::BAR; Bar.new(data)
                      else FoobarUndefinedType.new(:__discriminator__ => union_type_name)
                    end
                  end.first
                end

              end

              class FoobarUndefinedType < Foobar

                attr_reader :name

                def initialize(incoming={})
                  super(:__discriminator__ => 'undefined_type')
                  opts = HttpClient::Helper.symbolize_keys(incoming)
                  @name = HttpClient::Preconditions.assert_class('name', opts.delete(:__discriminator__), String)
                end

                def subtype_to_hash
                  raise 'Unable to serialize undefined type to json'
                end

                def copy(incoming={})
                  raise 'Operation not supported for undefined type'
                end

                def to_hash
                  raise 'Operation not supported for undefined type'
                end

              end

              class User

                module Types
                  REGISTERED_USER = 'registered_user' unless defined?(REGISTERED_USER)
                  GUEST_USER = 'guest_user' unless defined?(GUEST_USER)
                  USER_UUID_WRAPPER = 'uuid' unless defined?(USER_UUID_WRAPPER)
                end

                attr_reader :discriminator

                def initialize(incoming={})
                  opts = HttpClient::Helper.symbolize_keys(incoming)
                  @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator) || 'registered_user', String)
                end

                def subtype_to_hash
                  raise 'Cannot serialize an instance of user directly - must use one of the specific types: registered_user, guest_user, uuid'
                end

                def to_hash
                  subtype_to_hash.merge(:discriminator => @discriminator)
                end

                def User.from_json(hash)
                  HttpClient::Preconditions.assert_class('hash', hash, Hash)
                  discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
                  if discriminator.empty?
                    raise "Union type[user] requires a field named 'discriminator'"
                  end
                  case discriminator
                    when Types::REGISTERED_USER; RegisteredUser.new(hash)
                    when Types::GUEST_USER; GuestUser.new(hash)
                    when Types::USER_UUID_WRAPPER; UserUuidWrapper.new(hash)
                    else UserUndefinedType.new(:discriminator => discriminator)
                  end
                end

              end

              class UserUndefinedType < User

                attr_reader :name

                def initialize(incoming={})
                  super(:discriminator => 'undefined_type')
                  opts = HttpClient::Helper.symbolize_keys(incoming)
                  @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
                end

                def subtype_to_hash
                  raise 'Unable to serialize undefined type to json'
                end

                def copy(incoming={})
                  raise 'Operation not supported for undefined type'
                end

                def to_hash
                  raise 'Operation not supported for undefined type'
                end

              end

              class Bar < Foobar

                attr_reader :value

                def initialize(value)
                  super(:name => Foobar::Types::BAR, :__discriminator__ => 'bar')
                  @value = HttpClient::Preconditions.assert_class('value', value, String)
                end

                # Returns the instance of Bar for this value, creating a new instance for an unknown value
                def Bar.apply(value)
                  if value.instance_of?(Bar)
                    value
                  else
                    HttpClient::Preconditions.assert_class_or_nil('value', value, String)
                    value.nil? ? nil : (from_string(value) || Bar.new(value))
                  end
                end

                # Returns the instance of Bar for this value, or nil if not found
                def Bar.from_string(value)
                  HttpClient::Preconditions.assert_class('value', value, String)
                  Bar.ALL.find { |v| v.value == value }
                end

                def Bar.ALL
                  @@all ||= [Bar.b]
                end

                def Bar.b
                  @@_b ||= Bar.new('b')
                end

                def subtype_to_hash
                  value
                end

              end

              class Foo < Foobar

                attr_reader :value

                def initialize(value)
                  super(:name => Foobar::Types::FOO, :__discriminator__ => 'foo')
                  @value = HttpClient::Preconditions.assert_class('value', value, String)
                end

                # Returns the instance of Foo for this value, creating a new instance for an unknown value
                def Foo.apply(value)
                  if value.instance_of?(Foo)
                    value
                  else
                    HttpClient::Preconditions.assert_class_or_nil('value', value, String)
                    value.nil? ? nil : (from_string(value) || Foo.new(value))
                  end
                end

                # Returns the instance of Foo for this value, or nil if not found
                def Foo.from_string(value)
                  HttpClient::Preconditions.assert_class('value', value, String)
                  Foo.ALL.find { |v| v.value == value }
                end

                def Foo.ALL
                  @@all ||= [Foo.a]
                end

                def Foo.a
                  @@_a ||= Foo.new('a')
                end

                def subtype_to_hash
                  value
                end

              end

              class GuestUser < User

                attr_reader :guid, :email

                def initialize(incoming={})
                  super(:discriminator => User::Types::GUEST_USER)
                  opts = HttpClient::Helper.symbolize_keys(incoming)
                  HttpClient::Preconditions.require_keys(opts, [:guid, :email], 'GuestUser')
                  @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
                  @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
                end

                def to_json
                  JSON.dump(to_hash)
                end

                def copy(incoming={})
                  GuestUser.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
                end

                def subtype_to_hash
                  {
                    :guid => guid,
                    :email => email
                  }
                end

              end

              class RegisteredUser < User

                attr_reader :guid, :email, :preference

                def initialize(incoming={})
                  super(:discriminator => User::Types::REGISTERED_USER)
                  opts = HttpClient::Helper.symbolize_keys(incoming)
                  HttpClient::Preconditions.require_keys(opts, [:guid, :email, :preference], 'RegisteredUser')
                  @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
                  @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
                  @preference = (x = opts.delete(:preference); x.is_a?(::Io::Apibuilder::Example::Union::Types::V0::Models::Foobar) ? x : ::Io::Apibuilder::Example::Union::Types::V0::Models::Foobar.from_json(x))
                end

                def to_json
                  JSON.dump(to_hash)
                end

                def copy(incoming={})
                  RegisteredUser.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
                end

                def subtype_to_hash
                  {
                    :guid => guid,
                    :email => email,
                    :preference => preference.to_hash
                  }
                end

              end

              # Wrapper class to support the union type[user] datatype[uuid]
              class UserUuidWrapper < User

                attr_reader :value

                def initialize(incoming={})
                  super(:discriminator => User::Types::USER_UUID_WRAPPER)
                  opts = HttpClient::Helper.symbolize_keys(incoming)
                  HttpClient::Preconditions.require_keys(opts, [:value], 'UserUuidWrapper')
                  @value = HttpClient::Preconditions.assert_class('value', HttpClient::Helper.to_uuid(opts.delete(:value)), String)
                end

                def to_json
                  JSON.dump(to_hash)
                end

                def copy(incoming={})
                  UserUuidWrapper.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
                end

                def subtype_to_hash
                  {
                    :value => value
                  }
                end

              end

            end

            # ===== END OF SERVICE DEFINITION =====
            module HttpClient

              class HttpHandler

                # Returns a client instance to use
                #
                # @param base_uri The base URI for this API
                # @param path the Requested full http path (including any query strings)
                def instance(base_uri, path)
                  raise "Override in subclass"
                end

              end

              class HttpHandlerInstance

                # Executes a request. The provided request object will be an
                # instance of Net::HTTP (e.g. Net::HTTP::Get)
                def execute(request)
                  raise "Override in subclass"
                end

              end

              class DefaultHttpHandler < HttpHandler

                def instance(base_uri, path)
                  DefaultHttpHandlerInstance.new(base_uri)
                end

              end

              class DefaultHttpHandlerInstance < HttpHandlerInstance

                attr_reader :client

                def initialize(base_uri)
                  @base_uri = Preconditions.assert_class('base_uri', base_uri, URI)
                  @client = Net::HTTP.new(@base_uri.host, @base_uri.port)
                  if @base_uri.scheme == "https"
                    configure_ssl
                  end
                end

                def execute(request)
                  response = begin
                               @client.request(request)
                             rescue SocketError => e
                               raise StandardError.new("Error accessing uri[#{full_uri(request.path)}]: #{e}")
                             end

                  case response
                  when Net::HTTPSuccess
                    response.body
                  else
                    body = response.body rescue nil
                    raise HttpClient::ServerError.new(response.code.to_i, response.message, :body => body, :uri => full_uri(request.path).to_s)
                  end
                end

                def full_uri(path)
                  path.start_with?(@base_uri.to_s) ? path : File.join(@base_uri.to_s, path)
                end

                # Called to configure SSL if the base uri requires it
                def configure_ssl
                  @client.use_ssl = true
                  @client.verify_mode = OpenSSL::SSL::VERIFY_PEER
                  @client.cert_store = OpenSSL::X509::Store.new
                  @client.cert_store.set_default_paths
                end

              end

              class Request

                attr_reader :base_uri, :path, :full_uri

                def initialize(http_handler, base_uri, path)
                  @http_handler = http_handler
                  @base_uri = Preconditions.assert_class('base_uri', base_uri, URI)
                  @path = Preconditions.assert_class('path', path, String)
                  @full_uri = @base_uri.to_s + @path
                  @params = nil
                  @body = nil
                  @auth = nil
                  @headers = {}
                  @header_keys_lower_case = []
                end

                def with_header(name, value)
                  Preconditions.check_not_blank('name', name, "Header name is required")
                  Preconditions.check_not_blank('value', value, "Header value is required")
                  Preconditions.check_state(!@headers.has_key?(name),
                                            "Duplicate header named[%s]" % name)
                  @headers[name] = value
                  @header_keys_lower_case << name.downcase
                  self
                end

                def with_auth(auth)
                  Preconditions.assert_class('auth', auth, HttpClient::Authorization)
                  Preconditions.check_state(@auth.nil?, "auth previously set")

                  if auth.scheme.name == AuthScheme::BASIC.name
                    @auth = auth
                  else
                    raise "Auth Scheme[#{auth.scheme.name}] not supported"
                  end
                  self
                end

                def with_query(params)
                  Preconditions.assert_class('params', params, Hash)
                  Preconditions.check_state(@params.nil?, "Already have query parameters")
                  @params = params
                  self
                end

                # Wrapper to set Content-Type header to application/json and set
                # the provided json document as the body
                def with_json(json)
                  @headers['Content-Type'] ||= 'application/json; charset=UTF-8'
                  with_body(json)
                end

                def with_body(body)
                  Preconditions.check_not_blank('body', body)
                  @body = body
                  self
                end

                def get(&block)
                  do_request(Net::HTTP::Get, &block)
                end

                def delete(&block)
                  do_request(Net::HTTP::Delete, &block)
                end

                def options(&block)
                  do_request(Net::HTTP::Options, &block)
                end

                def post(&block)
                  do_request(Net::HTTP::Post, &block)
                end

                def put(&block)
                  do_request(Net::HTTP::Put, &block)
                end

                class PATCH < Net::HTTP::Put
                  METHOD = "PATCH"
                end

                def patch(&block)
                  do_request(PATCH, &block)
                end

                def do_request(klass)
                  Preconditions.assert_class('klass', klass, Class)

                  uri = @full_uri.dup
                  if q = to_query(@params)
                    uri += "?%s" % q
                  end

                  request = klass.send(:new, uri)

                  curl = ['curl']
                  if klass != Net::HTTP::Get
                    curl << "-X%s" % klass.name.split("::").last.upcase
                  end

                  if @body
                    # DEBUG path = "/tmp/rest_client.tmp"
                    # DEBUG File.open(path, "w") { |os| os << @body.to_s }
                    # DEBUG curl << "-d@%s" % path
                    request.body = @body
                  end

                  if @auth
                    curl << "-u \"%s:%s\"" % [@auth.username, @auth.password]
                    Preconditions.check_state(!@header_keys_lower_case.include?("authorization"),
                                              "Cannot specify both an Authorization header and an auth instance")
                    user_pass = "%s:%s" % [@auth.username, @auth.password]
                    encoded = Base64.encode64(user_pass).to_s.split("\n").map(&:strip).join
                    request.add_field("Authorization", "Basic %s" % encoded)
                  end

                  @headers.each { |key, value|
                    curl <<  "-H \"%s: %s\"" % [key, value]
                    request.add_field(key, value)
                  }

                  curl << "'%s%s'" % [@base_uri, path]
                  # DEBUG puts curl.join(" ")

                  raw_response = @http_handler.instance(@base_uri, request.path).execute(request)
                  response = raw_response.to_s == "" ? nil : JSON.parse(raw_response)

                  if block_given?
                    yield response
                  else
                    response
                  end
                end

                private
                def to_query(params={})
                  parts = (params || {}).map { |k,v|
                    if v.is_a?(Enumerable)
                      v.map { |el| "%s=%s" % [k, CGI.escape(el.to_s)] }
                    else
                      "%s=%s" % [k, CGI.escape(v.to_s)]
                    end
                  }
                  parts.empty? ? nil : parts.join("&")
                end

              end

              class ServerError < StandardError

                attr_reader :code, :details, :body, :uri

                def initialize(code, details, incoming={})
                  opts = HttpClient::Helper.symbolize_keys(incoming)
                  @code = HttpClient::Preconditions.assert_class('code', code, Integer)
                  @details = HttpClient::Preconditions.assert_class('details', details, String)
                  @body = HttpClient::Preconditions.assert_class_or_nil('body', opts.delete(:body), String)
                  @uri = HttpClient::Preconditions.assert_class_or_nil('uri', opts.delete(:uri), String)
                  HttpClient::Preconditions.assert_empty_opts(opts)
                  super(self.message)
                end

                def message
                  m = "%s %s" % [@code, @details]
                  if @body
                    m << ": %s" % @body
                  end
                  m
                end

                def body_json
                  @body ? JSON.parse(@body) : nil
                end

              end

              class PreconditionException < StandardError

                attr_reader :message

                def initialize(message)
                  super(message)
                  @message = message
                end

              end

              module Preconditions

                def Preconditions.check_argument(expression, error_message=nil)
                  if !expression
                    raise PreconditionException.new(error_message || "check_argument failed")
                  end
                  nil
                end

                def Preconditions.check_state(expression, error_message=nil)
                  if !expression
                    raise PreconditionException.new(error_message || "check_state failed")
                  end
                  nil
                end

                def Preconditions.check_not_nil(field_name, reference, error_message=nil)
                  if reference.nil?
                    raise PreconditionException.new(error_message || "argument for %s cannot be nil" % field_name)
                  end
                  reference
                end

                def Preconditions.check_not_blank(field_name, reference, error_message=nil)
                  if reference.to_s.strip == ""
                    raise PreconditionException.new(error_message || "argument for %s cannot be blank" % field_name)
                  end
                  reference
                end

                # Throws an error if opts is not empty. Useful when parsing
                # arguments to a function
                def Preconditions.assert_empty_opts(opts)
                  if !opts.empty?
                    raise PreconditionException.new("Invalid opts: #{opts.keys.inspect}\n#{opts.inspect}")
                  end
                end

                # Requires that the provided hash has the specified keys.
                # @param fields A list of symbols
                def Preconditions.require_keys(hash, fields, error_prefix=nil)
                  missing = fields.select { |f| !hash.has_key?(f) }
                  if !missing.empty?
                    msg = "Missing required fields: " + missing.join(", ")
                    raise PreconditionException.new(error_prefix.empty? ? msg : "#{error_prefix}: #{msg}")
                  end
                end

                # Asserts that value is not nill and is_?(klass). Returns
                # value. Common use is
                #
                # amount = Preconditions.assert_class('amount', amount, BigDecimal)
                def Preconditions.assert_class(field_name, value, klass)
                  Preconditions.check_not_nil('field_name', field_name)
                  Preconditions.check_not_nil('klass', klass)
                  Preconditions.check_not_nil('value', value, "Value for %s cannot be nil. Expected an instance of class %s" % [field_name, klass.name])
                  Preconditions.check_state(value.is_a?(klass),
                                            "Value for #{field_name} is of type[#{value.class}] - class[#{klass}] is required. value[#{value.inspect.to_s}]")
                  value
                end

                def Preconditions.assert_class_or_nil(field_name, value, klass)
                  if !value.nil?
                    Preconditions.assert_class(field_name, value, klass)
                  end
                end

                def Preconditions.assert_boolean(field_name, value)
                  Preconditions.check_not_nil('field_name', field_name)
                  Preconditions.check_not_nil('value', value, "Value for %s cannot be nil. Expected an instance of TrueClass or FalseClass" % field_name)
                  Preconditions.check_state(value.is_a?(TrueClass) || value.is_a?(FalseClass),
                                            "Value for #{field_name} is of type[#{value.class}] - class[TrueClass or FalseClass] is required. value[#{value.inspect.to_s}]")
                  value
                end

                def Preconditions.assert_boolean_or_nil(field_name, value)
                  if !value.nil?
                    Preconditions.assert_boolean(field_name, value)
                  end
                end

                def Preconditions.assert_collection_of_class(field_name, values, klass)
                  Preconditions.assert_class(field_name, values, Array)
                  values.each { |v| Preconditions.assert_class(field_name, v, klass) }
                end

                def Preconditions.assert_hash_of_class(field_name, hash, klass)
                  Preconditions.assert_class(field_name, hash, Hash)
                  values.each { |k, v| Preconditions.assert_class(field_name, v, klass) }
                end

              end

              class AuthScheme

                attr_reader :name

                def initialize(name)
                  @name = HttpClient::Preconditions.check_not_blank('name', name)
                end

                BASIC = AuthScheme.new("basic") unless defined?(BASIC)

              end

              class Authorization

                attr_reader :scheme, :username, :password

                def initialize(scheme, username, opts={})
                  @scheme = HttpClient::Preconditions.assert_class('schema', scheme, AuthScheme)
                  @username = HttpClient::Preconditions.check_not_blank('username', username, "username is required")
                  @password = HttpClient::Preconditions.assert_class_or_nil('password', opts.delete(:password), String)
                  HttpClient::Preconditions.assert_empty_opts(opts)
                end

                def Authorization.basic(username, password=nil)
                  Authorization.new(AuthScheme::BASIC, username, :password => password)
                end

              end

              module Helper

                def Helper.symbolize_keys(hash)
                  Preconditions.assert_class('hash', hash, Hash)
                  new_hash = {}
                  hash.each { |k, v|
                    new_hash[k.to_sym] = v
                  }
                  new_hash
                end

                def Helper.to_big_decimal(value)
                  value ? BigDecimal.new(value.to_s) : nil
                end

                def Helper.to_object(value)
                  value ? (value.is_a?(Hash) ? value : JSON.parse(value)) : nil
                end

                def Helper.to_uuid(value)
                  Preconditions.check_state(value.nil? || value.match(/^\w\w\w\w\w\w\w\w\-\w\w\w\w\-\w\w\w\w\-\w\w\w\w\-\w\w\w\w\w\w\w\w\w\w\w\w$/),
                                            "Invalid guid[%s]" % value)
                  value
                end

                def Helper.to_date_iso8601(value)
                  if value.is_a?(Date)
                    value
                  elsif value
                    Date.parse(value.to_s)
                  else
                    nil
                  end
                end

                def Helper.to_date_time_iso8601(value)
                  if value.is_a?(DateTime)
                    value
                  elsif value
                    DateTime.parse(value.to_s)
                  else
                    nil
                  end
                end

                def Helper.date_iso8601_to_string(value)
                  value.nil? ? nil : value.strftime('%Y-%m-%d')
                end

                def Helper.date_time_iso8601_to_string(value)
                  value.nil? ? nil : value.strftime('%Y-%m-%dT%H:%M:%S%z')
                end

                TRUE_STRINGS = ['t', 'true', 'y', 'yes', 'on', '1', 'trueclass'] unless defined?(TRUE_STRINGS)
                FALSE_STRINGS = ['f', 'false', 'n', 'no', 'off', '0', 'falseclass'] unless defined?(FALSE_STRINGS)

                def Helper.to_boolean(field_name, value)
                  string = value.to_s.strip.downcase
                  if TRUE_STRINGS.include?(string)
                    true
                  elsif FALSE_STRINGS.include?(string)
                    false
                  elsif string != ""
                    raise PreconditionException.new("Unsupported boolean value[#{string}]. For true, must be one of: #{TRUE_STRINGS.inspect}. For false, must be one of: #{FALSE_STRINGS.inspect}")
                  else
                    nil
                  end
                end

              end

            end
          end
        end
      end
    end
  end
end