# Generated by apidoc - http://www.apidoc.me
# Service version: 0.3.46

require 'cgi'
require 'net/http'
require 'net/https'
require 'uri'
require 'base64'

require 'date'
require 'rubygems'
require 'json'
require 'bigdecimal'

module Com
  module Bryzek
    module Apidoc
      module Example
        module Union
          module Types
            module V0

              class Client

                module Constants

                  NAMESPACE = 'com.bryzek.apidoc.example.union.types.v0' unless defined?(Constants::NAMESPACE)
                  USER_AGENT = 'apidoc:play_2x_client:unknown' unless defined?(Constants::USER_AGENT)
                  VERSION = '0.3.46' unless defined?(Constants::VERSION)
                  VERSION_MAJOR = 0 unless defined?(VERSION_MAJOR)

                end

                attr_reader :url

                def initialize(url, opts={})
                  @url = HttpClient::Preconditions.assert_class('url', url, String)
                  @authorization = HttpClient::Preconditions.assert_class_or_nil('authorization', opts.delete(:authorization), HttpClient::Authorization)
                  @default_headers = HttpClient::Preconditions.assert_class('default_headers', opts.delete(:default_headers) || {}, Hash)
                  HttpClient::Preconditions.assert_empty_opts(opts)
                  HttpClient::Preconditions.check_state(url.match(/http.+/i), "URL[%s] must start with http" % url)
                end

                def request(path=nil)
                  HttpClient::Preconditions.assert_class_or_nil('path', path, String)
                  request = HttpClient::Request.new(URI.parse(@url + path.to_s)).with_header('User-Agent', Constants::USER_AGENT).with_header('X-Apidoc-Version', Constants::VERSION).with_header('X-Apidoc-Version-Major', Constants::VERSION_MAJOR)

                  @default_headers.each do |key, value|
                    request = request.with_header(key, value)
                  end

                  if @authorization
                    request = request.with_auth(@authorization)
                  end

                  request
                end

                def users
                  @users ||= ::Com::Bryzek::Apidoc::Example::Union::Types::V0::Clients::Users.new(self)
                end
              end

              module Clients

                class Users

                  def initialize(client)
                    @client = HttpClient::Preconditions.assert_class('client', client, ::Com::Bryzek::Apidoc::Example::Union::Types::V0::Client)
                  end

                  def get
                    r = @client.request("/users").get
                    r.map { |x| ::Com::Bryzek::Apidoc::Example::Union::Types::V0::Models::User.from_json(x) }
                  end

                  def get_by_guid(guid)
                    HttpClient::Preconditions.assert_class('guid', guid, String)
                    r = @client.request("/users/#{guid}").get
                    ::Com::Bryzek::Apidoc::Example::Union::Types::V0::Models::User.from_json(r)
                  end

                  def post(user)
                    HttpClient::Preconditions.assert_class('user', user, ::Com::Bryzek::Apidoc::Example::Union::Types::V0::Models::User)
                    r = @client.request("/users").with_json(user.to_json).post
                    ::Com::Bryzek::Apidoc::Example::Union::Types::V0::Models::User.from_json(r)
                  end

                end

              end

              module Models

                class Foobar

                  module Types
                    FOO = 'foo' unless defined?(FOO)
                    BAR = 'bar' unless defined?(BAR)
                  end

                  attr_reader :__discriminator__

                  def initialize(incoming={})
                    opts = HttpClient::Helper.symbolize_keys(incoming)
                    @__discriminator__ = 'foobar'
                  end

                  def subtype_to_hash
                    raise 'Cannot serialize an instance of foobar directly - must use one of the specific types: foo, bar'
                  end

                  def to_hash
                    { @__discriminator__ => subtype_to_hash }
                  end

                  def Foobar.from_json(hash)
                    HttpClient::Preconditions.assert_class('hash', hash, Hash)
                    hash.map do |union_type_name, data|
                      case union_type_name
                        when Types::FOO; Foo.new(data)
                        when Types::BAR; Bar.new(data)
                        else FoobarUndefinedType.new(:__discriminator__ => union_type_name)
                      end
                    end.first
                  end

                end

                class FoobarUndefinedType < Foobar

                  attr_reader :name

                  def initialize(incoming={})
                    super(:__discriminator__ => 'undefined_type')
                    opts = HttpClient::Helper.symbolize_keys(incoming)
                    @name = HttpClient::Preconditions.assert_class('name', opts.delete(:__discriminator__), String)
                  end

                  def subtype_to_hash
                    raise 'Unable to serialize undefined type to json'
                  end

                  def copy(incoming={})
                    raise 'Operation not supported for undefined type'
                  end

                  def to_hash
                    raise 'Operation not supported for undefined type'
                  end

                end

                class User

                  module Types
                    REGISTERED_USER = 'registered_user' unless defined?(REGISTERED_USER)
                    GUEST_USER = 'guest_user' unless defined?(GUEST_USER)
                    USER_UUID_WRAPPER = 'uuid' unless defined?(USER_UUID_WRAPPER)
                  end

                  attr_reader :__discriminator__

                  def initialize(incoming={})
                    opts = HttpClient::Helper.symbolize_keys(incoming)
                    @__discriminator__ = 'user'
                  end

                  def subtype_to_hash
                    raise 'Cannot serialize an instance of user directly - must use one of the specific types: registered_user, guest_user, uuid'
                  end

                  def to_hash
                    { @__discriminator__ => subtype_to_hash }
                  end

                  def User.from_json(hash)
                    HttpClient::Preconditions.assert_class('hash', hash, Hash)
                    hash.map do |union_type_name, data|
                      case union_type_name
                        when Types::REGISTERED_USER; RegisteredUser.new(data)
                        when Types::GUEST_USER; GuestUser.new(data)
                        when Types::USER_UUID_WRAPPER; UserUuidWrapper.new(data)
                        else UserUndefinedType.new(:__discriminator__ => union_type_name)
                      end
                    end.first
                  end

                end

                class UserUndefinedType < User

                  attr_reader :name

                  def initialize(incoming={})
                    super(:__discriminator__ => 'undefined_type')
                    opts = HttpClient::Helper.symbolize_keys(incoming)
                    @name = HttpClient::Preconditions.assert_class('name', opts.delete(:__discriminator__), String)
                  end

                  def subtype_to_hash
                    raise 'Unable to serialize undefined type to json'
                  end

                  def copy(incoming={})
                    raise 'Operation not supported for undefined type'
                  end

                  def to_hash
                    raise 'Operation not supported for undefined type'
                  end

                end

                class Bar < Foobar

                  attr_reader :value

                  def initialize(value)
                    super(:name => Foobar::Types::BAR)
                    @value = HttpClient::Preconditions.assert_class('value', value, String)
                  end

                  # Returns the instance of Bar for this value, creating a new instance for an unknown value
                  def Bar.apply(value)
                    if value.instance_of?(Bar)
                      value
                    else
                      HttpClient::Preconditions.assert_class_or_nil('value', value, String)
                      value.nil? ? nil : (from_string(value) || Bar.new(value))
                    end
                  end

                  # Returns the instance of Bar for this value, or nil if not found
                  def Bar.from_string(value)
                    HttpClient::Preconditions.assert_class('value', value, String)
                    Bar.ALL.find { |v| v.value == value }
                  end

                  def Bar.ALL
                    @@all ||= [Bar.b]
                  end

                  def Bar.b
                    @@_b ||= Bar.new('b')
                  end

                  def subtype_to_hash
                    value
                  end

                end

                class Foo < Foobar

                  attr_reader :value

                  def initialize(value)
                    super(:name => Foobar::Types::FOO)
                    @value = HttpClient::Preconditions.assert_class('value', value, String)
                  end

                  # Returns the instance of Foo for this value, creating a new instance for an unknown value
                  def Foo.apply(value)
                    if value.instance_of?(Foo)
                      value
                    else
                      HttpClient::Preconditions.assert_class_or_nil('value', value, String)
                      value.nil? ? nil : (from_string(value) || Foo.new(value))
                    end
                  end

                  # Returns the instance of Foo for this value, or nil if not found
                  def Foo.from_string(value)
                    HttpClient::Preconditions.assert_class('value', value, String)
                    Foo.ALL.find { |v| v.value == value }
                  end

                  def Foo.ALL
                    @@all ||= [Foo.a]
                  end

                  def Foo.a
                    @@_a ||= Foo.new('a')
                  end

                  def subtype_to_hash
                    value
                  end

                end

                class GuestUser < User

                  attr_reader :guid, :email

                  def initialize(incoming={})
                    super(:__discriminator__ => User::Types::GUEST_USER)
                    opts = HttpClient::Helper.symbolize_keys(incoming)
                    HttpClient::Preconditions.require_keys(opts, [:guid, :email], 'GuestUser')
                    @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
                    @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
                  end

                  def to_json
                    JSON.dump(to_hash)
                  end

                  def copy(incoming={})
                    GuestUser.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
                  end

                  def subtype_to_hash
                    {
                      :guid => guid,
                      :email => email
                    }
                  end

                end

                class RegisteredUser < User

                  attr_reader :guid, :email, :preference

                  def initialize(incoming={})
                    super(:__discriminator__ => User::Types::REGISTERED_USER)
                    opts = HttpClient::Helper.symbolize_keys(incoming)
                    HttpClient::Preconditions.require_keys(opts, [:guid, :email, :preference], 'RegisteredUser')
                    @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
                    @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
                    @preference = (x = opts.delete(:preference); x.is_a?(::Com::Bryzek::Apidoc::Example::Union::Types::V0::Models::Foobar) ? x : ::Com::Bryzek::Apidoc::Example::Union::Types::V0::Models::Foobar.from_json(x))
                  end

                  def to_json
                    JSON.dump(to_hash)
                  end

                  def copy(incoming={})
                    RegisteredUser.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
                  end

                  def subtype_to_hash
                    {
                      :guid => guid,
                      :email => email,
                      :preference => preference.to_hash
                    }
                  end

                end

                # Wrapper class to support the union type[user] datatype[uuid]
                class UserUuidWrapper < User

                  attr_reader :value

                  def initialize(incoming={})
                    super(:__discriminator__ => User::Types::USER_UUID_WRAPPER)
                    opts = HttpClient::Helper.symbolize_keys(incoming)
                    HttpClient::Preconditions.require_keys(opts, [:value], 'UserUuidWrapper')
                    @value = HttpClient::Preconditions.assert_class('value', HttpClient::Helper.to_uuid(opts.delete(:value)), String)
                  end

                  def to_json
                    JSON.dump(to_hash)
                  end

                  def copy(incoming={})
                    UserUuidWrapper.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
                  end

                  def subtype_to_hash
                    {
                      :value => value
                    }
                  end

                end

              end

              # ===== END OF SERVICE DEFINITION =====
              module HttpClient

                class Request

                  def initialize(uri)
                    @uri = Preconditions.assert_class('uri', uri, URI)
                    @params = nil
                    @body = nil
                    @auth = nil
                    @headers = {}
                    @header_keys_lower_case = []
                  end

                  def with_header(name, value)
                    Preconditions.check_not_blank('name', name, "Header name is required")
                    Preconditions.check_not_blank('value', value, "Header value is required")
                    Preconditions.check_state(!@headers.has_key?(name),
                                              "Duplicate header named[%s]" % name)
                    @headers[name] = value
                    @header_keys_lower_case << name.downcase
                    self
                  end

                  def with_auth(auth)
                    Preconditions.assert_class('auth', auth, HttpClient::Authorization)
                    Preconditions.check_state(@auth.nil?, "auth previously set")

                    if auth.scheme.name == AuthScheme::BASIC.name
                      @auth = auth
                    else
                      raise "Auth Scheme[#{auth.scheme.name}] not supported"
                    end
                    self
                  end

                  def with_query(params)
                    Preconditions.assert_class('params', params, Hash)
                    Preconditions.check_state(@params.nil?, "Already have query parameters")
                    @params = params
                    self
                  end

                  # Wrapper to set Content-Type header to application/json and set
                  # the provided json document as the body
                  def with_json(json)
                    @headers['Content-Type'] ||= 'application/json; charset=UTF-8'
                    with_body(json)
                  end

                  def with_body(body)
                    Preconditions.check_not_blank('body', body)
                    @body = body
                    self
                  end

                  # Creates a new Net:HTTP client. The client returned should be
                  # fully configured to make a request.
                  def new_http_client
                    client = Net::HTTP.new(@uri.host, @uri.port)
                    if @uri.scheme == "https"
                      configure_ssl(client)
                    end
                    client
                  end

                  # If HTTPS is required, this method accepts an HTTP Client and configures SSL
                  def configure_ssl(http)
                    Preconditions.assert_class('http', http, Net::HTTP)
                    http.use_ssl = true
                    http.ssl_version = :TLSv1_2
                    http.verify_mode = OpenSSL::SSL::VERIFY_PEER
                    http.cert_store = OpenSSL::X509::Store.new
                    http.cert_store.set_default_paths
                  end

                  def get(&block)
                    do_request(Net::HTTP::Get, &block)
                  end

                  def delete(&block)
                    do_request(Net::HTTP::Delete, &block)
                  end

                  def options(&block)
                    do_request(Net::HTTP::Options, &block)
                  end

                  def post(&block)
                    do_request(Net::HTTP::Post, &block)
                  end

                  def put(&block)
                    do_request(Net::HTTP::Put, &block)
                  end

                  class PATCH < Net::HTTP::Put
                    METHOD = "PATCH"
                  end

                  def patch(&block)
                    do_request(PATCH, &block)
                  end

                  def do_request(klass)
                    Preconditions.assert_class('klass', klass, Class)

                    uri = @uri.to_s
                    if q = to_query(@params)
                      uri += "?%s" % q
                    end

                    request = klass.send(:new, uri)

                    curl = ['curl']
                    if klass != Net::HTTP::Get
                      curl << "-X%s" % klass.name.split("::").last.upcase
                    end

                    if @body
                      # DEBUG path = "/tmp/rest_client.tmp"
                      # DEBUG File.open(path, "w") { |os| os << @body.to_s }
                      # DEBUG curl << "-d@%s" % path
                      request.body = @body
                    end

                    if @auth
                      curl << "-u \"%s:%s\"" % [@auth.username, @auth.password]
                      Preconditions.check_state(!@header_keys_lower_case.include?("authorization"),
                                                "Cannot specify both an Authorization header and an auth instance")
                      user_pass = "%s:%s" % [@auth.username, @auth.password]
                      encoded = Base64.encode64(user_pass).to_s.split("\n").map(&:strip).join
                      request.add_field("Authorization", "Basic %s" % encoded)
                    end

                    @headers.each { |key, value|
                      curl <<  "-H \"%s: %s\"" % [key, value]
                      request.add_field(key, value)
                    }

                    curl << "'%s'" % uri
                    # DEBUG puts curl.join(" ")

                    raw_response = http_request(request)
                    response = raw_response.to_s == "" ? nil : JSON.parse(raw_response)

                    if block_given?
                      yield response
                    else
                      response
                    end
                  end

                  private
                  def to_query(params={})
                    parts = (params || {}).map { |k,v|
                      if v.is_a?(Enumerable)
                        v.map { |el| "%s=%s" % [k, CGI.escape(el.to_s)] }
                      else
                        "%s=%s" % [k, CGI.escape(v.to_s)]
                      end
                    }
                    parts.empty? ? nil : parts.join("&")
                  end

                  def http_request(request)
                    response = begin
                                 new_http_client.request(request)
                               rescue SocketError => e
                                 raise Exception.new("Error accessing uri[#{@uri}]: #{e}")
                               end

                    case response
                    when Net::HTTPSuccess
                      response.body
                    else
                      body = response.body rescue nil
                      raise HttpClient::ServerError.new(response.code.to_i, response.message, :body => body, :uri => @uri.to_s)
                    end
                  end
                end

                class ServerError < StandardError

                  attr_reader :code, :details, :body, :uri

                  def initialize(code, details, incoming={})
                    opts = HttpClient::Helper.symbolize_keys(incoming)
                    @code = HttpClient::Preconditions.assert_class('code', code, Integer)
                    @details = HttpClient::Preconditions.assert_class('details', details, String)
                    @body = HttpClient::Preconditions.assert_class_or_nil('body', opts.delete(:body), String)
                    @uri = HttpClient::Preconditions.assert_class_or_nil('uri', opts.delete(:uri), String)
                    HttpClient::Preconditions.assert_empty_opts(opts)
                    super(self.message)
                  end

                  def message
                    m = "%s %s" % [@code, @details]
                    if @body
                      m << ": %s" % @body
                    end
                    m
                  end

                  def body_json
                    @body ? JSON.parse(@body) : nil
                  end

                end

                class PreconditionException < Exception

                  attr_reader :message

                  def initialize(message)
                    super(message)
                    @message = message
                  end

                end

                module Preconditions

                  def Preconditions.check_argument(expression, error_message=nil)
                    if !expression
                      raise PreconditionException.new(error_message || "check_argument failed")
                    end
                    nil
                  end

                  def Preconditions.check_state(expression, error_message=nil)
                    if !expression
                      raise PreconditionException.new(error_message || "check_state failed")
                    end
                    nil
                  end

                  def Preconditions.check_not_nil(field_name, reference, error_message=nil)
                    if reference.nil?
                      raise PreconditionException.new(error_message || "argument for %s cannot be nil" % field_name)
                    end
                    reference
                  end

                  def Preconditions.check_not_blank(field_name, reference, error_message=nil)
                    if reference.to_s.strip == ""
                      raise PreconditionException.new(error_message || "argument for %s cannot be blank" % field_name)
                    end
                    reference
                  end

                  # Throws an error if opts is not empty. Useful when parsing
                  # arguments to a function
                  def Preconditions.assert_empty_opts(opts)
                    if !opts.empty?
                      raise PreconditionException.new("Invalid opts: #{opts.keys.inspect}\n#{opts.inspect}")
                    end
                  end

                  # Requires that the provided hash has the specified keys.
                  # @param fields A list of symbols
                  def Preconditions.require_keys(hash, fields, error_prefix=nil)
                    missing = fields.select { |f| !hash.has_key?(f) }
                    if !missing.empty?
                      msg = "Missing required fields: " + missing.join(", ")
                      raise PreconditionException.new(error_prefix.empty? ? msg : "#{error_prefix}: #{msg}")
                    end
                  end

                  # Asserts that value is not nill and is_?(klass). Returns
                  # value. Common use is
                  #
                  # amount = Preconditions.assert_class('amount', amount, BigDecimal)
                  def Preconditions.assert_class(field_name, value, klass)
                    Preconditions.check_not_nil('field_name', field_name)
                    Preconditions.check_not_nil('klass', klass)
                    Preconditions.check_not_nil('value', value, "Value for %s cannot be nil. Expected an instance of class %s" % [field_name, klass.name])
                    Preconditions.check_state(value.is_a?(klass),
                                              "Value for #{field_name} is of type[#{value.class}] - class[#{klass}] is required. value[#{value.inspect.to_s}]")
                    value
                  end

                  def Preconditions.assert_class_or_nil(field_name, value, klass)
                    if !value.nil?
                      Preconditions.assert_class(field_name, value, klass)
                    end
                  end

                  def Preconditions.assert_boolean(field_name, value)
                    Preconditions.check_not_nil('field_name', field_name)
                    Preconditions.check_not_nil('value', value, "Value for %s cannot be nil. Expected an instance of TrueClass or FalseClass" % field_name)
                    Preconditions.check_state(value.is_a?(TrueClass) || value.is_a?(FalseClass),
                                              "Value for #{field_name} is of type[#{value.class}] - class[TrueClass or FalseClass] is required. value[#{value.inspect.to_s}]")
                    value
                  end

                  def Preconditions.assert_boolean_or_nil(field_name, value)
                    if !value.nil?
                      Preconditions.assert_boolean(field_name, value)
                    end
                  end

                  def Preconditions.assert_collection_of_class(field_name, values, klass)
                    Preconditions.assert_class(field_name, values, Array)
                    values.each { |v| Preconditions.assert_class(field_name, v, klass) }
                  end

                  def Preconditions.assert_hash_of_class(field_name, hash, klass)
                    Preconditions.assert_class(field_name, hash, Hash)
                    values.each { |k, v| Preconditions.assert_class(field_name, v, klass) }
                  end

                end

                class AuthScheme

                  attr_reader :name

                  def initialize(name)
                    @name = HttpClient::Preconditions.check_not_blank('name', name)
                  end

                  BASIC = AuthScheme.new("basic") unless defined?(BASIC)

                end

                class Authorization

                  attr_reader :scheme, :username, :password

                  def initialize(scheme, username, opts={})
                    @scheme = HttpClient::Preconditions.assert_class('schema', scheme, AuthScheme)
                    @username = HttpClient::Preconditions.check_not_blank('username', username, "username is required")
                    @password = HttpClient::Preconditions.assert_class_or_nil('password', opts.delete(:password), String)
                    HttpClient::Preconditions.assert_empty_opts(opts)
                  end

                  def Authorization.basic(username, password=nil)
                    Authorization.new(AuthScheme::BASIC, username, :password => password)
                  end

                end

                module Helper

                  def Helper.symbolize_keys(hash)
                    Preconditions.assert_class('hash', hash, Hash)
                    new_hash = {}
                    hash.each { |k, v|
                      new_hash[k.to_sym] = v
                    }
                    new_hash
                  end

                  def Helper.to_big_decimal(value)
                    value ? BigDecimal.new(value.to_s) : nil
                  end

                  def Helper.to_object(value)
                    value ? (value.is_a?(Hash) ? value : JSON.parse(value)) : nil
                  end

                  def Helper.to_uuid(value)
                    Preconditions.check_state(value.nil? || value.match(/^\w\w\w\w\w\w\w\w\-\w\w\w\w\-\w\w\w\w\-\w\w\w\w\-\w\w\w\w\w\w\w\w\w\w\w\w$/),
                                              "Invalid guid[%s]" % value)
                    value
                  end

                  def Helper.to_date_iso8601(value)
                    if value.is_a?(Date)
                      value
                    elsif value
                      Date.parse(value.to_s)
                    else
                      nil
                    end
                  end

                  def Helper.to_date_time_iso8601(value)
                    if value.is_a?(DateTime)
                      value
                    elsif value
                      DateTime.parse(value.to_s)
                    else
                      nil
                    end
                  end

                  def Helper.date_iso8601_to_string(value)
                    value.nil? ? nil : value.strftime('%Y-%m-%d')
                  end

                  def Helper.date_time_iso8601_to_string(value)
                    value.nil? ? nil : value.strftime('%Y-%m-%dT%H:%M:%S%z')
                  end

                  TRUE_STRINGS = ['t', 'true', 'y', 'yes', 'on', '1', 'trueclass'] unless defined?(TRUE_STRINGS)
                  FALSE_STRINGS = ['f', 'false', 'n', 'no', 'off', '0', 'falseclass'] unless defined?(FALSE_STRINGS)

                  def Helper.to_boolean(field_name, value)
                    string = value.to_s.strip.downcase
                    if TRUE_STRINGS.include?(string)
                      true
                    elsif FALSE_STRINGS.include?(string)
                      false
                    elsif string != ""
                      raise PreconditionException.new("Unsupported boolean value[#{string}]. For true, must be one of: #{TRUE_STRINGS.inspect}. For false, must be one of: #{FALSE_STRINGS.inspect}")
                    else
                      nil
                    end
                  end

                end

              end
            end
          end
        end
      end
    end
  end
end