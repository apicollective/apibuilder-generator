# Generated by API Builder - https://www.apibuilder.io
# Service version: 0.3.47
# gilt 0.0.1-test

require 'cgi'
require 'net/http'
require 'net/https'
require 'uri'
require 'base64'

require 'date'
require 'rubygems'
require 'json'
require 'bigdecimal'

module Io
  module Apibuilder
    module Reference
      module Api
        module V0

          class Client

            module Constants

              BASE_URL = 'http://localhost:9000' unless defined?(Constants::BASE_URL)
              NAMESPACE = 'io.apibuilder.reference.api.v0' unless defined?(Constants::NAMESPACE)
              USER_AGENT = 'gilt 0.0.1-test' unless defined?(Constants::USER_AGENT)
              VERSION = '0.3.47' unless defined?(Constants::VERSION)
              VERSION_MAJOR = 0 unless defined?(VERSION_MAJOR)

            end

            attr_reader :url

            def initialize(url, opts={})
              @url = HttpClient::Preconditions.assert_class('url', url, String)
              @base_url = URI(url)
              @authorization = HttpClient::Preconditions.assert_class_or_nil('authorization', opts.delete(:authorization), HttpClient::Authorization)
              @default_headers = HttpClient::Preconditions.assert_class('default_headers', opts.delete(:default_headers) || {}, Hash)
              @http_handler = opts.delete(:http_handler) || HttpClient::DefaultHttpHandler.new

              HttpClient::Preconditions.assert_empty_opts(opts)
              HttpClient::Preconditions.check_state(url.match(/http.+/i), "URL[%s] must start with http" % url)
            end

            # Creates an instance of the client using the base url specified in the API spec.
            def Client.at_base_url(opts={})
              Client.new(Constants::BASE_URL, opts)
            end

            def request(path=nil)
              HttpClient::Preconditions.assert_class_or_nil('path', path, String)
              request = HttpClient::Request.new(@http_handler, @base_url, path.to_s).with_header('User-Agent', Constants::USER_AGENT).with_header('X-Apidoc-Version', Constants::VERSION).with_header('X-Apidoc-Version-Major', Constants::VERSION_MAJOR)

              @default_headers.each do |key, value|
                request = request.with_header(key, value)
              end

              if @authorization
                request = request.with_auth(@authorization)
              end

              request
            end

            def echoes
              @echoes ||= ::Io::Apibuilder::Reference::Api::V0::Clients::Echoes.new(self)
            end

            def groups
              @groups ||= ::Io::Apibuilder::Reference::Api::V0::Clients::Groups.new(self)
            end

            def members
              @members ||= ::Io::Apibuilder::Reference::Api::V0::Clients::Members.new(self)
            end

            def organizations
              @organizations ||= ::Io::Apibuilder::Reference::Api::V0::Clients::Organizations.new(self)
            end

            def users
              @users ||= ::Io::Apibuilder::Reference::Api::V0::Clients::Users.new(self)
            end
          end

          module Clients

            class Echoes

              def initialize(client)
                @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Apibuilder::Reference::Api::V0::Client)
              end

              def get(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                query = {
                  :foo => (x = opts.delete(:foo); x.nil? ? nil : HttpClient::Preconditions.assert_class('foo', x, String)),
                  :optional_messages => (x = opts.delete(:optional_messages); x.nil? ? nil : HttpClient::Preconditions.assert_class('optional_messages', x, Array).map { |v| HttpClient::Preconditions.assert_class('optional_messages', v, String) }),
                  :required_messages => HttpClient::Preconditions.assert_class('required_messages', opts.delete(:required_messages), Array).map { |v| HttpClient::Preconditions.assert_class('required_messages', v, String) }
                }.delete_if { |k, v| v.nil? }
                r = @client.request("/echoes").with_query(query).get
                nil
              end

              def get_arrays_only(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                query = {
                  :optional_messages => (x = opts.delete(:optional_messages); x.nil? ? nil : HttpClient::Preconditions.assert_class('optional_messages', x, Array).map { |v| HttpClient::Preconditions.assert_class('optional_messages', v, String) }),
                  :required_messages => HttpClient::Preconditions.assert_class('required_messages', opts.delete(:required_messages), Array).map { |v| HttpClient::Preconditions.assert_class('required_messages', v, String) }
                }.delete_if { |k, v| v.nil? }
                r = @client.request("/echoes/arrays-only").with_query(query).get
                nil
              end

            end

            class Groups

              def initialize(client)
                @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Apibuilder::Reference::Api::V0::Client)
              end

              def get_by_organization(organization)
                HttpClient::Preconditions.assert_class('organization', HttpClient::Helper.to_uuid(organization), String)
                r = @client.request("/groups/#{organization}").get
                r.inject({}) { |hash, x| hash[x[0]] = x[1].nil? ? nil : x[1].map { |x| ::Io::Apibuilder::Reference::Api::V0::Models::User.new(x) }; hash }
              end

            end

            class Members

              def initialize(client)
                @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Apibuilder::Reference::Api::V0::Client)
              end

              def post
                r = @client.request("/members").post
                ::Io::Apibuilder::Reference::Api::V0::Models::Member.new(r)
              end

              def get(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                query = {
                  :guid => (x = opts.delete(:guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(x), String)),
                  :organization_guid => (x = opts.delete(:organization_guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization_guid', HttpClient::Helper.to_uuid(x), String)),
                  :user_guid => (x = opts.delete(:user_guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('user_guid', HttpClient::Helper.to_uuid(x), String)),
                  :role => (x = opts.delete(:role); x.nil? ? nil : HttpClient::Preconditions.assert_class('role', x, String))
                }.delete_if { |k, v| v.nil? }
                r = @client.request("/members").with_query(query).get
                r.map { |x| ::Io::Apibuilder::Reference::Api::V0::Models::Member.new(x) }
              end

              def get_by_organization(organization)
                HttpClient::Preconditions.assert_class('organization', HttpClient::Helper.to_uuid(organization), String)
                r = @client.request("/members/#{organization}").get
                r.map { |x| ::Io::Apibuilder::Reference::Api::V0::Models::Member.new(x) }
              end

              def post_members_bulk_by_organization(organization, members)
                HttpClient::Preconditions.assert_class('organization', HttpClient::Helper.to_uuid(organization), String)
                HttpClient::Preconditions.assert_class('members', members, Array).map { |v| (x = v; x.is_a?(::Io::Apibuilder::Reference::Api::V0::Models::Member) ? x : ::Io::Apibuilder::Reference::Api::V0::Models::Member.new(x)) }
                r = @client.request("/members/#{organization}/members_bulk").with_json(members.map { |o| o.to_hash }.to_json).post
                r.map { |x| ::Io::Apibuilder::Reference::Api::V0::Models::Member.new(x) }
              end

            end

            class Organizations

              def initialize(client)
                @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Apibuilder::Reference::Api::V0::Client)
              end

              def post
                r = @client.request("/organizations").post
                ::Io::Apibuilder::Reference::Api::V0::Models::Organization.new(r)
              end

              def get(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                query = {
                  :guid => (x = opts.delete(:guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(x), String)),
                  :name => (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
                }.delete_if { |k, v| v.nil? }
                r = @client.request("/organizations").with_query(query).get
                r.map { |x| ::Io::Apibuilder::Reference::Api::V0::Models::Organization.new(x) }
              end

              def get_by_guid(guid)
                HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(guid), String)
                r = @client.request("/organizations/#{guid}").get
                ::Io::Apibuilder::Reference::Api::V0::Models::Organization.new(r)
              end

            end

            class Users

              def initialize(client)
                @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Apibuilder::Reference::Api::V0::Client)
              end

              def post
                r = @client.request("/users").post
                ::Io::Apibuilder::Reference::Api::V0::Models::User.new(r)
              end

              def get(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                query = {
                  :guid => (x = opts.delete(:guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(x), String)),
                  :organization_guids => (x = opts.delete(:organization_guids); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization_guids', x, Array).map { |v| HttpClient::Preconditions.assert_class('organization_guids', v, Integer) }),
                  :age_group => (x = opts.delete(:age_group); x.nil? ? nil : (x = x; x.is_a?(::Io::Apibuilder::Reference::Api::V0::Models::AgeGroup) ? x : ::Io::Apibuilder::Reference::Api::V0::Models::AgeGroup.apply(x)).value),
                  :email => (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String)),
                  :active => HttpClient::Preconditions.assert_boolean('active', (x = opts.delete(:active); x.nil? ? true : x))
                }.delete_if { |k, v| v.nil? }
                r = @client.request("/users").with_query(query).get
                r.map { |x| ::Io::Apibuilder::Reference::Api::V0::Models::User.new(x) }
              end

              def get_by_age_group(age_group)
                (x = age_group; x.is_a?(::Io::Apibuilder::Reference::Api::V0::Models::AgeGroup) ? x : ::Io::Apibuilder::Reference::Api::V0::Models::AgeGroup.apply(x))
                r = @client.request("/users/#{age_group.value}").get
                r.map { |x| ::Io::Apibuilder::Reference::Api::V0::Models::User.new(x) }
              end

              def post_noop
                r = @client.request("/users/noop").post
                nil
              end

            end

          end

          module Models

            class AgeGroup

              attr_reader :value

              def initialize(value)
                @value = HttpClient::Preconditions.assert_class('value', value, String)
              end

              # Returns the instance of AgeGroup for this value, creating a new instance for an unknown value
              def AgeGroup.apply(value)
                if value.instance_of?(AgeGroup)
                  value
                else
                  HttpClient::Preconditions.assert_class_or_nil('value', value, String)
                  value.nil? ? nil : (from_string(value) || AgeGroup.new(value))
                end
              end

              # Returns the instance of AgeGroup for this value, or nil if not found
              def AgeGroup.from_string(value)
                HttpClient::Preconditions.assert_class('value', value, String)
                AgeGroup.ALL.find { |v| v.value == value }
              end

              def AgeGroup.ALL
                @@all ||= [AgeGroup.youth, AgeGroup.adult]
              end

              # under 18
              def AgeGroup.youth
                @@_youth ||= AgeGroup.new('Youth')
              end

              # 18 and over
              def AgeGroup.adult
                @@_adult ||= AgeGroup.new('Adult')
              end

              def to_hash
                value
              end

            end

            # A model with a lot of fields.
            class Big

              attr_reader :f1, :f2, :f3, :f4, :f5, :f6, :f7, :f8, :f9, :f10, :f11, :f12, :f13, :f14, :f15, :f16, :f17, :f18, :f19, :f20, :f21

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                HttpClient::Preconditions.require_keys(opts, [:f1, :f2, :f3, :f4, :f5, :f6, :f7, :f8, :f9, :f10, :f11, :f12, :f13, :f14, :f15, :f16, :f17, :f18, :f19, :f20, :f21], 'Big')
                @f1 = HttpClient::Preconditions.assert_class('f1', opts.delete(:f1), String)
                @f2 = HttpClient::Preconditions.assert_class('f2', opts.delete(:f2), String)
                @f3 = HttpClient::Preconditions.assert_class('f3', opts.delete(:f3), String)
                @f4 = HttpClient::Preconditions.assert_class('f4', opts.delete(:f4), String)
                @f5 = HttpClient::Preconditions.assert_class('f5', opts.delete(:f5), String)
                @f6 = HttpClient::Preconditions.assert_class('f6', opts.delete(:f6), String)
                @f7 = HttpClient::Preconditions.assert_class('f7', opts.delete(:f7), String)
                @f8 = HttpClient::Preconditions.assert_class('f8', opts.delete(:f8), String)
                @f9 = HttpClient::Preconditions.assert_class('f9', opts.delete(:f9), String)
                @f10 = HttpClient::Preconditions.assert_class('f10', opts.delete(:f10), String)
                @f11 = HttpClient::Preconditions.assert_class('f11', opts.delete(:f11), String)
                @f12 = HttpClient::Preconditions.assert_class('f12', opts.delete(:f12), String)
                @f13 = HttpClient::Preconditions.assert_class('f13', opts.delete(:f13), String)
                @f14 = HttpClient::Preconditions.assert_class('f14', opts.delete(:f14), String)
                @f15 = HttpClient::Preconditions.assert_class('f15', opts.delete(:f15), String)
                @f16 = HttpClient::Preconditions.assert_class('f16', opts.delete(:f16), String)
                @f17 = HttpClient::Preconditions.assert_class('f17', opts.delete(:f17), String)
                @f18 = HttpClient::Preconditions.assert_class('f18', opts.delete(:f18), String)
                @f19 = HttpClient::Preconditions.assert_class('f19', opts.delete(:f19), String)
                @f20 = HttpClient::Preconditions.assert_class('f20', opts.delete(:f20), String)
                @f21 = HttpClient::Preconditions.assert_class('f21', opts.delete(:f21), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Big.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :f1 => f1,
                  :f2 => f2,
                  :f3 => f3,
                  :f4 => f4,
                  :f5 => f5,
                  :f6 => f6,
                  :f7 => f7,
                  :f8 => f8,
                  :f9 => f9,
                  :f10 => f10,
                  :f11 => f11,
                  :f12 => f12,
                  :f13 => f13,
                  :f14 => f14,
                  :f15 => f15,
                  :f16 => f16,
                  :f17 => f17,
                  :f18 => f18,
                  :f19 => f19,
                  :f20 => f20,
                  :f21 => f21
                }
              end

            end

            class Echo

              attr_reader :value

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                HttpClient::Preconditions.require_keys(opts, [:value], 'Echo')
                @value = HttpClient::Preconditions.assert_class('value', opts.delete(:value), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Echo.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :value => value
                }
              end

            end

            # Models an API error.
            class Error

              attr_reader :code, :message

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                HttpClient::Preconditions.require_keys(opts, [:code, :message], 'Error')
                @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
                @message = HttpClient::Preconditions.assert_class('message', opts.delete(:message), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Error.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :code => code,
                  :message => message
                }
              end

            end

            # A group of users in an organization.
            class Group

              attr_reader :members

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                HttpClient::Preconditions.require_keys(opts, [:members], 'Group')
                @members = HttpClient::Preconditions.assert_class('members', opts.delete(:members), Array).map { |v| (x = v; x.is_a?(::Io::Apibuilder::Reference::Api::V0::Models::User) ? x : ::Io::Apibuilder::Reference::Api::V0::Models::User.new(x)) }
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Group.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :members => members.map { |o| o.to_hash }
                }
              end

            end

            class Member

              attr_reader :guid, :organization, :user, :role

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                HttpClient::Preconditions.require_keys(opts, [:guid, :organization, :user, :role], 'Member')
                @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
                @organization = (x = opts.delete(:organization); x.is_a?(::Io::Apibuilder::Reference::Api::V0::Models::Organization) ? x : ::Io::Apibuilder::Reference::Api::V0::Models::Organization.new(x))
                @user = (x = opts.delete(:user); x.is_a?(::Io::Apibuilder::Reference::Api::V0::Models::User) ? x : ::Io::Apibuilder::Reference::Api::V0::Models::User.new(x))
                @role = HttpClient::Preconditions.assert_class('role', opts.delete(:role), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Member.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :guid => guid,
                  :organization => organization.to_hash,
                  :user => user.to_hash,
                  :role => role
                }
              end

            end

            class Organization

              attr_reader :guid, :name

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                HttpClient::Preconditions.require_keys(opts, [:guid, :name], 'Organization')
                @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
                @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Organization.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :guid => guid,
                  :name => name
                }
              end

            end

            class User

              attr_reader :guid, :email, :active, :age_group, :tags

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                HttpClient::Preconditions.require_keys(opts, [:guid, :email, :active, :age_group], 'User')
                @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
                @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
                @active = HttpClient::Preconditions.assert_boolean('active', opts.delete(:active))
                @age_group = (x = opts.delete(:age_group); x.is_a?(::Io::Apibuilder::Reference::Api::V0::Models::AgeGroup) ? x : ::Io::Apibuilder::Reference::Api::V0::Models::AgeGroup.apply(x))
                @tags = (x = opts.delete(:tags); x.nil? ? nil : HttpClient::Preconditions.assert_class('tags', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('tags', d[1], String); h })
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                User.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :guid => guid,
                  :email => email,
                  :active => active,
                  :age_group => age_group.value,
                  :tags => tags.nil? ? nil : tags
                }
              end

            end

            class UserList

              attr_reader :users

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                HttpClient::Preconditions.require_keys(opts, [:users], 'UserList')
                @users = HttpClient::Preconditions.assert_class('users', opts.delete(:users), Array).map { |v| (x = v; x.is_a?(::Io::Apibuilder::Reference::Api::V0::Models::User) ? x : ::Io::Apibuilder::Reference::Api::V0::Models::User.new(x)) }
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                UserList.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :users => users.map { |o| o.to_hash }
                }
              end

            end

          end

          # ===== END OF SERVICE DEFINITION =====
          module HttpClient

            class HttpHandler

              # Returns a client instance to use
              #
              # @param base_uri The base URI for this API
              # @param path the Requested full http path (including any query strings)
              def instance(base_uri, path)
                raise "Override in subclass"
              end

            end

            class HttpHandlerInstance

              # Executes a request. The provided request object will be an
              # instance of Net::HTTP (e.g. Net::HTTP::Get)
              def execute(request)
                raise "Override in subclass"
              end

            end

            class DefaultHttpHandler < HttpHandler

              def instance(base_uri, path)
                DefaultHttpHandlerInstance.new(base_uri)
              end

            end

            class DefaultHttpHandlerInstance < HttpHandlerInstance

              attr_reader :client

              def initialize(base_uri)
                @base_uri = Preconditions.assert_class('base_uri', base_uri, URI)
                @client = Net::HTTP.new(@base_uri.host, @base_uri.port)
                if @base_uri.scheme == "https"
                  configure_ssl
                end
              end

              def execute(request)
                response = begin
                             @client.request(request)
                           rescue SocketError => e
                             raise StandardError.new("Error accessing uri[#{full_uri(request.path)}]: #{e}")
                           end

                case response
                when Net::HTTPSuccess
                  response.body
                else
                  body = response.body rescue nil
                  raise HttpClient::ServerError.new(response.code.to_i, response.message, :body => body, :uri => full_uri(request.path).to_s)
                end
              end

              def full_uri(path)
                path.start_with?(@base_uri.to_s) ? path : File.join(@base_uri.to_s, path)
              end

              # Called to configure SSL if the base uri requires it
              def configure_ssl
                @client.use_ssl = true
                @client.verify_mode = OpenSSL::SSL::VERIFY_PEER
                @client.cert_store = OpenSSL::X509::Store.new
                @client.cert_store.set_default_paths
              end

            end

            class Request

              attr_reader :base_uri, :path, :full_uri

              def initialize(http_handler, base_uri, path)
                @http_handler = http_handler
                @base_uri = Preconditions.assert_class('base_uri', base_uri, URI)
                @path = Preconditions.assert_class('path', path, String)
                @full_uri = @base_uri.to_s + @path
                @params = nil
                @body = nil
                @auth = nil
                @headers = {}
                @header_keys_lower_case = []
              end

              def with_header(name, value)
                Preconditions.check_not_blank('name', name, "Header name is required")
                Preconditions.check_not_blank('value', value, "Header value is required")
                Preconditions.check_state(!@headers.has_key?(name),
                                          "Duplicate header named[%s]" % name)
                @headers[name] = value
                @header_keys_lower_case << name.downcase
                self
              end

              def with_auth(auth)
                Preconditions.assert_class('auth', auth, HttpClient::Authorization)
                Preconditions.check_state(@auth.nil?, "auth previously set")

                if auth.scheme.name == AuthScheme::BASIC.name
                  @auth = auth
                else
                  raise "Auth Scheme[#{auth.scheme.name}] not supported"
                end
                self
              end

              def with_query(params)
                Preconditions.assert_class('params', params, Hash)
                Preconditions.check_state(@params.nil?, "Already have query parameters")
                @params = params
                self
              end

              # Wrapper to set Content-Type header to application/json and set
              # the provided json document as the body
              def with_json(json)
                @headers['Content-Type'] ||= 'application/json; charset=UTF-8'
                with_body(json)
              end

              def with_body(body)
                Preconditions.check_not_blank('body', body)
                @body = body
                self
              end

              def get(&block)
                do_request(Net::HTTP::Get, &block)
              end

              def delete(&block)
                do_request(Net::HTTP::Delete, &block)
              end

              def options(&block)
                do_request(Net::HTTP::Options, &block)
              end

              def post(&block)
                do_request(Net::HTTP::Post, &block)
              end

              def put(&block)
                do_request(Net::HTTP::Put, &block)
              end

              class PATCH < Net::HTTP::Put
                METHOD = "PATCH"
              end

              def patch(&block)
                do_request(PATCH, &block)
              end

              def do_request(klass)
                Preconditions.assert_class('klass', klass, Class)

                uri = @full_uri.dup
                if q = to_query(@params)
                  uri += "?%s" % q
                end

                request = klass.send(:new, uri)

                curl = ['curl']
                if klass != Net::HTTP::Get
                  curl << "-X%s" % klass.name.split("::").last.upcase
                end

                if @body
                  # DEBUG path = "/tmp/rest_client.tmp"
                  # DEBUG File.open(path, "w") { |os| os << @body.to_s }
                  # DEBUG curl << "-d@%s" % path
                  request.body = @body
                end

                if @auth
                  curl << "-u \"%s:%s\"" % [@auth.username, @auth.password]
                  Preconditions.check_state(!@header_keys_lower_case.include?("authorization"),
                                            "Cannot specify both an Authorization header and an auth instance")
                  user_pass = "%s:%s" % [@auth.username, @auth.password]
                  encoded = Base64.encode64(user_pass).to_s.split("\n").map(&:strip).join
                  request.add_field("Authorization", "Basic %s" % encoded)
                end

                @headers.each { |key, value|
                  curl <<  "-H \"%s: %s\"" % [key, value]
                  request.add_field(key, value)
                }

                curl << "'%s%s'" % [@base_uri, path]
                # DEBUG puts curl.join(" ")

                raw_response = @http_handler.instance(@base_uri, request.path).execute(request)
                response = raw_response.to_s == "" ? nil : JSON.parse(raw_response)

                if block_given?
                  yield response
                else
                  response
                end
              end

              private
              def to_query(params={})
                parts = (params || {}).map { |k,v|
                  if v.is_a?(Enumerable)
                    v.map { |el| "%s=%s" % [k, CGI.escape(el.to_s)] }
                  else
                    "%s=%s" % [k, CGI.escape(v.to_s)]
                  end
                }
                parts.empty? ? nil : parts.join("&")
              end

            end

            class ServerError < StandardError

              attr_reader :code, :details, :body, :uri

              def initialize(code, details, incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @code = HttpClient::Preconditions.assert_class('code', code, Integer)
                @details = HttpClient::Preconditions.assert_class('details', details, String)
                @body = HttpClient::Preconditions.assert_class_or_nil('body', opts.delete(:body), String)
                @uri = HttpClient::Preconditions.assert_class_or_nil('uri', opts.delete(:uri), String)
                HttpClient::Preconditions.assert_empty_opts(opts)
                super(self.message)
              end

              def message
                m = "%s %s" % [@code, @details]
                if @body
                  m << ": %s" % @body
                end
                m
              end

              def body_json
                @body ? JSON.parse(@body) : nil
              end

            end

            class PreconditionException < StandardError

              attr_reader :message

              def initialize(message)
                super(message)
                @message = message
              end

            end

            module Preconditions

              def Preconditions.check_argument(expression, error_message=nil)
                if !expression
                  raise PreconditionException.new(error_message || "check_argument failed")
                end
                nil
              end

              def Preconditions.check_state(expression, error_message=nil)
                if !expression
                  raise PreconditionException.new(error_message || "check_state failed")
                end
                nil
              end

              def Preconditions.check_not_nil(field_name, reference, error_message=nil)
                if reference.nil?
                  raise PreconditionException.new(error_message || "argument for %s cannot be nil" % field_name)
                end
                reference
              end

              def Preconditions.check_not_blank(field_name, reference, error_message=nil)
                if reference.to_s.strip == ""
                  raise PreconditionException.new(error_message || "argument for %s cannot be blank" % field_name)
                end
                reference
              end

              # Throws an error if opts is not empty. Useful when parsing
              # arguments to a function
              def Preconditions.assert_empty_opts(opts)
                if !opts.empty?
                  raise PreconditionException.new("Invalid opts: #{opts.keys.inspect}\n#{opts.inspect}")
                end
              end

              # Requires that the provided hash has the specified keys.
              # @param fields A list of symbols
              def Preconditions.require_keys(hash, fields, error_prefix=nil)
                missing = fields.select { |f| !hash.has_key?(f) }
                if !missing.empty?
                  msg = "Missing required fields: " + missing.join(", ")
                  raise PreconditionException.new(error_prefix.empty? ? msg : "#{error_prefix}: #{msg}")
                end
              end

              # Asserts that value is not nill and is_?(klass). Returns
              # value. Common use is
              #
              # amount = Preconditions.assert_class('amount', amount, BigDecimal)
              def Preconditions.assert_class(field_name, value, klass)
                Preconditions.check_not_nil('field_name', field_name)
                Preconditions.check_not_nil('klass', klass)
                Preconditions.check_not_nil('value', value, "Value for %s cannot be nil. Expected an instance of class %s" % [field_name, klass.name])
                Preconditions.check_state(value.is_a?(klass),
                                          "Value for #{field_name} is of type[#{value.class}] - class[#{klass}] is required. value[#{value.inspect.to_s}]")
                value
              end

              def Preconditions.assert_class_or_nil(field_name, value, klass)
                if !value.nil?
                  Preconditions.assert_class(field_name, value, klass)
                end
              end

              def Preconditions.assert_boolean(field_name, value)
                Preconditions.check_not_nil('field_name', field_name)
                Preconditions.check_not_nil('value', value, "Value for %s cannot be nil. Expected an instance of TrueClass or FalseClass" % field_name)
                Preconditions.check_state(value.is_a?(TrueClass) || value.is_a?(FalseClass),
                                          "Value for #{field_name} is of type[#{value.class}] - class[TrueClass or FalseClass] is required. value[#{value.inspect.to_s}]")
                value
              end

              def Preconditions.assert_boolean_or_nil(field_name, value)
                if !value.nil?
                  Preconditions.assert_boolean(field_name, value)
                end
              end

              def Preconditions.assert_collection_of_class(field_name, values, klass)
                Preconditions.assert_class(field_name, values, Array)
                values.each { |v| Preconditions.assert_class(field_name, v, klass) }
              end

              def Preconditions.assert_hash_of_class(field_name, hash, klass)
                Preconditions.assert_class(field_name, hash, Hash)
                values.each { |k, v| Preconditions.assert_class(field_name, v, klass) }
              end

            end

            class AuthScheme

              attr_reader :name

              def initialize(name)
                @name = HttpClient::Preconditions.check_not_blank('name', name)
              end

              BASIC = AuthScheme.new("basic") unless defined?(BASIC)

            end

            class Authorization

              attr_reader :scheme, :username, :password

              def initialize(scheme, username, opts={})
                @scheme = HttpClient::Preconditions.assert_class('schema', scheme, AuthScheme)
                @username = HttpClient::Preconditions.check_not_blank('username', username, "username is required")
                @password = HttpClient::Preconditions.assert_class_or_nil('password', opts.delete(:password), String)
                HttpClient::Preconditions.assert_empty_opts(opts)
              end

              def Authorization.basic(username, password=nil)
                Authorization.new(AuthScheme::BASIC, username, :password => password)
              end

            end

            module Helper

              def Helper.symbolize_keys(hash)
                Preconditions.assert_class('hash', hash, Hash)
                new_hash = {}
                hash.each { |k, v|
                  new_hash[k.to_sym] = v
                }
                new_hash
              end

              def Helper.to_big_decimal(value)
                value ? BigDecimal.new(value.to_s) : nil
              end

              def Helper.to_object(value)
                value ? (value.is_a?(Hash) ? value : JSON.parse(value)) : nil
              end

              def Helper.to_uuid(value)
                Preconditions.check_state(value.nil? || value.match(/^\w\w\w\w\w\w\w\w\-\w\w\w\w\-\w\w\w\w\-\w\w\w\w\-\w\w\w\w\w\w\w\w\w\w\w\w$/),
                                          "Invalid guid[%s]" % value)
                value
              end

              def Helper.to_date_iso8601(value)
                if value.is_a?(Date)
                  value
                elsif value
                  Date.parse(value.to_s)
                else
                  nil
                end
              end

              def Helper.to_date_time_iso8601(value)
                if value.is_a?(DateTime)
                  value
                elsif value
                  DateTime.parse(value.to_s)
                else
                  nil
                end
              end

              def Helper.date_iso8601_to_string(value)
                value.nil? ? nil : value.strftime('%Y-%m-%d')
              end

              def Helper.date_time_iso8601_to_string(value)
                value.nil? ? nil : value.strftime('%Y-%m-%dT%H:%M:%S%z')
              end

              TRUE_STRINGS = ['t', 'true', 'y', 'yes', 'on', '1', 'trueclass'] unless defined?(TRUE_STRINGS)
              FALSE_STRINGS = ['f', 'false', 'n', 'no', 'off', '0', 'falseclass'] unless defined?(FALSE_STRINGS)

              def Helper.to_boolean(field_name, value)
                string = value.to_s.strip.downcase
                if TRUE_STRINGS.include?(string)
                  true
                elsif FALSE_STRINGS.include?(string)
                  false
                elsif string != ""
                  raise PreconditionException.new("Unsupported boolean value[#{string}]. For true, must be one of: #{TRUE_STRINGS.inspect}. For false, must be one of: #{FALSE_STRINGS.inspect}")
                else
                  nil
                end
              end

            end

          end
        end
      end
    end
  end
end