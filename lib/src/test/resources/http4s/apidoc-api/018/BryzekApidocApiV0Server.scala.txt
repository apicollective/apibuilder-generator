/**
 * Generated by API Builder - https://www.apibuilder.io
 * Service version: 0.11.17
 */
package io.apibuilder.api.v0.server

import org.http4s.circe.decodeUri
import org.http4s.circe.encodeUri
import org.http4s.dsl.{io => _, _}
import cats.effect._
import cats.implicits._
import scala.language.higherKinds
import io.apibuilder.api.v0.models.json._
import io.apibuilder.common.v0.models.json._
import io.apibuilder.generator.v0.models.json._
import io.apibuilder.spec.v0.models.json._

private[server] trait Matchers[F[_]] extends Http4sDsl[F] {

  implicit lazy val queryParamDecodeBigDecimal: org.http4s.QueryParamDecoder[BigDecimal] =
    org.http4s.QueryParamDecoder.fromUnsafeCast[BigDecimal](p => BigDecimal(p.value))("BigDecimal")

  implicit lazy val queryParamDecodeInstant: org.http4s.QueryParamDecoder[_root_.java.time.Instant] =
    org.http4s.QueryParamDecoder.fromUnsafeCast[_root_.java.time.Instant](p => _root_.java.time.OffsetDateTime.parse(p.value).toInstant)("_root_.java.time.Instant")

  implicit lazy val queryParamDecodeLocalDate: org.http4s.QueryParamDecoder[_root_.java.time.LocalDate] =
    org.http4s.QueryParamDecoder.fromUnsafeCast[_root_.java.time.LocalDate](p => _root_.java.time.LocalDate.parse(p.value))("_root_.java.time.LocalDate")

  implicit lazy val queryParamDecodeUUID: org.http4s.QueryParamDecoder[_root_.java.util.UUID] =
    org.http4s.QueryParamDecoder.fromUnsafeCast[_root_.java.util.UUID](p => _root_.java.util.UUID.fromString(p.value))("_root_.java.util.UUID")

  implicit lazy val publicationQueryParamDecoder: org.http4s.QueryParamDecoder[io.apibuilder.api.v0.models.Publication] =
    org.http4s.QueryParamDecoder.fromUnsafeCast[io.apibuilder.api.v0.models.Publication](p => io.apibuilder.api.v0.models.Publication.fromString(p.value).get)("io.apibuilder.api.v0.models.Publication")

  object ApiVersion {
    val ApiVersionMajor = {
      "X-Apidoc-Version-Major".ci
    }

    def apply(req: org.http4s.Message[F]): Boolean = req.headers.get(ApiVersionMajor) match {
      case Some(v) if v.value == "0" => true
      case _ => false
    }
  }

  object UUIDVal {
    def unapply(s: String): Option[_root_.java.util.UUID] = scala.util.Try(_root_.java.util.UUID.fromString(s)).toOption
  }

  object ApplicationKeyOptStringMatcher extends OptionalQueryParamDecoderMatcher[String]("application_key")

  object ApplicationKeyStringMatcher extends QueryParamDecoderMatcher[String]("application_key")

  object AttributeNameOptStringMatcher extends OptionalQueryParamDecoderMatcher[String]("attribute_name")

  object EmailOptStringMatcher extends OptionalQueryParamDecoderMatcher[String]("email")

  object GeneratorKeyOptStringMatcher extends OptionalQueryParamDecoderMatcher[String]("generator_key")

  object GuidOptUUIDMatcher extends OptionalQueryParamDecoderMatcher[_root_.java.util.UUID]("guid")

  object HasVersionOptBooleanMatcher extends OptionalQueryParamDecoderMatcher[Boolean]("has_version")

  object KeyOptStringMatcher extends OptionalQueryParamDecoderMatcher[String]("key")

  object LimitLong1To100Def100Matcher extends QueryParamDecoderMatcher[Long]("limit") {
    override def unapply(params: Map[String, Seq[String]]) = super.unapply(params).orElse(Some(100L)).filter(v => v >= 1 && v <= 100)
  }

  object LimitLong1To100Def25Matcher extends QueryParamDecoderMatcher[Long]("limit") {
    override def unapply(params: Map[String, Seq[String]]) = super.unapply(params).orElse(Some(25L)).filter(v => v >= 1 && v <= 100)
  }

  object LimitLongTo100Def25Matcher extends QueryParamDecoderMatcher[Long]("limit") {
    override def unapply(params: Map[String, Seq[String]]) = super.unapply(params).orElse(Some(25L)).filter(_ <= 100)
  }

  object NameOptStringMatcher extends OptionalQueryParamDecoderMatcher[String]("name")

  object NamespaceOptStringMatcher extends OptionalQueryParamDecoderMatcher[String]("namespace")

  object OffsetLong0Def0Matcher extends QueryParamDecoderMatcher[Long]("offset") {
    override def unapply(params: Map[String, Seq[String]]) = super.unapply(params).orElse(Some(0L)).filter(_ >= 0)
  }

  object OrgGuidOptUUIDMatcher extends OptionalQueryParamDecoderMatcher[_root_.java.util.UUID]("org_guid")

  object OrgKeyOptStringMatcher extends OptionalQueryParamDecoderMatcher[String]("org_key")

  object OrganizationKeyOptStringMatcher extends OptionalQueryParamDecoderMatcher[String]("organization_key")

  object OrganizationKeyStringMatcher extends QueryParamDecoderMatcher[String]("organization_key")

  object PublicationOptPublicationMatcher extends OptionalQueryParamDecoderMatcher[io.apibuilder.api.v0.models.Publication]("publication")

  object QOptStringMatcher extends OptionalQueryParamDecoderMatcher[String]("q")

  object RoleOptStringMatcher extends OptionalQueryParamDecoderMatcher[String]("role")

  object ServiceGuidOptUUIDMatcher extends OptionalQueryParamDecoderMatcher[_root_.java.util.UUID]("service_guid")

  object ServiceUriOptStringMatcher extends OptionalQueryParamDecoderMatcher[String]("service_uri")

  object TokenOptStringMatcher extends OptionalQueryParamDecoderMatcher[String]("token")

  object UriOptStringMatcher extends OptionalQueryParamDecoderMatcher[String]("uri")

  object UserGuidOptUUIDMatcher extends OptionalQueryParamDecoderMatcher[_root_.java.util.UUID]("user_guid")
}

trait ApplicationRoutes[F[_]] extends Matchers[F] {

  implicit def circeJsonDecoder[A](implicit decoder: _root_.io.circe.Decoder[A], sync: Sync[F]) = org.http4s.circe.jsonOf[F, A]
  implicit def circeJsonEncoder[A](implicit encoder: _root_.io.circe.Encoder[A], sync: Sync[F]) = org.http4s.circe.jsonEncoderOf[F, A]

  sealed trait GetResponse

  object GetResponse {
    case class HTTP200(value: Seq[io.apibuilder.api.v0.models.Application], headers: Seq[org.http4s.Header] = Nil) extends GetResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends GetResponse
  }

  def get(
    _req: org.http4s.Request[F],
    orgKey: String,
    name: _root_.scala.Option[String],
    guid: _root_.scala.Option[_root_.java.util.UUID],
    key: _root_.scala.Option[String],
    hasVersion: _root_.scala.Option[Boolean],
    limit: Long,
    offset: Long
  ): F[GetResponse]

  sealed trait PostResponse

  object PostResponse {
    case class HTTP200(value: io.apibuilder.api.v0.models.Application, headers: Seq[org.http4s.Header] = Nil) extends PostResponse
    case class HTTP409(value: Seq[io.apibuilder.api.v0.models.Error], headers: Seq[org.http4s.Header] = Nil) extends PostResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends PostResponse
  }

  def post(
    _req: org.http4s.Request[F],
    orgKey: String,
    body: => org.http4s.DecodeResult[F, io.apibuilder.api.v0.models.ApplicationForm]
  ): F[PostResponse]

  sealed trait PutByApplicationKeyResponse

  object PutByApplicationKeyResponse {
    case class HTTP200(value: io.apibuilder.api.v0.models.Application, headers: Seq[org.http4s.Header] = Nil) extends PutByApplicationKeyResponse
    case class HTTP409(value: Seq[io.apibuilder.api.v0.models.Error], headers: Seq[org.http4s.Header] = Nil) extends PutByApplicationKeyResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends PutByApplicationKeyResponse
  }

  def putByApplicationKey(
    _req: org.http4s.Request[F],
    orgKey: String,
    applicationKey: String,
    body: => org.http4s.DecodeResult[F, io.apibuilder.api.v0.models.ApplicationForm]
  ): F[PutByApplicationKeyResponse]

  sealed trait DeleteByApplicationKeyResponse

  object DeleteByApplicationKeyResponse {
    case class HTTP204(headers: Seq[org.http4s.Header] = Nil) extends DeleteByApplicationKeyResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends DeleteByApplicationKeyResponse
  }

  def deleteByApplicationKey(
    _req: org.http4s.Request[F],
    orgKey: String,
    applicationKey: String
  ): F[DeleteByApplicationKeyResponse]

  sealed trait PostMoveByApplicationKeyResponse

  object PostMoveByApplicationKeyResponse {
    case class HTTP200(value: io.apibuilder.api.v0.models.Application, headers: Seq[org.http4s.Header] = Nil) extends PostMoveByApplicationKeyResponse
    case class HTTP409(value: Seq[io.apibuilder.api.v0.models.Error], headers: Seq[org.http4s.Header] = Nil) extends PostMoveByApplicationKeyResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends PostMoveByApplicationKeyResponse
  }

  def postMoveByApplicationKey(
    _req: org.http4s.Request[F],
    orgKey: String,
    applicationKey: String,
    body: => org.http4s.DecodeResult[F, io.apibuilder.api.v0.models.MoveForm]
  ): F[PostMoveByApplicationKeyResponse]

  def apiVersionMatch(req: org.http4s.Message[F]): Boolean = ApiVersion(req)

  def service()(implicit sync: Sync[F]) = org.http4s.HttpService[F] {
    case _req @ GET -> Root / orgKey :? NameOptStringMatcher(name) +& GuidOptUUIDMatcher(guid) +& KeyOptStringMatcher(key) +& HasVersionOptBooleanMatcher(hasVersion) +& LimitLongTo100Def25Matcher(limit) +& OffsetLong0Def0Matcher(offset) if apiVersionMatch(_req) =>
      get(_req, orgKey, name, guid, key, hasVersion, limit, offset).flatMap {
        case GetResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case GetResponse.UndocumentedResponse(response) => response
      }
    case _req @ GET -> Root / orgKey :? NameOptStringMatcher(name) +& GuidOptUUIDMatcher(guid) +& KeyOptStringMatcher(key) +& HasVersionOptBooleanMatcher(hasVersion) +& LimitLongTo100Def25Matcher(limit) +& OffsetLong0Def0Matcher(offset) if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ POST -> Root / orgKey if apiVersionMatch(_req) =>
      post(_req, orgKey, _req.attemptAs[io.apibuilder.api.v0.models.ApplicationForm]).flatMap {
        case PostResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case PostResponse.HTTP409(value, headers) => Conflict(value, headers: _*)
        case PostResponse.UndocumentedResponse(response) => response
      }
    case _req @ POST -> Root / orgKey if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ PUT -> Root / orgKey / applicationKey if apiVersionMatch(_req) =>
      putByApplicationKey(_req, orgKey, applicationKey, _req.attemptAs[io.apibuilder.api.v0.models.ApplicationForm]).flatMap {
        case PutByApplicationKeyResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case PutByApplicationKeyResponse.HTTP409(value, headers) => Conflict(value, headers: _*)
        case PutByApplicationKeyResponse.UndocumentedResponse(response) => response
      }
    case _req @ PUT -> Root / orgKey / applicationKey if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ DELETE -> Root / orgKey / applicationKey if apiVersionMatch(_req) =>
      deleteByApplicationKey(_req, orgKey, applicationKey).flatMap {
        case DeleteByApplicationKeyResponse.HTTP204(headers) => NoContent(headers: _*)
        case DeleteByApplicationKeyResponse.UndocumentedResponse(response) => response
      }
    case _req @ DELETE -> Root / orgKey / applicationKey if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ POST -> Root / orgKey / applicationKey / "move" if apiVersionMatch(_req) =>
      postMoveByApplicationKey(_req, orgKey, applicationKey, _req.attemptAs[io.apibuilder.api.v0.models.MoveForm]).flatMap {
        case PostMoveByApplicationKeyResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case PostMoveByApplicationKeyResponse.HTTP409(value, headers) => Conflict(value, headers: _*)
        case PostMoveByApplicationKeyResponse.UndocumentedResponse(response) => response
      }
    case _req @ POST -> Root / orgKey / applicationKey / "move" if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")
  }
}

trait AttributeRoutes[F[_]] extends Matchers[F] {

  implicit def circeJsonDecoder[A](implicit decoder: _root_.io.circe.Decoder[A], sync: Sync[F]) = org.http4s.circe.jsonOf[F, A]
  implicit def circeJsonEncoder[A](implicit encoder: _root_.io.circe.Encoder[A], sync: Sync[F]) = org.http4s.circe.jsonEncoderOf[F, A]

  sealed trait GetResponse

  object GetResponse {
    case class HTTP200(value: Seq[io.apibuilder.api.v0.models.Attribute], headers: Seq[org.http4s.Header] = Nil) extends GetResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends GetResponse
  }

  def get(
    _req: org.http4s.Request[F],
    guid: _root_.scala.Option[_root_.java.util.UUID],
    name: _root_.scala.Option[String],
    limit: Long,
    offset: Long
  ): F[GetResponse]

  sealed trait GetByNameResponse

  object GetByNameResponse {
    case class HTTP200(value: io.apibuilder.api.v0.models.Attribute, headers: Seq[org.http4s.Header] = Nil) extends GetByNameResponse
    case class HTTP404(headers: Seq[org.http4s.Header] = Nil) extends GetByNameResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends GetByNameResponse
  }

  def getByName(
    _req: org.http4s.Request[F],
    name: String
  ): F[GetByNameResponse]

  sealed trait PostResponse

  object PostResponse {
    case class HTTP201(value: io.apibuilder.api.v0.models.Attribute, headers: Seq[org.http4s.Header] = Nil) extends PostResponse
    case class HTTP401(authenticate: org.http4s.headers.`WWW-Authenticate`, headers: Seq[org.http4s.Header] = Nil) extends PostResponse
    case class HTTP409(value: Seq[io.apibuilder.api.v0.models.Error], headers: Seq[org.http4s.Header] = Nil) extends PostResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends PostResponse
  }

  def post(
    _req: org.http4s.Request[F],
    body: => org.http4s.DecodeResult[F, io.apibuilder.api.v0.models.AttributeForm]
  ): F[PostResponse]

  sealed trait DeleteByNameResponse

  object DeleteByNameResponse {
    case class HTTP204(headers: Seq[org.http4s.Header] = Nil) extends DeleteByNameResponse
    case class HTTP401(authenticate: org.http4s.headers.`WWW-Authenticate`, headers: Seq[org.http4s.Header] = Nil) extends DeleteByNameResponse
    case class HTTP404(headers: Seq[org.http4s.Header] = Nil) extends DeleteByNameResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends DeleteByNameResponse
  }

  def deleteByName(
    _req: org.http4s.Request[F],
    name: String
  ): F[DeleteByNameResponse]

  def apiVersionMatch(req: org.http4s.Message[F]): Boolean = ApiVersion(req)

  def service()(implicit sync: Sync[F]) = org.http4s.HttpService[F] {
    case _req @ GET -> Root / "attributes" :? GuidOptUUIDMatcher(guid) +& NameOptStringMatcher(name) +& LimitLong1To100Def25Matcher(limit) +& OffsetLong0Def0Matcher(offset) if apiVersionMatch(_req) =>
      get(_req, guid, name, limit, offset).flatMap {
        case GetResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case GetResponse.UndocumentedResponse(response) => response
      }
    case _req @ GET -> Root / "attributes" :? GuidOptUUIDMatcher(guid) +& NameOptStringMatcher(name) +& LimitLong1To100Def25Matcher(limit) +& OffsetLong0Def0Matcher(offset) if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ GET -> Root / "attributes" / name if apiVersionMatch(_req) =>
      getByName(_req, name).flatMap {
        case GetByNameResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case GetByNameResponse.HTTP404(headers) => NotFound(headers: _*)
        case GetByNameResponse.UndocumentedResponse(response) => response
      }
    case _req @ GET -> Root / "attributes" / name if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ POST -> Root / "attributes" if apiVersionMatch(_req) =>
      post(_req, _req.attemptAs[io.apibuilder.api.v0.models.AttributeForm]).flatMap {
        case PostResponse.HTTP201(value, headers) => Created(value, headers: _*)
        case PostResponse.HTTP401(authenticate, headers) => Unauthorized(authenticate, headers: _*)
        case PostResponse.HTTP409(value, headers) => Conflict(value, headers: _*)
        case PostResponse.UndocumentedResponse(response) => response
      }
    case _req @ POST -> Root / "attributes" if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ DELETE -> Root / "attributes" / name if apiVersionMatch(_req) =>
      deleteByName(_req, name).flatMap {
        case DeleteByNameResponse.HTTP204(headers) => NoContent(headers: _*)
        case DeleteByNameResponse.HTTP401(authenticate, headers) => Unauthorized(authenticate, headers: _*)
        case DeleteByNameResponse.HTTP404(headers) => NotFound(headers: _*)
        case DeleteByNameResponse.UndocumentedResponse(response) => response
      }
    case _req @ DELETE -> Root / "attributes" / name if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")
  }
}

trait ChangeRoutes[F[_]] extends Matchers[F] {

  implicit def circeJsonDecoder[A](implicit decoder: _root_.io.circe.Decoder[A], sync: Sync[F]) = org.http4s.circe.jsonOf[F, A]
  implicit def circeJsonEncoder[A](implicit encoder: _root_.io.circe.Encoder[A], sync: Sync[F]) = org.http4s.circe.jsonEncoderOf[F, A]

  sealed trait GetResponse

  object GetResponse {
    case class HTTP200(value: Seq[io.apibuilder.api.v0.models.Change], headers: Seq[org.http4s.Header] = Nil) extends GetResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends GetResponse
  }

  def get(
    _req: org.http4s.Request[F],
    orgKey: _root_.scala.Option[String],
    applicationKey: _root_.scala.Option[String],
    limit: Long,
    offset: Long
  ): F[GetResponse]

  def apiVersionMatch(req: org.http4s.Message[F]): Boolean = ApiVersion(req)

  def service()(implicit sync: Sync[F]) = org.http4s.HttpService[F] {
    case _req @ GET -> Root / "changes" :? OrgKeyOptStringMatcher(orgKey) +& ApplicationKeyOptStringMatcher(applicationKey) +& LimitLong1To100Def25Matcher(limit) +& OffsetLong0Def0Matcher(offset) if apiVersionMatch(_req) =>
      get(_req, orgKey, applicationKey, limit, offset).flatMap {
        case GetResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case GetResponse.UndocumentedResponse(response) => response
      }
    case _req @ GET -> Root / "changes" :? OrgKeyOptStringMatcher(orgKey) +& ApplicationKeyOptStringMatcher(applicationKey) +& LimitLong1To100Def25Matcher(limit) +& OffsetLong0Def0Matcher(offset) if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")
  }
}

trait CodeRoutes[F[_]] extends Matchers[F] {

  implicit def circeJsonDecoder[A](implicit decoder: _root_.io.circe.Decoder[A], sync: Sync[F]) = org.http4s.circe.jsonOf[F, A]
  implicit def circeJsonEncoder[A](implicit encoder: _root_.io.circe.Encoder[A], sync: Sync[F]) = org.http4s.circe.jsonEncoderOf[F, A]

  sealed trait GetResponse

  object GetResponse {
    case class HTTP200(value: io.apibuilder.api.v0.models.Code, headers: Seq[org.http4s.Header] = Nil) extends GetResponse
    case class HTTP404(headers: Seq[org.http4s.Header] = Nil) extends GetResponse
    case class HTTP409(value: Seq[io.apibuilder.api.v0.models.Error], headers: Seq[org.http4s.Header] = Nil) extends GetResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends GetResponse
  }

  def get(
    _req: org.http4s.Request[F],
    orgKey: String,
    applicationKey: String,
    version: String,
    generatorKey: String
  ): F[GetResponse]

  def apiVersionMatch(req: org.http4s.Message[F]): Boolean = ApiVersion(req)

  def service()(implicit sync: Sync[F]) = org.http4s.HttpService[F] {
    case _req @ GET -> Root / orgKey / applicationKey / version / generatorKey if apiVersionMatch(_req) =>
      get(_req, orgKey, applicationKey, version, generatorKey).flatMap {
        case GetResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case GetResponse.HTTP404(headers) => NotFound(headers: _*)
        case GetResponse.HTTP409(value, headers) => Conflict(value, headers: _*)
        case GetResponse.UndocumentedResponse(response) => response
      }
    case _req @ GET -> Root / orgKey / applicationKey / version / generatorKey if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")
  }
}

trait DomainRoutes[F[_]] extends Matchers[F] {

  implicit def circeJsonDecoder[A](implicit decoder: _root_.io.circe.Decoder[A], sync: Sync[F]) = org.http4s.circe.jsonOf[F, A]
  implicit def circeJsonEncoder[A](implicit encoder: _root_.io.circe.Encoder[A], sync: Sync[F]) = org.http4s.circe.jsonEncoderOf[F, A]

  sealed trait PostResponse

  object PostResponse {
    case class HTTP200(value: io.apibuilder.api.v0.models.Domain, headers: Seq[org.http4s.Header] = Nil) extends PostResponse
    case class HTTP409(value: Seq[io.apibuilder.api.v0.models.Error], headers: Seq[org.http4s.Header] = Nil) extends PostResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends PostResponse
  }

  def post(
    _req: org.http4s.Request[F],
    orgKey: String,
    body: => org.http4s.DecodeResult[F, io.apibuilder.api.v0.models.Domain]
  ): F[PostResponse]

  sealed trait DeleteByNameResponse

  object DeleteByNameResponse {
    case class HTTP204(headers: Seq[org.http4s.Header] = Nil) extends DeleteByNameResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends DeleteByNameResponse
  }

  def deleteByName(
    _req: org.http4s.Request[F],
    orgKey: String,
    name: String
  ): F[DeleteByNameResponse]

  def apiVersionMatch(req: org.http4s.Message[F]): Boolean = ApiVersion(req)

  def service()(implicit sync: Sync[F]) = org.http4s.HttpService[F] {
    case _req @ POST -> Root / "domains" / orgKey if apiVersionMatch(_req) =>
      post(_req, orgKey, _req.attemptAs[io.apibuilder.api.v0.models.Domain]).flatMap {
        case PostResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case PostResponse.HTTP409(value, headers) => Conflict(value, headers: _*)
        case PostResponse.UndocumentedResponse(response) => response
      }
    case _req @ POST -> Root / "domains" / orgKey if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ DELETE -> Root / "domains" / orgKey / name if apiVersionMatch(_req) =>
      deleteByName(_req, orgKey, name).flatMap {
        case DeleteByNameResponse.HTTP204(headers) => NoContent(headers: _*)
        case DeleteByNameResponse.UndocumentedResponse(response) => response
      }
    case _req @ DELETE -> Root / "domains" / orgKey / name if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")
  }
}

trait EmailVerificationConfirmationFormRoutes[F[_]] extends Matchers[F] {

  implicit def circeJsonDecoder[A](implicit decoder: _root_.io.circe.Decoder[A], sync: Sync[F]) = org.http4s.circe.jsonOf[F, A]
  implicit def circeJsonEncoder[A](implicit encoder: _root_.io.circe.Encoder[A], sync: Sync[F]) = org.http4s.circe.jsonEncoderOf[F, A]

  sealed trait PostResponse

  object PostResponse {
    case class HTTP204(headers: Seq[org.http4s.Header] = Nil) extends PostResponse
    case class HTTP409(value: Seq[io.apibuilder.api.v0.models.Error], headers: Seq[org.http4s.Header] = Nil) extends PostResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends PostResponse
  }

  def post(
    _req: org.http4s.Request[F],
    body: => org.http4s.DecodeResult[F, io.apibuilder.api.v0.models.EmailVerificationConfirmationForm]
  ): F[PostResponse]

  def apiVersionMatch(req: org.http4s.Message[F]): Boolean = ApiVersion(req)

  def service()(implicit sync: Sync[F]) = org.http4s.HttpService[F] {
    case _req @ POST -> Root / "email_verification_confirmations" if apiVersionMatch(_req) =>
      post(_req, _req.attemptAs[io.apibuilder.api.v0.models.EmailVerificationConfirmationForm]).flatMap {
        case PostResponse.HTTP204(headers) => NoContent(headers: _*)
        case PostResponse.HTTP409(value, headers) => Conflict(value, headers: _*)
        case PostResponse.UndocumentedResponse(response) => response
      }
    case _req @ POST -> Root / "email_verification_confirmations" if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")
  }
}

trait GeneratorServiceRoutes[F[_]] extends Matchers[F] {

  implicit def circeJsonDecoder[A](implicit decoder: _root_.io.circe.Decoder[A], sync: Sync[F]) = org.http4s.circe.jsonOf[F, A]
  implicit def circeJsonEncoder[A](implicit encoder: _root_.io.circe.Encoder[A], sync: Sync[F]) = org.http4s.circe.jsonEncoderOf[F, A]

  sealed trait GetResponse

  object GetResponse {
    case class HTTP200(value: Seq[io.apibuilder.api.v0.models.GeneratorService], headers: Seq[org.http4s.Header] = Nil) extends GetResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends GetResponse
  }

  def get(
    _req: org.http4s.Request[F],
    guid: _root_.scala.Option[_root_.java.util.UUID],
    uri: _root_.scala.Option[String],
    generatorKey: _root_.scala.Option[String],
    limit: Long,
    offset: Long
  ): F[GetResponse]

  sealed trait GetByGuidResponse

  object GetByGuidResponse {
    case class HTTP200(value: io.apibuilder.api.v0.models.GeneratorService, headers: Seq[org.http4s.Header] = Nil) extends GetByGuidResponse
    case class HTTP404(headers: Seq[org.http4s.Header] = Nil) extends GetByGuidResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends GetByGuidResponse
  }

  def getByGuid(
    _req: org.http4s.Request[F],
    guid: _root_.java.util.UUID
  ): F[GetByGuidResponse]

  sealed trait PostResponse

  object PostResponse {
    case class HTTP200(value: io.apibuilder.api.v0.models.GeneratorService, headers: Seq[org.http4s.Header] = Nil) extends PostResponse
    case class HTTP409(value: Seq[io.apibuilder.api.v0.models.Error], headers: Seq[org.http4s.Header] = Nil) extends PostResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends PostResponse
  }

  def post(
    _req: org.http4s.Request[F],
    body: => org.http4s.DecodeResult[F, io.apibuilder.api.v0.models.GeneratorServiceForm]
  ): F[PostResponse]

  sealed trait DeleteByGuidResponse

  object DeleteByGuidResponse {
    case class HTTP204(headers: Seq[org.http4s.Header] = Nil) extends DeleteByGuidResponse
    case class HTTP403(headers: Seq[org.http4s.Header] = Nil) extends DeleteByGuidResponse
    case class HTTP404(headers: Seq[org.http4s.Header] = Nil) extends DeleteByGuidResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends DeleteByGuidResponse
  }

  def deleteByGuid(
    _req: org.http4s.Request[F],
    guid: _root_.java.util.UUID
  ): F[DeleteByGuidResponse]

  def apiVersionMatch(req: org.http4s.Message[F]): Boolean = ApiVersion(req)

  def service()(implicit sync: Sync[F]) = org.http4s.HttpService[F] {
    case _req @ GET -> Root / "generator_services" :? GuidOptUUIDMatcher(guid) +& UriOptStringMatcher(uri) +& GeneratorKeyOptStringMatcher(generatorKey) +& LimitLong1To100Def100Matcher(limit) +& OffsetLong0Def0Matcher(offset) if apiVersionMatch(_req) =>
      get(_req, guid, uri, generatorKey, limit, offset).flatMap {
        case GetResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case GetResponse.UndocumentedResponse(response) => response
      }
    case _req @ GET -> Root / "generator_services" :? GuidOptUUIDMatcher(guid) +& UriOptStringMatcher(uri) +& GeneratorKeyOptStringMatcher(generatorKey) +& LimitLong1To100Def100Matcher(limit) +& OffsetLong0Def0Matcher(offset) if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ GET -> Root / "generator_services" / UUIDVal(guid) if apiVersionMatch(_req) =>
      getByGuid(_req, guid).flatMap {
        case GetByGuidResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case GetByGuidResponse.HTTP404(headers) => NotFound(headers: _*)
        case GetByGuidResponse.UndocumentedResponse(response) => response
      }
    case _req @ GET -> Root / "generator_services" / UUIDVal(guid) if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ POST -> Root / "generator_services" if apiVersionMatch(_req) =>
      post(_req, _req.attemptAs[io.apibuilder.api.v0.models.GeneratorServiceForm]).flatMap {
        case PostResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case PostResponse.HTTP409(value, headers) => Conflict(value, headers: _*)
        case PostResponse.UndocumentedResponse(response) => response
      }
    case _req @ POST -> Root / "generator_services" if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ DELETE -> Root / "generator_services" / UUIDVal(guid) if apiVersionMatch(_req) =>
      deleteByGuid(_req, guid).flatMap {
        case DeleteByGuidResponse.HTTP204(headers) => NoContent(headers: _*)
        case DeleteByGuidResponse.HTTP403(headers) => Forbidden(headers: _*)
        case DeleteByGuidResponse.HTTP404(headers) => NotFound(headers: _*)
        case DeleteByGuidResponse.UndocumentedResponse(response) => response
      }
    case _req @ DELETE -> Root / "generator_services" / UUIDVal(guid) if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")
  }
}

trait GeneratorWithServiceRoutes[F[_]] extends Matchers[F] {

  implicit def circeJsonDecoder[A](implicit decoder: _root_.io.circe.Decoder[A], sync: Sync[F]) = org.http4s.circe.jsonOf[F, A]
  implicit def circeJsonEncoder[A](implicit encoder: _root_.io.circe.Encoder[A], sync: Sync[F]) = org.http4s.circe.jsonEncoderOf[F, A]

  sealed trait GetResponse

  object GetResponse {
    case class HTTP200(value: Seq[io.apibuilder.api.v0.models.GeneratorWithService], headers: Seq[org.http4s.Header] = Nil) extends GetResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends GetResponse
  }

  def get(
    _req: org.http4s.Request[F],
    guid: _root_.scala.Option[_root_.java.util.UUID],
    serviceGuid: _root_.scala.Option[_root_.java.util.UUID],
    serviceUri: _root_.scala.Option[String],
    attributeName: _root_.scala.Option[String],
    key: _root_.scala.Option[String],
    limit: Long,
    offset: Long
  ): F[GetResponse]

  sealed trait GetByKeyResponse

  object GetByKeyResponse {
    case class HTTP200(value: io.apibuilder.api.v0.models.GeneratorWithService, headers: Seq[org.http4s.Header] = Nil) extends GetByKeyResponse
    case class HTTP404(headers: Seq[org.http4s.Header] = Nil) extends GetByKeyResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends GetByKeyResponse
  }

  def getByKey(
    _req: org.http4s.Request[F],
    key: String
  ): F[GetByKeyResponse]

  def apiVersionMatch(req: org.http4s.Message[F]): Boolean = ApiVersion(req)

  def service()(implicit sync: Sync[F]) = org.http4s.HttpService[F] {
    case _req @ GET -> Root / "generators" :? GuidOptUUIDMatcher(guid) +& ServiceGuidOptUUIDMatcher(serviceGuid) +& ServiceUriOptStringMatcher(serviceUri) +& AttributeNameOptStringMatcher(attributeName) +& KeyOptStringMatcher(key) +& LimitLong1To100Def100Matcher(limit) +& OffsetLong0Def0Matcher(offset) if apiVersionMatch(_req) =>
      get(_req, guid, serviceGuid, serviceUri, attributeName, key, limit, offset).flatMap {
        case GetResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case GetResponse.UndocumentedResponse(response) => response
      }
    case _req @ GET -> Root / "generators" :? GuidOptUUIDMatcher(guid) +& ServiceGuidOptUUIDMatcher(serviceGuid) +& ServiceUriOptStringMatcher(serviceUri) +& AttributeNameOptStringMatcher(attributeName) +& KeyOptStringMatcher(key) +& LimitLong1To100Def100Matcher(limit) +& OffsetLong0Def0Matcher(offset) if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ GET -> Root / "generators" / key if apiVersionMatch(_req) =>
      getByKey(_req, key).flatMap {
        case GetByKeyResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case GetByKeyResponse.HTTP404(headers) => NotFound(headers: _*)
        case GetByKeyResponse.UndocumentedResponse(response) => response
      }
    case _req @ GET -> Root / "generators" / key if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")
  }
}

trait IoApibuilderGeneratorV0ModelsHealthcheckRoutes[F[_]] extends Matchers[F] {

  implicit def circeJsonDecoder[A](implicit decoder: _root_.io.circe.Decoder[A], sync: Sync[F]) = org.http4s.circe.jsonOf[F, A]
  implicit def circeJsonEncoder[A](implicit encoder: _root_.io.circe.Encoder[A], sync: Sync[F]) = org.http4s.circe.jsonEncoderOf[F, A]

  sealed trait GetHealthcheckResponse

  object GetHealthcheckResponse {
    case class HTTP200(value: io.apibuilder.generator.v0.models.Healthcheck, headers: Seq[org.http4s.Header] = Nil) extends GetHealthcheckResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends GetHealthcheckResponse
  }

  def getHealthcheck(
    _req: org.http4s.Request[F]
  ): F[GetHealthcheckResponse]

  sealed trait GetMigrateResponse

  object GetMigrateResponse {
    case class HTTP200(value: Map[String, String], headers: Seq[org.http4s.Header] = Nil) extends GetMigrateResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends GetMigrateResponse
  }

  def getMigrate(
    _req: org.http4s.Request[F]
  ): F[GetMigrateResponse]

  def apiVersionMatch(req: org.http4s.Message[F]): Boolean = ApiVersion(req)

  def service()(implicit sync: Sync[F]) = org.http4s.HttpService[F] {
    case _req @ GET -> Root / "_internal_" / "healthcheck" if apiVersionMatch(_req) =>
      getHealthcheck(_req).flatMap {
        case GetHealthcheckResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case GetHealthcheckResponse.UndocumentedResponse(response) => response
      }
    case _req @ GET -> Root / "_internal_" / "healthcheck" if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ GET -> Root / "_internal_" / "migrate" if apiVersionMatch(_req) =>
      getMigrate(_req).flatMap {
        case GetMigrateResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case GetMigrateResponse.UndocumentedResponse(response) => response
      }
    case _req @ GET -> Root / "_internal_" / "migrate" if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")
  }
}

trait ItemRoutes[F[_]] extends Matchers[F] {

  implicit def circeJsonDecoder[A](implicit decoder: _root_.io.circe.Decoder[A], sync: Sync[F]) = org.http4s.circe.jsonOf[F, A]
  implicit def circeJsonEncoder[A](implicit encoder: _root_.io.circe.Encoder[A], sync: Sync[F]) = org.http4s.circe.jsonEncoderOf[F, A]

  sealed trait GetResponse

  object GetResponse {
    case class HTTP200(value: Seq[io.apibuilder.api.v0.models.Item], headers: Seq[org.http4s.Header] = Nil) extends GetResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends GetResponse
  }

  def get(
    _req: org.http4s.Request[F],
    q: _root_.scala.Option[String],
    limit: Long,
    offset: Long
  ): F[GetResponse]

  sealed trait GetByGuidResponse

  object GetByGuidResponse {
    case class HTTP200(value: io.apibuilder.api.v0.models.Item, headers: Seq[org.http4s.Header] = Nil) extends GetByGuidResponse
    case class HTTP404(headers: Seq[org.http4s.Header] = Nil) extends GetByGuidResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends GetByGuidResponse
  }

  def getByGuid(
    _req: org.http4s.Request[F],
    guid: _root_.java.util.UUID
  ): F[GetByGuidResponse]

  def apiVersionMatch(req: org.http4s.Message[F]): Boolean = ApiVersion(req)

  def service()(implicit sync: Sync[F]) = org.http4s.HttpService[F] {
    case _req @ GET -> Root / "items" :? QOptStringMatcher(q) +& LimitLong1To100Def25Matcher(limit) +& OffsetLong0Def0Matcher(offset) if apiVersionMatch(_req) =>
      get(_req, q, limit, offset).flatMap {
        case GetResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case GetResponse.UndocumentedResponse(response) => response
      }
    case _req @ GET -> Root / "items" :? QOptStringMatcher(q) +& LimitLong1To100Def25Matcher(limit) +& OffsetLong0Def0Matcher(offset) if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ GET -> Root / "items" / UUIDVal(guid) if apiVersionMatch(_req) =>
      getByGuid(_req, guid).flatMap {
        case GetByGuidResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case GetByGuidResponse.HTTP404(headers) => NotFound(headers: _*)
        case GetByGuidResponse.UndocumentedResponse(response) => response
      }
    case _req @ GET -> Root / "items" / UUIDVal(guid) if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")
  }
}

trait MembershipRequestRoutes[F[_]] extends Matchers[F] {

  implicit def circeJsonDecoder[A](implicit decoder: _root_.io.circe.Decoder[A], sync: Sync[F]) = org.http4s.circe.jsonOf[F, A]
  implicit def circeJsonEncoder[A](implicit encoder: _root_.io.circe.Encoder[A], sync: Sync[F]) = org.http4s.circe.jsonEncoderOf[F, A]

  sealed trait GetResponse

  object GetResponse {
    case class HTTP200(value: Seq[io.apibuilder.api.v0.models.MembershipRequest], headers: Seq[org.http4s.Header] = Nil) extends GetResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends GetResponse
  }

  def get(
    _req: org.http4s.Request[F],
    orgGuid: _root_.scala.Option[_root_.java.util.UUID],
    orgKey: _root_.scala.Option[String],
    userGuid: _root_.scala.Option[_root_.java.util.UUID],
    role: _root_.scala.Option[String],
    limit: Long,
    offset: Long
  ): F[GetResponse]

  case class PostRequest(orgGuid: _root_.java.util.UUID, userGuid: _root_.java.util.UUID, role: String)

  implicit val PostRequestDecoder: _root_.io.circe.Decoder[PostRequest] = _root_.io.circe.Decoder.instance { a =>
    for {
      orgGuid <- a.downField("org_guid").as[_root_.java.util.UUID]
      userGuid <- a.downField("user_guid").as[_root_.java.util.UUID]
      role <- a.downField("role").as[String]
    } yield {
      PostRequest(
        orgGuid = orgGuid,
        userGuid = userGuid,
        role = role
      )
    }
  }

  sealed trait PostResponse

  object PostResponse {
    case class HTTP200(value: io.apibuilder.api.v0.models.MembershipRequest, headers: Seq[org.http4s.Header] = Nil) extends PostResponse
    case class HTTP409(value: Seq[io.apibuilder.api.v0.models.Error], headers: Seq[org.http4s.Header] = Nil) extends PostResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends PostResponse
  }

  def post(
    _req: org.http4s.Request[F],
    orgGuid: _root_.java.util.UUID,
    userGuid: _root_.java.util.UUID,
    role: String
  ): F[PostResponse]

  sealed trait PostAcceptByGuidResponse

  object PostAcceptByGuidResponse {
    case class HTTP204(headers: Seq[org.http4s.Header] = Nil) extends PostAcceptByGuidResponse
    case class HTTP409(value: Seq[io.apibuilder.api.v0.models.Error], headers: Seq[org.http4s.Header] = Nil) extends PostAcceptByGuidResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends PostAcceptByGuidResponse
  }

  def postAcceptByGuid(
    _req: org.http4s.Request[F],
    guid: _root_.java.util.UUID
  ): F[PostAcceptByGuidResponse]

  sealed trait PostDeclineByGuidResponse

  object PostDeclineByGuidResponse {
    case class HTTP204(headers: Seq[org.http4s.Header] = Nil) extends PostDeclineByGuidResponse
    case class HTTP409(value: Seq[io.apibuilder.api.v0.models.Error], headers: Seq[org.http4s.Header] = Nil) extends PostDeclineByGuidResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends PostDeclineByGuidResponse
  }

  def postDeclineByGuid(
    _req: org.http4s.Request[F],
    guid: _root_.java.util.UUID
  ): F[PostDeclineByGuidResponse]

  def apiVersionMatch(req: org.http4s.Message[F]): Boolean = ApiVersion(req)

  def service()(implicit sync: Sync[F]) = org.http4s.HttpService[F] {
    case _req @ GET -> Root / "membership_requests" :? OrgGuidOptUUIDMatcher(orgGuid) +& OrgKeyOptStringMatcher(orgKey) +& UserGuidOptUUIDMatcher(userGuid) +& RoleOptStringMatcher(role) +& LimitLong1To100Def25Matcher(limit) +& OffsetLong0Def0Matcher(offset) if apiVersionMatch(_req) =>
      get(_req, orgGuid, orgKey, userGuid, role, limit, offset).flatMap {
        case GetResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case GetResponse.UndocumentedResponse(response) => response
      }
    case _req @ GET -> Root / "membership_requests" :? OrgGuidOptUUIDMatcher(orgGuid) +& OrgKeyOptStringMatcher(orgKey) +& UserGuidOptUUIDMatcher(userGuid) +& RoleOptStringMatcher(role) +& LimitLong1To100Def25Matcher(limit) +& OffsetLong0Def0Matcher(offset) if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ POST -> Root / "membership_requests" if apiVersionMatch(_req) =>
    if (_req.contentType.exists(_.mediaType == _root_.org.http4s.MediaType.`application/json`)) {
      _req.attemptAs[PostRequest].value.flatMap{
        case Right(req) =>
          post(_req, req.orgGuid, req.userGuid, req.role).flatMap {
            case PostResponse.HTTP200(value, headers) => Ok(value, headers: _*)
            case PostResponse.HTTP409(value, headers) => Conflict(value, headers: _*)
            case PostResponse.UndocumentedResponse(response) => response
          }
        case Left(_) => BadRequest()
      }
    } else {
        _req.decode[_root_.org.http4s.UrlForm] {
          req =>
            val responseOpt = for {
              orgGuid <- req.getFirst("org_guid").flatMap(f => _root_.io.circe.parser.decode[_root_.java.util.UUID](f).toOption)
              userGuid <- req.getFirst("user_guid").flatMap(f => _root_.io.circe.parser.decode[_root_.java.util.UUID](f).toOption)
              role <- req.getFirst("role")
            } yield {
                post(_req, orgGuid, userGuid, role).flatMap {
                  case PostResponse.HTTP200(value, headers) => Ok(value, headers: _*)
                  case PostResponse.HTTP409(value, headers) => Conflict(value, headers: _*)
                  case PostResponse.UndocumentedResponse(response) => response
                }
              }
            responseOpt.getOrElse(BadRequest())
      }
    }
    case _req @ POST -> Root / "membership_requests" if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ POST -> Root / "membership_requests" / UUIDVal(guid) / "accept" if apiVersionMatch(_req) =>
      postAcceptByGuid(_req, guid).flatMap {
        case PostAcceptByGuidResponse.HTTP204(headers) => NoContent(headers: _*)
        case PostAcceptByGuidResponse.HTTP409(value, headers) => Conflict(value, headers: _*)
        case PostAcceptByGuidResponse.UndocumentedResponse(response) => response
      }
    case _req @ POST -> Root / "membership_requests" / UUIDVal(guid) / "accept" if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ POST -> Root / "membership_requests" / UUIDVal(guid) / "decline" if apiVersionMatch(_req) =>
      postDeclineByGuid(_req, guid).flatMap {
        case PostDeclineByGuidResponse.HTTP204(headers) => NoContent(headers: _*)
        case PostDeclineByGuidResponse.HTTP409(value, headers) => Conflict(value, headers: _*)
        case PostDeclineByGuidResponse.UndocumentedResponse(response) => response
      }
    case _req @ POST -> Root / "membership_requests" / UUIDVal(guid) / "decline" if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")
  }
}

trait MembershipRoutes[F[_]] extends Matchers[F] {

  implicit def circeJsonDecoder[A](implicit decoder: _root_.io.circe.Decoder[A], sync: Sync[F]) = org.http4s.circe.jsonOf[F, A]
  implicit def circeJsonEncoder[A](implicit encoder: _root_.io.circe.Encoder[A], sync: Sync[F]) = org.http4s.circe.jsonEncoderOf[F, A]

  sealed trait GetResponse

  object GetResponse {
    case class HTTP200(value: Seq[io.apibuilder.api.v0.models.Membership], headers: Seq[org.http4s.Header] = Nil) extends GetResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends GetResponse
  }

  def get(
    _req: org.http4s.Request[F],
    orgGuid: _root_.scala.Option[_root_.java.util.UUID],
    orgKey: _root_.scala.Option[String],
    userGuid: _root_.scala.Option[_root_.java.util.UUID],
    role: _root_.scala.Option[String],
    limit: Long,
    offset: Long
  ): F[GetResponse]

  sealed trait GetByGuidResponse

  object GetByGuidResponse {
    case class HTTP200(value: io.apibuilder.api.v0.models.Membership, headers: Seq[org.http4s.Header] = Nil) extends GetByGuidResponse
    case class HTTP404(headers: Seq[org.http4s.Header] = Nil) extends GetByGuidResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends GetByGuidResponse
  }

  def getByGuid(
    _req: org.http4s.Request[F],
    guid: _root_.java.util.UUID
  ): F[GetByGuidResponse]

  sealed trait DeleteByGuidResponse

  object DeleteByGuidResponse {
    case class HTTP204(headers: Seq[org.http4s.Header] = Nil) extends DeleteByGuidResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends DeleteByGuidResponse
  }

  def deleteByGuid(
    _req: org.http4s.Request[F],
    guid: _root_.java.util.UUID
  ): F[DeleteByGuidResponse]

  def apiVersionMatch(req: org.http4s.Message[F]): Boolean = ApiVersion(req)

  def service()(implicit sync: Sync[F]) = org.http4s.HttpService[F] {
    case _req @ GET -> Root / "memberships" :? OrgGuidOptUUIDMatcher(orgGuid) +& OrgKeyOptStringMatcher(orgKey) +& UserGuidOptUUIDMatcher(userGuid) +& RoleOptStringMatcher(role) +& LimitLong1To100Def25Matcher(limit) +& OffsetLong0Def0Matcher(offset) if apiVersionMatch(_req) =>
      get(_req, orgGuid, orgKey, userGuid, role, limit, offset).flatMap {
        case GetResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case GetResponse.UndocumentedResponse(response) => response
      }
    case _req @ GET -> Root / "memberships" :? OrgGuidOptUUIDMatcher(orgGuid) +& OrgKeyOptStringMatcher(orgKey) +& UserGuidOptUUIDMatcher(userGuid) +& RoleOptStringMatcher(role) +& LimitLong1To100Def25Matcher(limit) +& OffsetLong0Def0Matcher(offset) if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ GET -> Root / "memberships" / UUIDVal(guid) if apiVersionMatch(_req) =>
      getByGuid(_req, guid).flatMap {
        case GetByGuidResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case GetByGuidResponse.HTTP404(headers) => NotFound(headers: _*)
        case GetByGuidResponse.UndocumentedResponse(response) => response
      }
    case _req @ GET -> Root / "memberships" / UUIDVal(guid) if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ DELETE -> Root / "memberships" / UUIDVal(guid) if apiVersionMatch(_req) =>
      deleteByGuid(_req, guid).flatMap {
        case DeleteByGuidResponse.HTTP204(headers) => NoContent(headers: _*)
        case DeleteByGuidResponse.UndocumentedResponse(response) => response
      }
    case _req @ DELETE -> Root / "memberships" / UUIDVal(guid) if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")
  }
}

trait OrganizationRoutes[F[_]] extends Matchers[F] {

  implicit def circeJsonDecoder[A](implicit decoder: _root_.io.circe.Decoder[A], sync: Sync[F]) = org.http4s.circe.jsonOf[F, A]
  implicit def circeJsonEncoder[A](implicit encoder: _root_.io.circe.Encoder[A], sync: Sync[F]) = org.http4s.circe.jsonEncoderOf[F, A]

  sealed trait GetResponse

  object GetResponse {
    case class HTTP200(value: Seq[io.apibuilder.api.v0.models.Organization], headers: Seq[org.http4s.Header] = Nil) extends GetResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends GetResponse
  }

  def get(
    _req: org.http4s.Request[F],
    guid: _root_.scala.Option[_root_.java.util.UUID],
    userGuid: _root_.scala.Option[_root_.java.util.UUID],
    key: _root_.scala.Option[String],
    name: _root_.scala.Option[String],
    namespace: _root_.scala.Option[String],
    limit: Long,
    offset: Long
  ): F[GetResponse]

  sealed trait GetByKeyResponse

  object GetByKeyResponse {
    case class HTTP200(value: io.apibuilder.api.v0.models.Organization, headers: Seq[org.http4s.Header] = Nil) extends GetByKeyResponse
    case class HTTP404(headers: Seq[org.http4s.Header] = Nil) extends GetByKeyResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends GetByKeyResponse
  }

  def getByKey(
    _req: org.http4s.Request[F],
    key: String
  ): F[GetByKeyResponse]

  sealed trait PostResponse

  object PostResponse {
    case class HTTP200(value: io.apibuilder.api.v0.models.Organization, headers: Seq[org.http4s.Header] = Nil) extends PostResponse
    case class HTTP409(value: Seq[io.apibuilder.api.v0.models.Error], headers: Seq[org.http4s.Header] = Nil) extends PostResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends PostResponse
  }

  def post(
    _req: org.http4s.Request[F],
    body: => org.http4s.DecodeResult[F, io.apibuilder.api.v0.models.OrganizationForm]
  ): F[PostResponse]

  sealed trait PutByKeyResponse

  object PutByKeyResponse {
    case class HTTP200(value: io.apibuilder.api.v0.models.Organization, headers: Seq[org.http4s.Header] = Nil) extends PutByKeyResponse
    case class HTTP409(value: Seq[io.apibuilder.api.v0.models.Error], headers: Seq[org.http4s.Header] = Nil) extends PutByKeyResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends PutByKeyResponse
  }

  def putByKey(
    _req: org.http4s.Request[F],
    key: String,
    body: => org.http4s.DecodeResult[F, io.apibuilder.api.v0.models.OrganizationForm]
  ): F[PutByKeyResponse]

  sealed trait DeleteByKeyResponse

  object DeleteByKeyResponse {
    case class HTTP204(headers: Seq[org.http4s.Header] = Nil) extends DeleteByKeyResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends DeleteByKeyResponse
  }

  def deleteByKey(
    _req: org.http4s.Request[F],
    key: String
  ): F[DeleteByKeyResponse]

  sealed trait GetAttributesByKeyResponse

  object GetAttributesByKeyResponse {
    case class HTTP200(value: Seq[io.apibuilder.api.v0.models.AttributeValue], headers: Seq[org.http4s.Header] = Nil) extends GetAttributesByKeyResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends GetAttributesByKeyResponse
  }

  def getAttributesByKey(
    _req: org.http4s.Request[F],
    key: String,
    name: _root_.scala.Option[String],
    limit: Long,
    offset: Long
  ): F[GetAttributesByKeyResponse]

  sealed trait GetAttributesByKeyAndNameResponse

  object GetAttributesByKeyAndNameResponse {
    case class HTTP200(value: io.apibuilder.api.v0.models.AttributeValue, headers: Seq[org.http4s.Header] = Nil) extends GetAttributesByKeyAndNameResponse
    case class HTTP404(headers: Seq[org.http4s.Header] = Nil) extends GetAttributesByKeyAndNameResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends GetAttributesByKeyAndNameResponse
  }

  def getAttributesByKeyAndName(
    _req: org.http4s.Request[F],
    key: String,
    name: String
  ): F[GetAttributesByKeyAndNameResponse]

  sealed trait PutAttributesByKeyAndNameResponse

  object PutAttributesByKeyAndNameResponse {
    case class HTTP200(value: io.apibuilder.api.v0.models.AttributeValue, headers: Seq[org.http4s.Header] = Nil) extends PutAttributesByKeyAndNameResponse
    case class HTTP201(value: io.apibuilder.api.v0.models.AttributeValue, headers: Seq[org.http4s.Header] = Nil) extends PutAttributesByKeyAndNameResponse
    case class HTTP404(headers: Seq[org.http4s.Header] = Nil) extends PutAttributesByKeyAndNameResponse
    case class HTTP409(value: Seq[io.apibuilder.api.v0.models.Error], headers: Seq[org.http4s.Header] = Nil) extends PutAttributesByKeyAndNameResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends PutAttributesByKeyAndNameResponse
  }

  def putAttributesByKeyAndName(
    _req: org.http4s.Request[F],
    key: String,
    name: String,
    body: => org.http4s.DecodeResult[F, io.apibuilder.api.v0.models.AttributeValueForm]
  ): F[PutAttributesByKeyAndNameResponse]

  sealed trait DeleteAttributesByKeyAndNameResponse

  object DeleteAttributesByKeyAndNameResponse {
    case class HTTP204(headers: Seq[org.http4s.Header] = Nil) extends DeleteAttributesByKeyAndNameResponse
    case class HTTP401(authenticate: org.http4s.headers.`WWW-Authenticate`, headers: Seq[org.http4s.Header] = Nil) extends DeleteAttributesByKeyAndNameResponse
    case class HTTP404(headers: Seq[org.http4s.Header] = Nil) extends DeleteAttributesByKeyAndNameResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends DeleteAttributesByKeyAndNameResponse
  }

  def deleteAttributesByKeyAndName(
    _req: org.http4s.Request[F],
    key: String,
    name: String
  ): F[DeleteAttributesByKeyAndNameResponse]

  def apiVersionMatch(req: org.http4s.Message[F]): Boolean = ApiVersion(req)

  def service()(implicit sync: Sync[F]) = org.http4s.HttpService[F] {
    case _req @ GET -> Root / "organizations" :? GuidOptUUIDMatcher(guid) +& UserGuidOptUUIDMatcher(userGuid) +& KeyOptStringMatcher(key) +& NameOptStringMatcher(name) +& NamespaceOptStringMatcher(namespace) +& LimitLong1To100Def25Matcher(limit) +& OffsetLong0Def0Matcher(offset) if apiVersionMatch(_req) =>
      get(_req, guid, userGuid, key, name, namespace, limit, offset).flatMap {
        case GetResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case GetResponse.UndocumentedResponse(response) => response
      }
    case _req @ GET -> Root / "organizations" :? GuidOptUUIDMatcher(guid) +& UserGuidOptUUIDMatcher(userGuid) +& KeyOptStringMatcher(key) +& NameOptStringMatcher(name) +& NamespaceOptStringMatcher(namespace) +& LimitLong1To100Def25Matcher(limit) +& OffsetLong0Def0Matcher(offset) if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ GET -> Root / "organizations" / key if apiVersionMatch(_req) =>
      getByKey(_req, key).flatMap {
        case GetByKeyResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case GetByKeyResponse.HTTP404(headers) => NotFound(headers: _*)
        case GetByKeyResponse.UndocumentedResponse(response) => response
      }
    case _req @ GET -> Root / "organizations" / key if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ POST -> Root / "organizations" if apiVersionMatch(_req) =>
      post(_req, _req.attemptAs[io.apibuilder.api.v0.models.OrganizationForm]).flatMap {
        case PostResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case PostResponse.HTTP409(value, headers) => Conflict(value, headers: _*)
        case PostResponse.UndocumentedResponse(response) => response
      }
    case _req @ POST -> Root / "organizations" if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ PUT -> Root / "organizations" / key if apiVersionMatch(_req) =>
      putByKey(_req, key, _req.attemptAs[io.apibuilder.api.v0.models.OrganizationForm]).flatMap {
        case PutByKeyResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case PutByKeyResponse.HTTP409(value, headers) => Conflict(value, headers: _*)
        case PutByKeyResponse.UndocumentedResponse(response) => response
      }
    case _req @ PUT -> Root / "organizations" / key if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ DELETE -> Root / "organizations" / key if apiVersionMatch(_req) =>
      deleteByKey(_req, key).flatMap {
        case DeleteByKeyResponse.HTTP204(headers) => NoContent(headers: _*)
        case DeleteByKeyResponse.UndocumentedResponse(response) => response
      }
    case _req @ DELETE -> Root / "organizations" / key if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ GET -> Root / "organizations" / key / "attributes" :? NameOptStringMatcher(name) +& LimitLong1To100Def25Matcher(limit) +& OffsetLong0Def0Matcher(offset) if apiVersionMatch(_req) =>
      getAttributesByKey(_req, key, name, limit, offset).flatMap {
        case GetAttributesByKeyResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case GetAttributesByKeyResponse.UndocumentedResponse(response) => response
      }
    case _req @ GET -> Root / "organizations" / key / "attributes" :? NameOptStringMatcher(name) +& LimitLong1To100Def25Matcher(limit) +& OffsetLong0Def0Matcher(offset) if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ GET -> Root / "organizations" / key / "attributes" / name if apiVersionMatch(_req) =>
      getAttributesByKeyAndName(_req, key, name).flatMap {
        case GetAttributesByKeyAndNameResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case GetAttributesByKeyAndNameResponse.HTTP404(headers) => NotFound(headers: _*)
        case GetAttributesByKeyAndNameResponse.UndocumentedResponse(response) => response
      }
    case _req @ GET -> Root / "organizations" / key / "attributes" / name if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ PUT -> Root / "organizations" / key / "attributes" / name if apiVersionMatch(_req) =>
      putAttributesByKeyAndName(_req, key, name, _req.attemptAs[io.apibuilder.api.v0.models.AttributeValueForm]).flatMap {
        case PutAttributesByKeyAndNameResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case PutAttributesByKeyAndNameResponse.HTTP201(value, headers) => Created(value, headers: _*)
        case PutAttributesByKeyAndNameResponse.HTTP404(headers) => NotFound(headers: _*)
        case PutAttributesByKeyAndNameResponse.HTTP409(value, headers) => Conflict(value, headers: _*)
        case PutAttributesByKeyAndNameResponse.UndocumentedResponse(response) => response
      }
    case _req @ PUT -> Root / "organizations" / key / "attributes" / name if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ DELETE -> Root / "organizations" / key / "attributes" / name if apiVersionMatch(_req) =>
      deleteAttributesByKeyAndName(_req, key, name).flatMap {
        case DeleteAttributesByKeyAndNameResponse.HTTP204(headers) => NoContent(headers: _*)
        case DeleteAttributesByKeyAndNameResponse.HTTP401(authenticate, headers) => Unauthorized(authenticate, headers: _*)
        case DeleteAttributesByKeyAndNameResponse.HTTP404(headers) => NotFound(headers: _*)
        case DeleteAttributesByKeyAndNameResponse.UndocumentedResponse(response) => response
      }
    case _req @ DELETE -> Root / "organizations" / key / "attributes" / name if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")
  }
}

trait PasswordResetRequestRoutes[F[_]] extends Matchers[F] {

  implicit def circeJsonDecoder[A](implicit decoder: _root_.io.circe.Decoder[A], sync: Sync[F]) = org.http4s.circe.jsonOf[F, A]
  implicit def circeJsonEncoder[A](implicit encoder: _root_.io.circe.Encoder[A], sync: Sync[F]) = org.http4s.circe.jsonEncoderOf[F, A]

  sealed trait PostResponse

  object PostResponse {
    case class HTTP204(headers: Seq[org.http4s.Header] = Nil) extends PostResponse
    case class HTTP409(value: Seq[io.apibuilder.api.v0.models.Error], headers: Seq[org.http4s.Header] = Nil) extends PostResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends PostResponse
  }

  def post(
    _req: org.http4s.Request[F],
    body: => org.http4s.DecodeResult[F, io.apibuilder.api.v0.models.PasswordResetRequest]
  ): F[PostResponse]

  def apiVersionMatch(req: org.http4s.Message[F]): Boolean = ApiVersion(req)

  def service()(implicit sync: Sync[F]) = org.http4s.HttpService[F] {
    case _req @ POST -> Root / "password_reset_requests" if apiVersionMatch(_req) =>
      post(_req, _req.attemptAs[io.apibuilder.api.v0.models.PasswordResetRequest]).flatMap {
        case PostResponse.HTTP204(headers) => NoContent(headers: _*)
        case PostResponse.HTTP409(value, headers) => Conflict(value, headers: _*)
        case PostResponse.UndocumentedResponse(response) => response
      }
    case _req @ POST -> Root / "password_reset_requests" if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")
  }
}

trait PasswordResetRoutes[F[_]] extends Matchers[F] {

  implicit def circeJsonDecoder[A](implicit decoder: _root_.io.circe.Decoder[A], sync: Sync[F]) = org.http4s.circe.jsonOf[F, A]
  implicit def circeJsonEncoder[A](implicit encoder: _root_.io.circe.Encoder[A], sync: Sync[F]) = org.http4s.circe.jsonEncoderOf[F, A]

  sealed trait PostResponse

  object PostResponse {
    case class HTTP200(value: io.apibuilder.api.v0.models.PasswordResetSuccess, headers: Seq[org.http4s.Header] = Nil) extends PostResponse
    case class HTTP409(value: Seq[io.apibuilder.api.v0.models.Error], headers: Seq[org.http4s.Header] = Nil) extends PostResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends PostResponse
  }

  def post(
    _req: org.http4s.Request[F],
    body: => org.http4s.DecodeResult[F, io.apibuilder.api.v0.models.PasswordReset]
  ): F[PostResponse]

  def apiVersionMatch(req: org.http4s.Message[F]): Boolean = ApiVersion(req)

  def service()(implicit sync: Sync[F]) = org.http4s.HttpService[F] {
    case _req @ POST -> Root / "password_resets" if apiVersionMatch(_req) =>
      post(_req, _req.attemptAs[io.apibuilder.api.v0.models.PasswordReset]).flatMap {
        case PostResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case PostResponse.HTTP409(value, headers) => Conflict(value, headers: _*)
        case PostResponse.UndocumentedResponse(response) => response
      }
    case _req @ POST -> Root / "password_resets" if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")
  }
}

trait SubscriptionRoutes[F[_]] extends Matchers[F] {

  implicit def circeJsonDecoder[A](implicit decoder: _root_.io.circe.Decoder[A], sync: Sync[F]) = org.http4s.circe.jsonOf[F, A]
  implicit def circeJsonEncoder[A](implicit encoder: _root_.io.circe.Encoder[A], sync: Sync[F]) = org.http4s.circe.jsonEncoderOf[F, A]

  sealed trait GetResponse

  object GetResponse {
    case class HTTP200(value: Seq[io.apibuilder.api.v0.models.Subscription], headers: Seq[org.http4s.Header] = Nil) extends GetResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends GetResponse
  }

  def get(
    _req: org.http4s.Request[F],
    guid: _root_.scala.Option[_root_.java.util.UUID],
    organizationKey: _root_.scala.Option[String],
    userGuid: _root_.scala.Option[_root_.java.util.UUID],
    publication: _root_.scala.Option[io.apibuilder.api.v0.models.Publication],
    limit: Long,
    offset: Long
  ): F[GetResponse]

  sealed trait GetByGuidResponse

  object GetByGuidResponse {
    case class HTTP200(value: io.apibuilder.api.v0.models.Subscription, headers: Seq[org.http4s.Header] = Nil) extends GetByGuidResponse
    case class HTTP404(headers: Seq[org.http4s.Header] = Nil) extends GetByGuidResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends GetByGuidResponse
  }

  def getByGuid(
    _req: org.http4s.Request[F],
    guid: _root_.java.util.UUID
  ): F[GetByGuidResponse]

  sealed trait PostResponse

  object PostResponse {
    case class HTTP201(value: io.apibuilder.api.v0.models.Subscription, headers: Seq[org.http4s.Header] = Nil) extends PostResponse
    case class HTTP409(value: Seq[io.apibuilder.api.v0.models.Error], headers: Seq[org.http4s.Header] = Nil) extends PostResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends PostResponse
  }

  def post(
    _req: org.http4s.Request[F],
    body: => org.http4s.DecodeResult[F, io.apibuilder.api.v0.models.SubscriptionForm]
  ): F[PostResponse]

  sealed trait DeleteByGuidResponse

  object DeleteByGuidResponse {
    case class HTTP204(headers: Seq[org.http4s.Header] = Nil) extends DeleteByGuidResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends DeleteByGuidResponse
  }

  def deleteByGuid(
    _req: org.http4s.Request[F],
    guid: _root_.java.util.UUID
  ): F[DeleteByGuidResponse]

  def apiVersionMatch(req: org.http4s.Message[F]): Boolean = ApiVersion(req)

  def service()(implicit sync: Sync[F]) = org.http4s.HttpService[F] {
    case _req @ GET -> Root / "subscriptions" :? GuidOptUUIDMatcher(guid) +& OrganizationKeyOptStringMatcher(organizationKey) +& UserGuidOptUUIDMatcher(userGuid) +& PublicationOptPublicationMatcher(publication) +& LimitLong1To100Def25Matcher(limit) +& OffsetLong0Def0Matcher(offset) if apiVersionMatch(_req) =>
      get(_req, guid, organizationKey, userGuid, publication, limit, offset).flatMap {
        case GetResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case GetResponse.UndocumentedResponse(response) => response
      }
    case _req @ GET -> Root / "subscriptions" :? GuidOptUUIDMatcher(guid) +& OrganizationKeyOptStringMatcher(organizationKey) +& UserGuidOptUUIDMatcher(userGuid) +& PublicationOptPublicationMatcher(publication) +& LimitLong1To100Def25Matcher(limit) +& OffsetLong0Def0Matcher(offset) if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ GET -> Root / "subscriptions" / UUIDVal(guid) if apiVersionMatch(_req) =>
      getByGuid(_req, guid).flatMap {
        case GetByGuidResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case GetByGuidResponse.HTTP404(headers) => NotFound(headers: _*)
        case GetByGuidResponse.UndocumentedResponse(response) => response
      }
    case _req @ GET -> Root / "subscriptions" / UUIDVal(guid) if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ POST -> Root / "subscriptions" if apiVersionMatch(_req) =>
      post(_req, _req.attemptAs[io.apibuilder.api.v0.models.SubscriptionForm]).flatMap {
        case PostResponse.HTTP201(value, headers) => Created(value, headers: _*)
        case PostResponse.HTTP409(value, headers) => Conflict(value, headers: _*)
        case PostResponse.UndocumentedResponse(response) => response
      }
    case _req @ POST -> Root / "subscriptions" if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ DELETE -> Root / "subscriptions" / UUIDVal(guid) if apiVersionMatch(_req) =>
      deleteByGuid(_req, guid).flatMap {
        case DeleteByGuidResponse.HTTP204(headers) => NoContent(headers: _*)
        case DeleteByGuidResponse.UndocumentedResponse(response) => response
      }
    case _req @ DELETE -> Root / "subscriptions" / UUIDVal(guid) if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")
  }
}

trait TokenRoutes[F[_]] extends Matchers[F] {

  implicit def circeJsonDecoder[A](implicit decoder: _root_.io.circe.Decoder[A], sync: Sync[F]) = org.http4s.circe.jsonOf[F, A]
  implicit def circeJsonEncoder[A](implicit encoder: _root_.io.circe.Encoder[A], sync: Sync[F]) = org.http4s.circe.jsonEncoderOf[F, A]

  sealed trait GetUsersByUserGuidResponse

  object GetUsersByUserGuidResponse {
    case class HTTP200(value: Seq[io.apibuilder.api.v0.models.Token], headers: Seq[org.http4s.Header] = Nil) extends GetUsersByUserGuidResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends GetUsersByUserGuidResponse
  }

  def getUsersByUserGuid(
    _req: org.http4s.Request[F],
    userGuid: _root_.java.util.UUID,
    guid: _root_.scala.Option[_root_.java.util.UUID],
    limit: Long,
    offset: Long
  ): F[GetUsersByUserGuidResponse]

  sealed trait GetCleartextByGuidResponse

  object GetCleartextByGuidResponse {
    case class HTTP200(value: io.apibuilder.api.v0.models.CleartextToken, headers: Seq[org.http4s.Header] = Nil) extends GetCleartextByGuidResponse
    case class HTTP404(headers: Seq[org.http4s.Header] = Nil) extends GetCleartextByGuidResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends GetCleartextByGuidResponse
  }

  def getCleartextByGuid(
    _req: org.http4s.Request[F],
    guid: _root_.java.util.UUID
  ): F[GetCleartextByGuidResponse]

  sealed trait PostResponse

  object PostResponse {
    case class HTTP201(value: io.apibuilder.api.v0.models.Token, headers: Seq[org.http4s.Header] = Nil) extends PostResponse
    case class HTTP409(value: Seq[io.apibuilder.api.v0.models.Error], headers: Seq[org.http4s.Header] = Nil) extends PostResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends PostResponse
  }

  def post(
    _req: org.http4s.Request[F],
    body: => org.http4s.DecodeResult[F, io.apibuilder.api.v0.models.TokenForm]
  ): F[PostResponse]

  sealed trait DeleteByGuidResponse

  object DeleteByGuidResponse {
    case class HTTP204(headers: Seq[org.http4s.Header] = Nil) extends DeleteByGuidResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends DeleteByGuidResponse
  }

  def deleteByGuid(
    _req: org.http4s.Request[F],
    guid: _root_.java.util.UUID
  ): F[DeleteByGuidResponse]

  def apiVersionMatch(req: org.http4s.Message[F]): Boolean = ApiVersion(req)

  def service()(implicit sync: Sync[F]) = org.http4s.HttpService[F] {
    case _req @ GET -> Root / "tokens" / "users" / UUIDVal(userGuid) :? GuidOptUUIDMatcher(guid) +& LimitLong1To100Def25Matcher(limit) +& OffsetLong0Def0Matcher(offset) if apiVersionMatch(_req) =>
      getUsersByUserGuid(_req, userGuid, guid, limit, offset).flatMap {
        case GetUsersByUserGuidResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case GetUsersByUserGuidResponse.UndocumentedResponse(response) => response
      }
    case _req @ GET -> Root / "tokens" / "users" / UUIDVal(userGuid) :? GuidOptUUIDMatcher(guid) +& LimitLong1To100Def25Matcher(limit) +& OffsetLong0Def0Matcher(offset) if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ GET -> Root / "tokens" / UUIDVal(guid) / "cleartext" if apiVersionMatch(_req) =>
      getCleartextByGuid(_req, guid).flatMap {
        case GetCleartextByGuidResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case GetCleartextByGuidResponse.HTTP404(headers) => NotFound(headers: _*)
        case GetCleartextByGuidResponse.UndocumentedResponse(response) => response
      }
    case _req @ GET -> Root / "tokens" / UUIDVal(guid) / "cleartext" if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ POST -> Root / "tokens" if apiVersionMatch(_req) =>
      post(_req, _req.attemptAs[io.apibuilder.api.v0.models.TokenForm]).flatMap {
        case PostResponse.HTTP201(value, headers) => Created(value, headers: _*)
        case PostResponse.HTTP409(value, headers) => Conflict(value, headers: _*)
        case PostResponse.UndocumentedResponse(response) => response
      }
    case _req @ POST -> Root / "tokens" if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ DELETE -> Root / "tokens" / UUIDVal(guid) if apiVersionMatch(_req) =>
      deleteByGuid(_req, guid).flatMap {
        case DeleteByGuidResponse.HTTP204(headers) => NoContent(headers: _*)
        case DeleteByGuidResponse.UndocumentedResponse(response) => response
      }
    case _req @ DELETE -> Root / "tokens" / UUIDVal(guid) if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")
  }
}

trait UserRoutes[F[_]] extends Matchers[F] {

  implicit def circeJsonDecoder[A](implicit decoder: _root_.io.circe.Decoder[A], sync: Sync[F]) = org.http4s.circe.jsonOf[F, A]
  implicit def circeJsonEncoder[A](implicit encoder: _root_.io.circe.Encoder[A], sync: Sync[F]) = org.http4s.circe.jsonEncoderOf[F, A]

  sealed trait GetResponse

  object GetResponse {
    case class HTTP200(value: Seq[io.apibuilder.api.v0.models.User], headers: Seq[org.http4s.Header] = Nil) extends GetResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends GetResponse
  }

  def get(
    _req: org.http4s.Request[F],
    guid: _root_.scala.Option[_root_.java.util.UUID],
    email: _root_.scala.Option[String],
    token: _root_.scala.Option[String]
  ): F[GetResponse]

  sealed trait GetByGuidResponse

  object GetByGuidResponse {
    case class HTTP200(value: io.apibuilder.api.v0.models.User, headers: Seq[org.http4s.Header] = Nil) extends GetByGuidResponse
    case class HTTP404(headers: Seq[org.http4s.Header] = Nil) extends GetByGuidResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends GetByGuidResponse
  }

  def getByGuid(
    _req: org.http4s.Request[F],
    guid: _root_.java.util.UUID
  ): F[GetByGuidResponse]

  case class PostAuthenticateRequest(email: String, password: String)

  implicit val PostAuthenticateRequestDecoder: _root_.io.circe.Decoder[PostAuthenticateRequest] = _root_.io.circe.Decoder.instance { a =>
    for {
      email <- a.downField("email").as[String]
      password <- a.downField("password").as[String]
    } yield {
      PostAuthenticateRequest(
        email = email,
        password = password
      )
    }
  }

  sealed trait PostAuthenticateResponse

  object PostAuthenticateResponse {
    case class HTTP200(value: io.apibuilder.api.v0.models.User, headers: Seq[org.http4s.Header] = Nil) extends PostAuthenticateResponse
    case class HTTP409(value: Seq[io.apibuilder.api.v0.models.Error], headers: Seq[org.http4s.Header] = Nil) extends PostAuthenticateResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends PostAuthenticateResponse
  }

  def postAuthenticate(
    _req: org.http4s.Request[F],
    email: String,
    password: String
  ): F[PostAuthenticateResponse]

  sealed trait PostResponse

  object PostResponse {
    case class HTTP200(value: io.apibuilder.api.v0.models.User, headers: Seq[org.http4s.Header] = Nil) extends PostResponse
    case class HTTP409(value: Seq[io.apibuilder.api.v0.models.Error], headers: Seq[org.http4s.Header] = Nil) extends PostResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends PostResponse
  }

  def post(
    _req: org.http4s.Request[F],
    body: => org.http4s.DecodeResult[F, io.apibuilder.api.v0.models.UserForm]
  ): F[PostResponse]

  sealed trait PutByGuidResponse

  object PutByGuidResponse {
    case class HTTP200(value: io.apibuilder.api.v0.models.User, headers: Seq[org.http4s.Header] = Nil) extends PutByGuidResponse
    case class HTTP409(value: Seq[io.apibuilder.api.v0.models.Error], headers: Seq[org.http4s.Header] = Nil) extends PutByGuidResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends PutByGuidResponse
  }

  def putByGuid(
    _req: org.http4s.Request[F],
    guid: _root_.java.util.UUID,
    body: => org.http4s.DecodeResult[F, io.apibuilder.api.v0.models.UserUpdateForm]
  ): F[PutByGuidResponse]

  def apiVersionMatch(req: org.http4s.Message[F]): Boolean = ApiVersion(req)

  def service()(implicit sync: Sync[F]) = org.http4s.HttpService[F] {
    case _req @ GET -> Root / "users" :? GuidOptUUIDMatcher(guid) +& EmailOptStringMatcher(email) +& TokenOptStringMatcher(token) if apiVersionMatch(_req) =>
      get(_req, guid, email, token).flatMap {
        case GetResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case GetResponse.UndocumentedResponse(response) => response
      }
    case _req @ GET -> Root / "users" :? GuidOptUUIDMatcher(guid) +& EmailOptStringMatcher(email) +& TokenOptStringMatcher(token) if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ GET -> Root / "users" / UUIDVal(guid) if apiVersionMatch(_req) =>
      getByGuid(_req, guid).flatMap {
        case GetByGuidResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case GetByGuidResponse.HTTP404(headers) => NotFound(headers: _*)
        case GetByGuidResponse.UndocumentedResponse(response) => response
      }
    case _req @ GET -> Root / "users" / UUIDVal(guid) if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ POST -> Root / "users" / "authenticate" if apiVersionMatch(_req) =>
    if (_req.contentType.exists(_.mediaType == _root_.org.http4s.MediaType.`application/json`)) {
      _req.attemptAs[PostAuthenticateRequest].value.flatMap{
        case Right(req) =>
          postAuthenticate(_req, req.email, req.password).flatMap {
            case PostAuthenticateResponse.HTTP200(value, headers) => Ok(value, headers: _*)
            case PostAuthenticateResponse.HTTP409(value, headers) => Conflict(value, headers: _*)
            case PostAuthenticateResponse.UndocumentedResponse(response) => response
          }
        case Left(_) => BadRequest()
      }
    } else {
        _req.decode[_root_.org.http4s.UrlForm] {
          req =>
            val responseOpt = for {
              email <- req.getFirst("email")
              password <- req.getFirst("password")
            } yield {
                postAuthenticate(_req, email, password).flatMap {
                  case PostAuthenticateResponse.HTTP200(value, headers) => Ok(value, headers: _*)
                  case PostAuthenticateResponse.HTTP409(value, headers) => Conflict(value, headers: _*)
                  case PostAuthenticateResponse.UndocumentedResponse(response) => response
                }
              }
            responseOpt.getOrElse(BadRequest())
      }
    }
    case _req @ POST -> Root / "users" / "authenticate" if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ POST -> Root / "users" if apiVersionMatch(_req) =>
      post(_req, _req.attemptAs[io.apibuilder.api.v0.models.UserForm]).flatMap {
        case PostResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case PostResponse.HTTP409(value, headers) => Conflict(value, headers: _*)
        case PostResponse.UndocumentedResponse(response) => response
      }
    case _req @ POST -> Root / "users" if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ PUT -> Root / "users" / UUIDVal(guid) if apiVersionMatch(_req) =>
      putByGuid(_req, guid, _req.attemptAs[io.apibuilder.api.v0.models.UserUpdateForm]).flatMap {
        case PutByGuidResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case PutByGuidResponse.HTTP409(value, headers) => Conflict(value, headers: _*)
        case PutByGuidResponse.UndocumentedResponse(response) => response
      }
    case _req @ PUT -> Root / "users" / UUIDVal(guid) if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")
  }
}

trait ValidationRoutes[F[_]] extends Matchers[F] {

  implicit def circeJsonDecoder[A](implicit decoder: _root_.io.circe.Decoder[A], sync: Sync[F]) = org.http4s.circe.jsonOf[F, A]
  implicit def circeJsonEncoder[A](implicit encoder: _root_.io.circe.Encoder[A], sync: Sync[F]) = org.http4s.circe.jsonEncoderOf[F, A]

  sealed trait PostResponse

  object PostResponse {
    case class HTTP200(value: io.apibuilder.api.v0.models.Validation, headers: Seq[org.http4s.Header] = Nil) extends PostResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends PostResponse
  }

  def post(
    _req: org.http4s.Request[F],
    body: => org.http4s.DecodeResult[F, String]
  ): F[PostResponse]

  def apiVersionMatch(req: org.http4s.Message[F]): Boolean = ApiVersion(req)

  def service()(implicit sync: Sync[F]) = org.http4s.HttpService[F] {
    case _req @ POST -> Root / "validations" if apiVersionMatch(_req) =>
      post(_req, _req.attemptAs[String]).flatMap {
        case PostResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case PostResponse.UndocumentedResponse(response) => response
      }
    case _req @ POST -> Root / "validations" if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")
  }
}

trait VersionRoutes[F[_]] extends Matchers[F] {

  implicit def circeJsonDecoder[A](implicit decoder: _root_.io.circe.Decoder[A], sync: Sync[F]) = org.http4s.circe.jsonOf[F, A]
  implicit def circeJsonEncoder[A](implicit encoder: _root_.io.circe.Encoder[A], sync: Sync[F]) = org.http4s.circe.jsonEncoderOf[F, A]

  sealed trait GetByApplicationKeyResponse

  object GetByApplicationKeyResponse {
    case class HTTP200(value: Seq[io.apibuilder.api.v0.models.Version], headers: Seq[org.http4s.Header] = Nil) extends GetByApplicationKeyResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends GetByApplicationKeyResponse
  }

  def getByApplicationKey(
    _req: org.http4s.Request[F],
    orgKey: String,
    applicationKey: String,
    limit: Long,
    offset: Long
  ): F[GetByApplicationKeyResponse]

  sealed trait GetByApplicationKeyAndVersionResponse

  object GetByApplicationKeyAndVersionResponse {
    case class HTTP200(value: io.apibuilder.api.v0.models.Version, headers: Seq[org.http4s.Header] = Nil) extends GetByApplicationKeyAndVersionResponse
    case class HTTP404(headers: Seq[org.http4s.Header] = Nil) extends GetByApplicationKeyAndVersionResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends GetByApplicationKeyAndVersionResponse
  }

  def getByApplicationKeyAndVersion(
    _req: org.http4s.Request[F],
    orgKey: String,
    applicationKey: String,
    version: String
  ): F[GetByApplicationKeyAndVersionResponse]

  sealed trait PostByVersionResponse

  object PostByVersionResponse {
    case class HTTP200(value: io.apibuilder.api.v0.models.Version, headers: Seq[org.http4s.Header] = Nil) extends PostByVersionResponse
    case class HTTP409(value: Seq[io.apibuilder.api.v0.models.Error], headers: Seq[org.http4s.Header] = Nil) extends PostByVersionResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends PostByVersionResponse
  }

  def postByVersion(
    _req: org.http4s.Request[F],
    orgKey: String,
    version: String,
    body: => org.http4s.DecodeResult[F, io.apibuilder.api.v0.models.VersionForm]
  ): F[PostByVersionResponse]

  sealed trait PutByApplicationKeyAndVersionResponse

  object PutByApplicationKeyAndVersionResponse {
    case class HTTP200(value: io.apibuilder.api.v0.models.Version, headers: Seq[org.http4s.Header] = Nil) extends PutByApplicationKeyAndVersionResponse
    case class HTTP409(value: Seq[io.apibuilder.api.v0.models.Error], headers: Seq[org.http4s.Header] = Nil) extends PutByApplicationKeyAndVersionResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends PutByApplicationKeyAndVersionResponse
  }

  def putByApplicationKeyAndVersion(
    _req: org.http4s.Request[F],
    orgKey: String,
    applicationKey: String,
    version: String,
    body: => org.http4s.DecodeResult[F, io.apibuilder.api.v0.models.VersionForm]
  ): F[PutByApplicationKeyAndVersionResponse]

  sealed trait DeleteByApplicationKeyAndVersionResponse

  object DeleteByApplicationKeyAndVersionResponse {
    case class HTTP204(headers: Seq[org.http4s.Header] = Nil) extends DeleteByApplicationKeyAndVersionResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends DeleteByApplicationKeyAndVersionResponse
  }

  def deleteByApplicationKeyAndVersion(
    _req: org.http4s.Request[F],
    orgKey: String,
    applicationKey: String,
    version: String
  ): F[DeleteByApplicationKeyAndVersionResponse]

  def apiVersionMatch(req: org.http4s.Message[F]): Boolean = ApiVersion(req)

  def service()(implicit sync: Sync[F]) = org.http4s.HttpService[F] {
    case _req @ GET -> Root / orgKey / applicationKey :? LimitLongTo100Def25Matcher(limit) +& OffsetLong0Def0Matcher(offset) if apiVersionMatch(_req) =>
      getByApplicationKey(_req, orgKey, applicationKey, limit, offset).flatMap {
        case GetByApplicationKeyResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case GetByApplicationKeyResponse.UndocumentedResponse(response) => response
      }
    case _req @ GET -> Root / orgKey / applicationKey :? LimitLongTo100Def25Matcher(limit) +& OffsetLong0Def0Matcher(offset) if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ GET -> Root / orgKey / applicationKey / version if apiVersionMatch(_req) =>
      getByApplicationKeyAndVersion(_req, orgKey, applicationKey, version).flatMap {
        case GetByApplicationKeyAndVersionResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case GetByApplicationKeyAndVersionResponse.HTTP404(headers) => NotFound(headers: _*)
        case GetByApplicationKeyAndVersionResponse.UndocumentedResponse(response) => response
      }
    case _req @ GET -> Root / orgKey / applicationKey / version if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ POST -> Root / orgKey / version if apiVersionMatch(_req) =>
      postByVersion(_req, orgKey, version, _req.attemptAs[io.apibuilder.api.v0.models.VersionForm]).flatMap {
        case PostByVersionResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case PostByVersionResponse.HTTP409(value, headers) => Conflict(value, headers: _*)
        case PostByVersionResponse.UndocumentedResponse(response) => response
      }
    case _req @ POST -> Root / orgKey / version if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ PUT -> Root / orgKey / applicationKey / version if apiVersionMatch(_req) =>
      putByApplicationKeyAndVersion(_req, orgKey, applicationKey, version, _req.attemptAs[io.apibuilder.api.v0.models.VersionForm]).flatMap {
        case PutByApplicationKeyAndVersionResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case PutByApplicationKeyAndVersionResponse.HTTP409(value, headers) => Conflict(value, headers: _*)
        case PutByApplicationKeyAndVersionResponse.UndocumentedResponse(response) => response
      }
    case _req @ PUT -> Root / orgKey / applicationKey / version if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ DELETE -> Root / orgKey / applicationKey / version if apiVersionMatch(_req) =>
      deleteByApplicationKeyAndVersion(_req, orgKey, applicationKey, version).flatMap {
        case DeleteByApplicationKeyAndVersionResponse.HTTP204(headers) => NoContent(headers: _*)
        case DeleteByApplicationKeyAndVersionResponse.UndocumentedResponse(response) => response
      }
    case _req @ DELETE -> Root / orgKey / applicationKey / version if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")
  }
}

trait WatchRoutes[F[_]] extends Matchers[F] {

  implicit def circeJsonDecoder[A](implicit decoder: _root_.io.circe.Decoder[A], sync: Sync[F]) = org.http4s.circe.jsonOf[F, A]
  implicit def circeJsonEncoder[A](implicit encoder: _root_.io.circe.Encoder[A], sync: Sync[F]) = org.http4s.circe.jsonEncoderOf[F, A]

  sealed trait GetResponse

  object GetResponse {
    case class HTTP200(value: Seq[io.apibuilder.api.v0.models.Watch], headers: Seq[org.http4s.Header] = Nil) extends GetResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends GetResponse
  }

  def get(
    _req: org.http4s.Request[F],
    guid: _root_.scala.Option[_root_.java.util.UUID],
    userGuid: _root_.scala.Option[_root_.java.util.UUID],
    organizationKey: _root_.scala.Option[String],
    applicationKey: _root_.scala.Option[String],
    limit: Long,
    offset: Long
  ): F[GetResponse]

  sealed trait GetByGuidResponse

  object GetByGuidResponse {
    case class HTTP200(value: io.apibuilder.api.v0.models.Watch, headers: Seq[org.http4s.Header] = Nil) extends GetByGuidResponse
    case class HTTP404(headers: Seq[org.http4s.Header] = Nil) extends GetByGuidResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends GetByGuidResponse
  }

  def getByGuid(
    _req: org.http4s.Request[F],
    guid: _root_.java.util.UUID
  ): F[GetByGuidResponse]

  sealed trait GetCheckResponse

  object GetCheckResponse {
    case class HTTP200(value: Boolean, headers: Seq[org.http4s.Header] = Nil) extends GetCheckResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends GetCheckResponse
  }

  def getCheck(
    _req: org.http4s.Request[F],
    userGuid: _root_.scala.Option[_root_.java.util.UUID],
    organizationKey: String,
    applicationKey: String
  ): F[GetCheckResponse]

  sealed trait PostResponse

  object PostResponse {
    case class HTTP201(value: io.apibuilder.api.v0.models.Watch, headers: Seq[org.http4s.Header] = Nil) extends PostResponse
    case class HTTP409(value: Seq[io.apibuilder.api.v0.models.Error], headers: Seq[org.http4s.Header] = Nil) extends PostResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends PostResponse
  }

  def post(
    _req: org.http4s.Request[F],
    body: => org.http4s.DecodeResult[F, io.apibuilder.api.v0.models.WatchForm]
  ): F[PostResponse]

  sealed trait DeleteByGuidResponse

  object DeleteByGuidResponse {
    case class HTTP204(headers: Seq[org.http4s.Header] = Nil) extends DeleteByGuidResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends DeleteByGuidResponse
  }

  def deleteByGuid(
    _req: org.http4s.Request[F],
    guid: _root_.java.util.UUID
  ): F[DeleteByGuidResponse]

  def apiVersionMatch(req: org.http4s.Message[F]): Boolean = ApiVersion(req)

  def service()(implicit sync: Sync[F]) = org.http4s.HttpService[F] {
    case _req @ GET -> Root / "watches" :? GuidOptUUIDMatcher(guid) +& UserGuidOptUUIDMatcher(userGuid) +& OrganizationKeyOptStringMatcher(organizationKey) +& ApplicationKeyOptStringMatcher(applicationKey) +& LimitLong1To100Def25Matcher(limit) +& OffsetLong0Def0Matcher(offset) if apiVersionMatch(_req) =>
      get(_req, guid, userGuid, organizationKey, applicationKey, limit, offset).flatMap {
        case GetResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case GetResponse.UndocumentedResponse(response) => response
      }
    case _req @ GET -> Root / "watches" :? GuidOptUUIDMatcher(guid) +& UserGuidOptUUIDMatcher(userGuid) +& OrganizationKeyOptStringMatcher(organizationKey) +& ApplicationKeyOptStringMatcher(applicationKey) +& LimitLong1To100Def25Matcher(limit) +& OffsetLong0Def0Matcher(offset) if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ GET -> Root / "watches" / UUIDVal(guid) if apiVersionMatch(_req) =>
      getByGuid(_req, guid).flatMap {
        case GetByGuidResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case GetByGuidResponse.HTTP404(headers) => NotFound(headers: _*)
        case GetByGuidResponse.UndocumentedResponse(response) => response
      }
    case _req @ GET -> Root / "watches" / UUIDVal(guid) if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ GET -> Root / "watches" / "check" :? UserGuidOptUUIDMatcher(userGuid) +& OrganizationKeyStringMatcher(organizationKey) +& ApplicationKeyStringMatcher(applicationKey) if apiVersionMatch(_req) =>
      getCheck(_req, userGuid, organizationKey, applicationKey).flatMap {
        case GetCheckResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case GetCheckResponse.UndocumentedResponse(response) => response
      }
    case _req @ GET -> Root / "watches" / "check" :? UserGuidOptUUIDMatcher(userGuid) +& OrganizationKeyStringMatcher(organizationKey) +& ApplicationKeyStringMatcher(applicationKey) if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ POST -> Root / "watches" if apiVersionMatch(_req) =>
      post(_req, _req.attemptAs[io.apibuilder.api.v0.models.WatchForm]).flatMap {
        case PostResponse.HTTP201(value, headers) => Created(value, headers: _*)
        case PostResponse.HTTP409(value, headers) => Conflict(value, headers: _*)
        case PostResponse.UndocumentedResponse(response) => response
      }
    case _req @ POST -> Root / "watches" if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")

    case _req @ DELETE -> Root / "watches" / UUIDVal(guid) if apiVersionMatch(_req) =>
      deleteByGuid(_req, guid).flatMap {
        case DeleteByGuidResponse.HTTP204(headers) => NoContent(headers: _*)
        case DeleteByGuidResponse.UndocumentedResponse(response) => response
      }
    case _req @ DELETE -> Root / "watches" / UUIDVal(guid) if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")
  }
}