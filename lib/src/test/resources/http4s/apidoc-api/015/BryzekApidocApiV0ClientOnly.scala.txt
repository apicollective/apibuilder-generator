/**
 * Generated by API Builder - https://www.apibuilder.io
 * Service version: 0.11.17
 */
package io.apibuilder.api.v0 {
import org.http4s.client.blaze._
import io.circe.syntax._

  object Constants {

    val BaseUrl = "http://api.apidoc.me"
    val Namespace = "io.apibuilder.api.v0"
    val UserAgent = "apibuilder-play_2x_client-unknown"
    val Version = "0.11.17"
    val VersionMajor = 0

  }

  class Client(
    val baseUrl: org.http4s.Uri = org.http4s.Uri.unsafeFromString("http://api.apidoc.me"),
    auth: scala.Option[io.apibuilder.api.v0.Authorization] = None,
    defaultHeaders: Seq[(String, String)] = Nil,
    asyncHttpClient: org.http4s.client.Client = Client.defaultAsyncHttpClient
  ) extends interfaces.Client {
    import org.http4s.Response
    import io.apibuilder.api.v0.models.json._
    import io.apibuilder.common.v0.models.json._
    import io.apibuilder.generator.v0.models.json._
    import io.apibuilder.spec.v0.models.json._

def closeAsyncHttpClient(): Unit = {
  asyncHttpClient.shutdownNow()
}

    def applications: Applications = Applications

    def attributes: Attributes = Attributes

    def changes: Changes = Changes

    def code: Code = Code

    def domains: Domains = Domains

    def emailVerificationConfirmationForms: EmailVerificationConfirmationForms = EmailVerificationConfirmationForms

    def generatorServices: GeneratorServices = GeneratorServices

    def generatorWithServices: GeneratorWithServices = GeneratorWithServices

    def healthchecks: Healthchecks = Healthchecks

    def items: Items = Items

    def membershipRequests: MembershipRequests = MembershipRequests

    def memberships: Memberships = Memberships

    def organizations: Organizations = Organizations

    def passwordResetRequests: PasswordResetRequests = PasswordResetRequests

    def passwordResets: PasswordResets = PasswordResets

    def subscriptions: Subscriptions = Subscriptions

    def tokens: Tokens = Tokens

    def users: Users = Users

    def validations: Validations = Validations

    def versions: Versions = Versions

    def watches: Watches = Watches

    object Applications extends Applications {
      override def get(
        orgKey: String,
        name: _root_.scala.Option[String] = None,
        guid: _root_.scala.Option[_root_.java.util.UUID] = None,
        key: _root_.scala.Option[String] = None,
        hasVersion: _root_.scala.Option[Boolean] = None,
        limit: Long = 25L,
        offset: Long = 0L,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[Seq[io.apibuilder.api.v0.models.Application]] = {
        val urlPath = Seq(orgKey)

        val queryParameters = Seq(
          name.map("name" -> _),
          guid.map("guid" -> _.toString),
          key.map("key" -> _),
          hasVersion.map("has_version" -> _.toString),
          Some("limit" -> limit.toString),
          Some("offset" -> offset.toString)
        ).flatten

        _executeRequest[Unit, Seq[io.apibuilder.api.v0.models.Application]]("GET", path = urlPath, queryParameters = queryParameters, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[Seq[io.apibuilder.api.v0.models.Application]]("Seq[io.apibuilder.api.v0.models.Application]", r)
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200"))
        }
      }

      override def post(
        orgKey: String,
        applicationForm: io.apibuilder.api.v0.models.ApplicationForm,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Application] = {
        val urlPath = Seq(orgKey)

        val (payload, formPayload) = (Some(applicationForm), None)

        _executeRequest[io.apibuilder.api.v0.models.ApplicationForm, io.apibuilder.api.v0.models.Application]("POST", path = urlPath, body = payload, formBody = formPayload, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.Application]("io.apibuilder.api.v0.models.Application", r)
          case r if r.status.code == 409 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.ErrorsResponse(r))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 409"))
        }
      }

      override def putByApplicationKey(
        orgKey: String,
        applicationKey: String,
        applicationForm: io.apibuilder.api.v0.models.ApplicationForm,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Application] = {
        val urlPath = Seq(orgKey, applicationKey)

        val (payload, formPayload) = (Some(applicationForm), None)

        _executeRequest[io.apibuilder.api.v0.models.ApplicationForm, io.apibuilder.api.v0.models.Application]("PUT", path = urlPath, body = payload, formBody = formPayload, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.Application]("io.apibuilder.api.v0.models.Application", r)
          case r if r.status.code == 409 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.ErrorsResponse(r))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 409"))
        }
      }

      override def deleteByApplicationKey(
        orgKey: String,
        applicationKey: String,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[Unit] = {
        val urlPath = Seq(orgKey, applicationKey)

        _executeRequest[Unit, Unit]("DELETE", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 204 => scalaz.concurrent.Task.now(())
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 204"))
        }
      }

      override def postMoveByApplicationKey(
        orgKey: String,
        applicationKey: String,
        moveForm: io.apibuilder.api.v0.models.MoveForm,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Application] = {
        val urlPath = Seq(orgKey, applicationKey, "move")

        val (payload, formPayload) = (Some(moveForm), None)

        _executeRequest[io.apibuilder.api.v0.models.MoveForm, io.apibuilder.api.v0.models.Application]("POST", path = urlPath, body = payload, formBody = formPayload, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.Application]("io.apibuilder.api.v0.models.Application", r)
          case r if r.status.code == 409 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.ErrorsResponse(r))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 409"))
        }
      }
    }

    object Attributes extends Attributes {
      override def get(
        guid: _root_.scala.Option[_root_.java.util.UUID] = None,
        name: _root_.scala.Option[String] = None,
        limit: Long = 25L,
        offset: Long = 0L,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[Seq[io.apibuilder.api.v0.models.Attribute]] = {
        val urlPath = Seq("attributes")

        val queryParameters = Seq(
          guid.map("guid" -> _.toString),
          name.map("name" -> _),
          Some("limit" -> limit.toString),
          Some("offset" -> offset.toString)
        ).flatten

        _executeRequest[Unit, Seq[io.apibuilder.api.v0.models.Attribute]]("GET", path = urlPath, queryParameters = queryParameters, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[Seq[io.apibuilder.api.v0.models.Attribute]]("Seq[io.apibuilder.api.v0.models.Attribute]", r)
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200"))
        }
      }

      override def getByName(
        name: String,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Attribute] = {
        val urlPath = Seq("attributes", name)

        _executeRequest[Unit, io.apibuilder.api.v0.models.Attribute]("GET", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.Attribute]("io.apibuilder.api.v0.models.Attribute", r)
          case r if r.status.code == 404 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.UnitResponse(r.status.code))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 404"))
        }
      }

      override def post(
        attributeForm: io.apibuilder.api.v0.models.AttributeForm,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Attribute] = {
        val urlPath = Seq("attributes")

        val (payload, formPayload) = (Some(attributeForm), None)

        _executeRequest[io.apibuilder.api.v0.models.AttributeForm, io.apibuilder.api.v0.models.Attribute]("POST", path = urlPath, body = payload, formBody = formPayload, requestHeaders = requestHeaders) {
          case r if r.status.code == 201 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.Attribute]("io.apibuilder.api.v0.models.Attribute", r)
          case r if r.status.code == 401 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.UnitResponse(r.status.code))
          case r if r.status.code == 409 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.ErrorsResponse(r))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 201, 401, 409"))
        }
      }

      override def deleteByName(
        name: String,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[Unit] = {
        val urlPath = Seq("attributes", name)

        _executeRequest[Unit, Unit]("DELETE", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 204 => scalaz.concurrent.Task.now(())
          case r if r.status.code == 401 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.UnitResponse(r.status.code))
          case r if r.status.code == 404 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.UnitResponse(r.status.code))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 204, 401, 404"))
        }
      }
    }

    object Changes extends Changes {
      override def get(
        orgKey: _root_.scala.Option[String] = None,
        applicationKey: _root_.scala.Option[String] = None,
        limit: Long = 25L,
        offset: Long = 0L,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[Seq[io.apibuilder.api.v0.models.Change]] = {
        val urlPath = Seq("changes")

        val queryParameters = Seq(
          orgKey.map("org_key" -> _),
          applicationKey.map("application_key" -> _),
          Some("limit" -> limit.toString),
          Some("offset" -> offset.toString)
        ).flatten

        _executeRequest[Unit, Seq[io.apibuilder.api.v0.models.Change]]("GET", path = urlPath, queryParameters = queryParameters, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[Seq[io.apibuilder.api.v0.models.Change]]("Seq[io.apibuilder.api.v0.models.Change]", r)
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200"))
        }
      }
    }

    object Code extends Code {
      override def get(
        orgKey: String,
        applicationKey: String,
        version: String,
        generatorKey: String,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Code] = {
        val urlPath = Seq(orgKey, applicationKey, version, generatorKey)

        _executeRequest[Unit, io.apibuilder.api.v0.models.Code]("GET", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.Code]("io.apibuilder.api.v0.models.Code", r)
          case r if r.status.code == 404 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.UnitResponse(r.status.code))
          case r if r.status.code == 409 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.ErrorsResponse(r))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 404, 409"))
        }
      }
    }

    object Domains extends Domains {
      override def post(
        orgKey: String,
        domain: io.apibuilder.api.v0.models.Domain,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Domain] = {
        val urlPath = Seq("domains", orgKey)

        val (payload, formPayload) = (Some(domain), None)

        _executeRequest[io.apibuilder.api.v0.models.Domain, io.apibuilder.api.v0.models.Domain]("POST", path = urlPath, body = payload, formBody = formPayload, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.Domain]("io.apibuilder.api.v0.models.Domain", r)
          case r if r.status.code == 409 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.ErrorsResponse(r))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 409"))
        }
      }

      override def deleteByName(
        orgKey: String,
        name: String,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[Unit] = {
        val urlPath = Seq("domains", orgKey, name)

        _executeRequest[Unit, Unit]("DELETE", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 204 => scalaz.concurrent.Task.now(())
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 204"))
        }
      }
    }

    object EmailVerificationConfirmationForms extends EmailVerificationConfirmationForms {
      override def post(
        emailVerificationConfirmationForm: io.apibuilder.api.v0.models.EmailVerificationConfirmationForm,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[Unit] = {
        val urlPath = Seq("email_verification_confirmations")

        val (payload, formPayload) = (Some(emailVerificationConfirmationForm), None)

        _executeRequest[io.apibuilder.api.v0.models.EmailVerificationConfirmationForm, Unit]("POST", path = urlPath, body = payload, formBody = formPayload, requestHeaders = requestHeaders) {
          case r if r.status.code == 204 => scalaz.concurrent.Task.now(())
          case r if r.status.code == 409 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.ErrorsResponse(r))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 204, 409"))
        }
      }
    }

    object GeneratorServices extends GeneratorServices {
      override def get(
        guid: _root_.scala.Option[_root_.java.util.UUID] = None,
        uri: _root_.scala.Option[String] = None,
        generatorKey: _root_.scala.Option[String] = None,
        limit: Long = 100L,
        offset: Long = 0L,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[Seq[io.apibuilder.api.v0.models.GeneratorService]] = {
        val urlPath = Seq("generator_services")

        val queryParameters = Seq(
          guid.map("guid" -> _.toString),
          uri.map("uri" -> _),
          generatorKey.map("generator_key" -> _),
          Some("limit" -> limit.toString),
          Some("offset" -> offset.toString)
        ).flatten

        _executeRequest[Unit, Seq[io.apibuilder.api.v0.models.GeneratorService]]("GET", path = urlPath, queryParameters = queryParameters, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[Seq[io.apibuilder.api.v0.models.GeneratorService]]("Seq[io.apibuilder.api.v0.models.GeneratorService]", r)
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200"))
        }
      }

      override def getByGuid(
        guid: _root_.java.util.UUID,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.GeneratorService] = {
        val urlPath = Seq("generator_services", guid.toString)

        _executeRequest[Unit, io.apibuilder.api.v0.models.GeneratorService]("GET", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.GeneratorService]("io.apibuilder.api.v0.models.GeneratorService", r)
          case r if r.status.code == 404 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.UnitResponse(r.status.code))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 404"))
        }
      }

      override def post(
        generatorServiceForm: io.apibuilder.api.v0.models.GeneratorServiceForm,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.GeneratorService] = {
        val urlPath = Seq("generator_services")

        val (payload, formPayload) = (Some(generatorServiceForm), None)

        _executeRequest[io.apibuilder.api.v0.models.GeneratorServiceForm, io.apibuilder.api.v0.models.GeneratorService]("POST", path = urlPath, body = payload, formBody = formPayload, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.GeneratorService]("io.apibuilder.api.v0.models.GeneratorService", r)
          case r if r.status.code == 409 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.ErrorsResponse(r))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 409"))
        }
      }

      override def deleteByGuid(
        guid: _root_.java.util.UUID,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[Unit] = {
        val urlPath = Seq("generator_services", guid.toString)

        _executeRequest[Unit, Unit]("DELETE", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 204 => scalaz.concurrent.Task.now(())
          case r if r.status.code == 403 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.UnitResponse(r.status.code))
          case r if r.status.code == 404 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.UnitResponse(r.status.code))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 204, 403, 404"))
        }
      }
    }

    object GeneratorWithServices extends GeneratorWithServices {
      override def get(
        guid: _root_.scala.Option[_root_.java.util.UUID] = None,
        serviceGuid: _root_.scala.Option[_root_.java.util.UUID] = None,
        serviceUri: _root_.scala.Option[String] = None,
        attributeName: _root_.scala.Option[String] = None,
        key: _root_.scala.Option[String] = None,
        limit: Long = 100L,
        offset: Long = 0L,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[Seq[io.apibuilder.api.v0.models.GeneratorWithService]] = {
        val urlPath = Seq("generators")

        val queryParameters = Seq(
          guid.map("guid" -> _.toString),
          serviceGuid.map("service_guid" -> _.toString),
          serviceUri.map("service_uri" -> _),
          attributeName.map("attribute_name" -> _),
          key.map("key" -> _),
          Some("limit" -> limit.toString),
          Some("offset" -> offset.toString)
        ).flatten

        _executeRequest[Unit, Seq[io.apibuilder.api.v0.models.GeneratorWithService]]("GET", path = urlPath, queryParameters = queryParameters, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[Seq[io.apibuilder.api.v0.models.GeneratorWithService]]("Seq[io.apibuilder.api.v0.models.GeneratorWithService]", r)
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200"))
        }
      }

      override def getByKey(
        key: String,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.GeneratorWithService] = {
        val urlPath = Seq("generators", key)

        _executeRequest[Unit, io.apibuilder.api.v0.models.GeneratorWithService]("GET", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.GeneratorWithService]("io.apibuilder.api.v0.models.GeneratorWithService", r)
          case r if r.status.code == 404 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.UnitResponse(r.status.code))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 404"))
        }
      }
    }

    object Healthchecks extends Healthchecks {
      override def getHealthcheck(
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.generator.v0.models.Healthcheck] = {
        val urlPath = Seq("_internal_", "healthcheck")

        _executeRequest[Unit, io.apibuilder.generator.v0.models.Healthcheck]("GET", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.generator.v0.models.Healthcheck]("io.apibuilder.generator.v0.models.Healthcheck", r)
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200"))
        }
      }

      override def getMigrate(
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[Map[String, String]] = {
        val urlPath = Seq("_internal_", "migrate")

        _executeRequest[Unit, Map[String, String]]("GET", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[Map[String, String]]("Map[String, String]", r)
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200"))
        }
      }
    }

    object Items extends Items {
      override def get(
        q: _root_.scala.Option[String] = None,
        limit: Long = 25L,
        offset: Long = 0L,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[Seq[io.apibuilder.api.v0.models.Item]] = {
        val urlPath = Seq("items")

        val queryParameters = Seq(
          q.map("q" -> _),
          Some("limit" -> limit.toString),
          Some("offset" -> offset.toString)
        ).flatten

        _executeRequest[Unit, Seq[io.apibuilder.api.v0.models.Item]]("GET", path = urlPath, queryParameters = queryParameters, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[Seq[io.apibuilder.api.v0.models.Item]]("Seq[io.apibuilder.api.v0.models.Item]", r)
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200"))
        }
      }

      override def getByGuid(
        guid: _root_.java.util.UUID,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Item] = {
        val urlPath = Seq("items", guid.toString)

        _executeRequest[Unit, io.apibuilder.api.v0.models.Item]("GET", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.Item]("io.apibuilder.api.v0.models.Item", r)
          case r if r.status.code == 404 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.UnitResponse(r.status.code))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 404"))
        }
      }
    }

    object MembershipRequests extends MembershipRequests {
      override def get(
        orgGuid: _root_.scala.Option[_root_.java.util.UUID] = None,
        orgKey: _root_.scala.Option[String] = None,
        userGuid: _root_.scala.Option[_root_.java.util.UUID] = None,
        role: _root_.scala.Option[String] = None,
        limit: Long = 25L,
        offset: Long = 0L,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[Seq[io.apibuilder.api.v0.models.MembershipRequest]] = {
        val urlPath = Seq("membership_requests")

        val queryParameters = Seq(
          orgGuid.map("org_guid" -> _.toString),
          orgKey.map("org_key" -> _),
          userGuid.map("user_guid" -> _.toString),
          role.map("role" -> _),
          Some("limit" -> limit.toString),
          Some("offset" -> offset.toString)
        ).flatten

        _executeRequest[Unit, Seq[io.apibuilder.api.v0.models.MembershipRequest]]("GET", path = urlPath, queryParameters = queryParameters, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[Seq[io.apibuilder.api.v0.models.MembershipRequest]]("Seq[io.apibuilder.api.v0.models.MembershipRequest]", r)
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200"))
        }
      }

      override def post(
        orgGuid: _root_.java.util.UUID,
        userGuid: _root_.java.util.UUID,
        role: String,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.MembershipRequest] = {
        val urlPath = Seq("membership_requests")

        val payload = None
        val formPayload = Some(org.http4s.UrlForm(
          "org_guid" -> orgGuid.asJson.noSpaces,
          "user_guid" -> userGuid.asJson.noSpaces,
          "role" -> role
        ))

        _executeRequest[Unit, io.apibuilder.api.v0.models.MembershipRequest]("POST", path = urlPath, body = payload, formBody = formPayload, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.MembershipRequest]("io.apibuilder.api.v0.models.MembershipRequest", r)
          case r if r.status.code == 409 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.ErrorsResponse(r))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 409"))
        }
      }

      override def postAcceptByGuid(
        guid: _root_.java.util.UUID,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[Unit] = {
        val urlPath = Seq("membership_requests", guid.toString, "accept")

        _executeRequest[Unit, Unit]("POST", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 204 => scalaz.concurrent.Task.now(())
          case r if r.status.code == 409 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.ErrorsResponse(r))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 204, 409"))
        }
      }

      override def postDeclineByGuid(
        guid: _root_.java.util.UUID,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[Unit] = {
        val urlPath = Seq("membership_requests", guid.toString, "decline")

        _executeRequest[Unit, Unit]("POST", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 204 => scalaz.concurrent.Task.now(())
          case r if r.status.code == 409 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.ErrorsResponse(r))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 204, 409"))
        }
      }
    }

    object Memberships extends Memberships {
      override def get(
        orgGuid: _root_.scala.Option[_root_.java.util.UUID] = None,
        orgKey: _root_.scala.Option[String] = None,
        userGuid: _root_.scala.Option[_root_.java.util.UUID] = None,
        role: _root_.scala.Option[String] = None,
        limit: Long = 25L,
        offset: Long = 0L,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[Seq[io.apibuilder.api.v0.models.Membership]] = {
        val urlPath = Seq("memberships")

        val queryParameters = Seq(
          orgGuid.map("org_guid" -> _.toString),
          orgKey.map("org_key" -> _),
          userGuid.map("user_guid" -> _.toString),
          role.map("role" -> _),
          Some("limit" -> limit.toString),
          Some("offset" -> offset.toString)
        ).flatten

        _executeRequest[Unit, Seq[io.apibuilder.api.v0.models.Membership]]("GET", path = urlPath, queryParameters = queryParameters, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[Seq[io.apibuilder.api.v0.models.Membership]]("Seq[io.apibuilder.api.v0.models.Membership]", r)
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200"))
        }
      }

      override def getByGuid(
        guid: _root_.java.util.UUID,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Membership] = {
        val urlPath = Seq("memberships", guid.toString)

        _executeRequest[Unit, io.apibuilder.api.v0.models.Membership]("GET", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.Membership]("io.apibuilder.api.v0.models.Membership", r)
          case r if r.status.code == 404 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.UnitResponse(r.status.code))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 404"))
        }
      }

      override def deleteByGuid(
        guid: _root_.java.util.UUID,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[Unit] = {
        val urlPath = Seq("memberships", guid.toString)

        _executeRequest[Unit, Unit]("DELETE", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 204 => scalaz.concurrent.Task.now(())
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 204"))
        }
      }
    }

    object Organizations extends Organizations {
      override def get(
        guid: _root_.scala.Option[_root_.java.util.UUID] = None,
        userGuid: _root_.scala.Option[_root_.java.util.UUID] = None,
        key: _root_.scala.Option[String] = None,
        name: _root_.scala.Option[String] = None,
        namespace: _root_.scala.Option[String] = None,
        limit: Long = 25L,
        offset: Long = 0L,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[Seq[io.apibuilder.api.v0.models.Organization]] = {
        val urlPath = Seq("organizations")

        val queryParameters = Seq(
          guid.map("guid" -> _.toString),
          userGuid.map("user_guid" -> _.toString),
          key.map("key" -> _),
          name.map("name" -> _),
          namespace.map("namespace" -> _),
          Some("limit" -> limit.toString),
          Some("offset" -> offset.toString)
        ).flatten

        _executeRequest[Unit, Seq[io.apibuilder.api.v0.models.Organization]]("GET", path = urlPath, queryParameters = queryParameters, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[Seq[io.apibuilder.api.v0.models.Organization]]("Seq[io.apibuilder.api.v0.models.Organization]", r)
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200"))
        }
      }

      override def getByKey(
        key: String,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Organization] = {
        val urlPath = Seq("organizations", key)

        _executeRequest[Unit, io.apibuilder.api.v0.models.Organization]("GET", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.Organization]("io.apibuilder.api.v0.models.Organization", r)
          case r if r.status.code == 404 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.UnitResponse(r.status.code))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 404"))
        }
      }

      override def post(
        organizationForm: io.apibuilder.api.v0.models.OrganizationForm,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Organization] = {
        val urlPath = Seq("organizations")

        val (payload, formPayload) = (Some(organizationForm), None)

        _executeRequest[io.apibuilder.api.v0.models.OrganizationForm, io.apibuilder.api.v0.models.Organization]("POST", path = urlPath, body = payload, formBody = formPayload, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.Organization]("io.apibuilder.api.v0.models.Organization", r)
          case r if r.status.code == 409 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.ErrorsResponse(r))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 409"))
        }
      }

      override def putByKey(
        key: String,
        organizationForm: io.apibuilder.api.v0.models.OrganizationForm,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Organization] = {
        val urlPath = Seq("organizations", key)

        val (payload, formPayload) = (Some(organizationForm), None)

        _executeRequest[io.apibuilder.api.v0.models.OrganizationForm, io.apibuilder.api.v0.models.Organization]("PUT", path = urlPath, body = payload, formBody = formPayload, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.Organization]("io.apibuilder.api.v0.models.Organization", r)
          case r if r.status.code == 409 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.ErrorsResponse(r))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 409"))
        }
      }

      override def deleteByKey(
        key: String,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[Unit] = {
        val urlPath = Seq("organizations", key)

        _executeRequest[Unit, Unit]("DELETE", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 204 => scalaz.concurrent.Task.now(())
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 204"))
        }
      }

      override def getAttributesByKey(
        key: String,
        name: _root_.scala.Option[String] = None,
        limit: Long = 25L,
        offset: Long = 0L,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[Seq[io.apibuilder.api.v0.models.AttributeValue]] = {
        val urlPath = Seq("organizations", key, "attributes")

        val queryParameters = Seq(
          name.map("name" -> _),
          Some("limit" -> limit.toString),
          Some("offset" -> offset.toString)
        ).flatten

        _executeRequest[Unit, Seq[io.apibuilder.api.v0.models.AttributeValue]]("GET", path = urlPath, queryParameters = queryParameters, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[Seq[io.apibuilder.api.v0.models.AttributeValue]]("Seq[io.apibuilder.api.v0.models.AttributeValue]", r)
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200"))
        }
      }

      override def getAttributesByKeyAndName(
        key: String,
        name: String,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.AttributeValue] = {
        val urlPath = Seq("organizations", key, "attributes", name)

        _executeRequest[Unit, io.apibuilder.api.v0.models.AttributeValue]("GET", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.AttributeValue]("io.apibuilder.api.v0.models.AttributeValue", r)
          case r if r.status.code == 404 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.UnitResponse(r.status.code))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 404"))
        }
      }

      override def putAttributesByKeyAndName(
        key: String,
        name: String,
        attributeValueForm: io.apibuilder.api.v0.models.AttributeValueForm,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.AttributeValue] = {
        val urlPath = Seq("organizations", key, "attributes", name)

        val (payload, formPayload) = (Some(attributeValueForm), None)

        _executeRequest[io.apibuilder.api.v0.models.AttributeValueForm, io.apibuilder.api.v0.models.AttributeValue]("PUT", path = urlPath, body = payload, formBody = formPayload, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.AttributeValue]("io.apibuilder.api.v0.models.AttributeValue", r)
          case r if r.status.code == 201 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.AttributeValue]("io.apibuilder.api.v0.models.AttributeValue", r)
          case r if r.status.code == 404 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.UnitResponse(r.status.code))
          case r if r.status.code == 409 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.ErrorsResponse(r))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 201, 404, 409"))
        }
      }

      override def deleteAttributesByKeyAndName(
        key: String,
        name: String,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[Unit] = {
        val urlPath = Seq("organizations", key, "attributes", name)

        _executeRequest[Unit, Unit]("DELETE", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 204 => scalaz.concurrent.Task.now(())
          case r if r.status.code == 401 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.UnitResponse(r.status.code))
          case r if r.status.code == 404 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.UnitResponse(r.status.code))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 204, 401, 404"))
        }
      }
    }

    object PasswordResetRequests extends PasswordResetRequests {
      override def post(
        passwordResetRequest: io.apibuilder.api.v0.models.PasswordResetRequest,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[Unit] = {
        val urlPath = Seq("password_reset_requests")

        val (payload, formPayload) = (Some(passwordResetRequest), None)

        _executeRequest[io.apibuilder.api.v0.models.PasswordResetRequest, Unit]("POST", path = urlPath, body = payload, formBody = formPayload, requestHeaders = requestHeaders) {
          case r if r.status.code == 204 => scalaz.concurrent.Task.now(())
          case r if r.status.code == 409 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.ErrorsResponse(r))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 204, 409"))
        }
      }
    }

    object PasswordResets extends PasswordResets {
      override def post(
        passwordReset: io.apibuilder.api.v0.models.PasswordReset,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.PasswordResetSuccess] = {
        val urlPath = Seq("password_resets")

        val (payload, formPayload) = (Some(passwordReset), None)

        _executeRequest[io.apibuilder.api.v0.models.PasswordReset, io.apibuilder.api.v0.models.PasswordResetSuccess]("POST", path = urlPath, body = payload, formBody = formPayload, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.PasswordResetSuccess]("io.apibuilder.api.v0.models.PasswordResetSuccess", r)
          case r if r.status.code == 409 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.ErrorsResponse(r))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 409"))
        }
      }
    }

    object Subscriptions extends Subscriptions {
      override def get(
        guid: _root_.scala.Option[_root_.java.util.UUID] = None,
        organizationKey: _root_.scala.Option[String] = None,
        userGuid: _root_.scala.Option[_root_.java.util.UUID] = None,
        publication: _root_.scala.Option[io.apibuilder.api.v0.models.Publication] = None,
        limit: Long = 25L,
        offset: Long = 0L,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[Seq[io.apibuilder.api.v0.models.Subscription]] = {
        val urlPath = Seq("subscriptions")

        val queryParameters = Seq(
          guid.map("guid" -> _.toString),
          organizationKey.map("organization_key" -> _),
          userGuid.map("user_guid" -> _.toString),
          publication.map("publication" -> _.toString),
          Some("limit" -> limit.toString),
          Some("offset" -> offset.toString)
        ).flatten

        _executeRequest[Unit, Seq[io.apibuilder.api.v0.models.Subscription]]("GET", path = urlPath, queryParameters = queryParameters, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[Seq[io.apibuilder.api.v0.models.Subscription]]("Seq[io.apibuilder.api.v0.models.Subscription]", r)
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200"))
        }
      }

      override def getByGuid(
        guid: _root_.java.util.UUID,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Subscription] = {
        val urlPath = Seq("subscriptions", guid.toString)

        _executeRequest[Unit, io.apibuilder.api.v0.models.Subscription]("GET", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.Subscription]("io.apibuilder.api.v0.models.Subscription", r)
          case r if r.status.code == 404 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.UnitResponse(r.status.code))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 404"))
        }
      }

      override def post(
        subscriptionForm: io.apibuilder.api.v0.models.SubscriptionForm,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Subscription] = {
        val urlPath = Seq("subscriptions")

        val (payload, formPayload) = (Some(subscriptionForm), None)

        _executeRequest[io.apibuilder.api.v0.models.SubscriptionForm, io.apibuilder.api.v0.models.Subscription]("POST", path = urlPath, body = payload, formBody = formPayload, requestHeaders = requestHeaders) {
          case r if r.status.code == 201 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.Subscription]("io.apibuilder.api.v0.models.Subscription", r)
          case r if r.status.code == 409 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.ErrorsResponse(r))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 201, 409"))
        }
      }

      override def deleteByGuid(
        guid: _root_.java.util.UUID,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[Unit] = {
        val urlPath = Seq("subscriptions", guid.toString)

        _executeRequest[Unit, Unit]("DELETE", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 204 => scalaz.concurrent.Task.now(())
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 204"))
        }
      }
    }

    object Tokens extends Tokens {
      override def getUsersByUserGuid(
        userGuid: _root_.java.util.UUID,
        guid: _root_.scala.Option[_root_.java.util.UUID] = None,
        limit: Long = 25L,
        offset: Long = 0L,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[Seq[io.apibuilder.api.v0.models.Token]] = {
        val urlPath = Seq("tokens", "users", userGuid.toString)

        val queryParameters = Seq(
          guid.map("guid" -> _.toString),
          Some("limit" -> limit.toString),
          Some("offset" -> offset.toString)
        ).flatten

        _executeRequest[Unit, Seq[io.apibuilder.api.v0.models.Token]]("GET", path = urlPath, queryParameters = queryParameters, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[Seq[io.apibuilder.api.v0.models.Token]]("Seq[io.apibuilder.api.v0.models.Token]", r)
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200"))
        }
      }

      override def getCleartextByGuid(
        guid: _root_.java.util.UUID,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.CleartextToken] = {
        val urlPath = Seq("tokens", guid.toString, "cleartext")

        _executeRequest[Unit, io.apibuilder.api.v0.models.CleartextToken]("GET", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.CleartextToken]("io.apibuilder.api.v0.models.CleartextToken", r)
          case r if r.status.code == 404 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.UnitResponse(r.status.code))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 404"))
        }
      }

      override def post(
        tokenForm: io.apibuilder.api.v0.models.TokenForm,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Token] = {
        val urlPath = Seq("tokens")

        val (payload, formPayload) = (Some(tokenForm), None)

        _executeRequest[io.apibuilder.api.v0.models.TokenForm, io.apibuilder.api.v0.models.Token]("POST", path = urlPath, body = payload, formBody = formPayload, requestHeaders = requestHeaders) {
          case r if r.status.code == 201 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.Token]("io.apibuilder.api.v0.models.Token", r)
          case r if r.status.code == 409 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.ErrorsResponse(r))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 201, 409"))
        }
      }

      override def deleteByGuid(
        guid: _root_.java.util.UUID,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[Unit] = {
        val urlPath = Seq("tokens", guid.toString)

        _executeRequest[Unit, Unit]("DELETE", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 204 => scalaz.concurrent.Task.now(())
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 204"))
        }
      }
    }

    object Users extends Users {
      override def get(
        guid: _root_.scala.Option[_root_.java.util.UUID] = None,
        email: _root_.scala.Option[String] = None,
        token: _root_.scala.Option[String] = None,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[Seq[io.apibuilder.api.v0.models.User]] = {
        val urlPath = Seq("users")

        val queryParameters = Seq(
          guid.map("guid" -> _.toString),
          email.map("email" -> _),
          token.map("token" -> _)
        ).flatten

        _executeRequest[Unit, Seq[io.apibuilder.api.v0.models.User]]("GET", path = urlPath, queryParameters = queryParameters, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[Seq[io.apibuilder.api.v0.models.User]]("Seq[io.apibuilder.api.v0.models.User]", r)
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200"))
        }
      }

      override def getByGuid(
        guid: _root_.java.util.UUID,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.User] = {
        val urlPath = Seq("users", guid.toString)

        _executeRequest[Unit, io.apibuilder.api.v0.models.User]("GET", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.User]("io.apibuilder.api.v0.models.User", r)
          case r if r.status.code == 404 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.UnitResponse(r.status.code))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 404"))
        }
      }

      override def postAuthenticate(
        email: String,
        password: String,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.User] = {
        val urlPath = Seq("users", "authenticate")

        val payload = None
        val formPayload = Some(org.http4s.UrlForm(
          "email" -> email,
          "password" -> password
        ))

        _executeRequest[Unit, io.apibuilder.api.v0.models.User]("POST", path = urlPath, body = payload, formBody = formPayload, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.User]("io.apibuilder.api.v0.models.User", r)
          case r if r.status.code == 409 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.ErrorsResponse(r))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 409"))
        }
      }

      override def post(
        userForm: io.apibuilder.api.v0.models.UserForm,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.User] = {
        val urlPath = Seq("users")

        val (payload, formPayload) = (Some(userForm), None)

        _executeRequest[io.apibuilder.api.v0.models.UserForm, io.apibuilder.api.v0.models.User]("POST", path = urlPath, body = payload, formBody = formPayload, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.User]("io.apibuilder.api.v0.models.User", r)
          case r if r.status.code == 409 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.ErrorsResponse(r))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 409"))
        }
      }

      override def putByGuid(
        guid: _root_.java.util.UUID,
        userUpdateForm: io.apibuilder.api.v0.models.UserUpdateForm,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.User] = {
        val urlPath = Seq("users", guid.toString)

        val (payload, formPayload) = (Some(userUpdateForm), None)

        _executeRequest[io.apibuilder.api.v0.models.UserUpdateForm, io.apibuilder.api.v0.models.User]("PUT", path = urlPath, body = payload, formBody = formPayload, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.User]("io.apibuilder.api.v0.models.User", r)
          case r if r.status.code == 409 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.ErrorsResponse(r))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 409"))
        }
      }
    }

    object Validations extends Validations {
      override def post(
        value: String,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Validation] = {
        val urlPath = Seq("validations")

        val (payload, formPayload) = (Some(value), None)

        _executeRequest[String, io.apibuilder.api.v0.models.Validation]("POST", path = urlPath, body = payload, formBody = formPayload, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.Validation]("io.apibuilder.api.v0.models.Validation", r)
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200"))
        }
      }
    }

    object Versions extends Versions {
      override def getByApplicationKey(
        orgKey: String,
        applicationKey: String,
        limit: Long = 25L,
        offset: Long = 0L,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[Seq[io.apibuilder.api.v0.models.Version]] = {
        val urlPath = Seq(orgKey, applicationKey)

        val queryParameters = Seq(
          Some("limit" -> limit.toString),
          Some("offset" -> offset.toString)
        ).flatten

        _executeRequest[Unit, Seq[io.apibuilder.api.v0.models.Version]]("GET", path = urlPath, queryParameters = queryParameters, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[Seq[io.apibuilder.api.v0.models.Version]]("Seq[io.apibuilder.api.v0.models.Version]", r)
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200"))
        }
      }

      override def getByApplicationKeyAndVersion(
        orgKey: String,
        applicationKey: String,
        version: String,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Version] = {
        val urlPath = Seq(orgKey, applicationKey, version)

        _executeRequest[Unit, io.apibuilder.api.v0.models.Version]("GET", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.Version]("io.apibuilder.api.v0.models.Version", r)
          case r if r.status.code == 404 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.UnitResponse(r.status.code))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 404"))
        }
      }

      override def postByVersion(
        orgKey: String,
        version: String,
        versionForm: io.apibuilder.api.v0.models.VersionForm,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Version] = {
        val urlPath = Seq(orgKey, version)

        val (payload, formPayload) = (Some(versionForm), None)

        _executeRequest[io.apibuilder.api.v0.models.VersionForm, io.apibuilder.api.v0.models.Version]("POST", path = urlPath, body = payload, formBody = formPayload, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.Version]("io.apibuilder.api.v0.models.Version", r)
          case r if r.status.code == 409 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.ErrorsResponse(r))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 409"))
        }
      }

      override def putByApplicationKeyAndVersion(
        orgKey: String,
        applicationKey: String,
        version: String,
        versionForm: io.apibuilder.api.v0.models.VersionForm,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Version] = {
        val urlPath = Seq(orgKey, applicationKey, version)

        val (payload, formPayload) = (Some(versionForm), None)

        _executeRequest[io.apibuilder.api.v0.models.VersionForm, io.apibuilder.api.v0.models.Version]("PUT", path = urlPath, body = payload, formBody = formPayload, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.Version]("io.apibuilder.api.v0.models.Version", r)
          case r if r.status.code == 409 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.ErrorsResponse(r))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 409"))
        }
      }

      override def deleteByApplicationKeyAndVersion(
        orgKey: String,
        applicationKey: String,
        version: String,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[Unit] = {
        val urlPath = Seq(orgKey, applicationKey, version)

        _executeRequest[Unit, Unit]("DELETE", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 204 => scalaz.concurrent.Task.now(())
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 204"))
        }
      }
    }

    object Watches extends Watches {
      override def get(
        guid: _root_.scala.Option[_root_.java.util.UUID] = None,
        userGuid: _root_.scala.Option[_root_.java.util.UUID] = None,
        organizationKey: _root_.scala.Option[String] = None,
        applicationKey: _root_.scala.Option[String] = None,
        limit: Long = 25L,
        offset: Long = 0L,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[Seq[io.apibuilder.api.v0.models.Watch]] = {
        val urlPath = Seq("watches")

        val queryParameters = Seq(
          guid.map("guid" -> _.toString),
          userGuid.map("user_guid" -> _.toString),
          organizationKey.map("organization_key" -> _),
          applicationKey.map("application_key" -> _),
          Some("limit" -> limit.toString),
          Some("offset" -> offset.toString)
        ).flatten

        _executeRequest[Unit, Seq[io.apibuilder.api.v0.models.Watch]]("GET", path = urlPath, queryParameters = queryParameters, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[Seq[io.apibuilder.api.v0.models.Watch]]("Seq[io.apibuilder.api.v0.models.Watch]", r)
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200"))
        }
      }

      override def getByGuid(
        guid: _root_.java.util.UUID,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Watch] = {
        val urlPath = Seq("watches", guid.toString)

        _executeRequest[Unit, io.apibuilder.api.v0.models.Watch]("GET", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.Watch]("io.apibuilder.api.v0.models.Watch", r)
          case r if r.status.code == 404 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.UnitResponse(r.status.code))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 404"))
        }
      }

      override def getCheck(
        userGuid: _root_.scala.Option[_root_.java.util.UUID] = None,
        organizationKey: String,
        applicationKey: String,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[Boolean] = {
        val urlPath = Seq("watches", "check")

        val queryParameters = Seq(
          userGuid.map("user_guid" -> _.toString),
          Some("organization_key" -> organizationKey),
          Some("application_key" -> applicationKey)
        ).flatten

        _executeRequest[Unit, Boolean]("GET", path = urlPath, queryParameters = queryParameters, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.apibuilder.api.v0.Client.parseJson[Boolean]("Boolean", r)
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200"))
        }
      }

      override def post(
        watchForm: io.apibuilder.api.v0.models.WatchForm,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Watch] = {
        val urlPath = Seq("watches")

        val (payload, formPayload) = (Some(watchForm), None)

        _executeRequest[io.apibuilder.api.v0.models.WatchForm, io.apibuilder.api.v0.models.Watch]("POST", path = urlPath, body = payload, formBody = formPayload, requestHeaders = requestHeaders) {
          case r if r.status.code == 201 => _root_.io.apibuilder.api.v0.Client.parseJson[io.apibuilder.api.v0.models.Watch]("io.apibuilder.api.v0.models.Watch", r)
          case r if r.status.code == 409 => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.ErrorsResponse(r))
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 201, 409"))
        }
      }

      override def deleteByGuid(
        guid: _root_.java.util.UUID,
        requestHeaders: Seq[(String, String)] = Nil
      ): scalaz.concurrent.Task[Unit] = {
        val urlPath = Seq("watches", guid.toString)

        _executeRequest[Unit, Unit]("DELETE", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 204 => scalaz.concurrent.Task.now(())
          case r => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 204"))
        }
      }
    }

    private lazy val defaultApiHeaders = Seq(
      ("User-Agent", Constants.UserAgent),
      ("X-Apidoc-Version", Constants.Version),
      ("X-Apidoc-Version-Major", Constants.VersionMajor.toString)
    )

    def apiHeaders: Seq[(String, String)] = defaultApiHeaders

    def modifyRequest(request: scalaz.concurrent.Task[org.http4s.Request]): scalaz.concurrent.Task[org.http4s.Request] = request

    implicit def circeJsonEncoder[A](implicit encoder: io.circe.Encoder[A]) = org.http4s.circe.jsonEncoderOf[A]

    def _executeRequest[T, U](
      method: String,
      path: Seq[String],
      queryParameters: Seq[(String, String)] = Nil,
      requestHeaders: Seq[(String, String)] = Nil,
      body: Option[T] = None,
      formBody : Option[org.http4s.UrlForm] = None
    )(handler: org.http4s.Response => scalaz.concurrent.Task[U]
    )(implicit encoder: io.circe.Encoder[T]): scalaz.concurrent.Task[U] = {
      import org.http4s.QueryParamEncoder._

      val m = org.http4s.Method.fromString(method) match {
        case scalaz.\/-(m) => m
        case scalaz.-\/(e) => sys.error(e.toString)
      }

      val headers = org.http4s.Headers((
        apiHeaders ++
        defaultHeaders ++
        requestHeaders
      ).toList.map { case (k, v) => org.http4s.Header(k, v) })

      val queryMap = queryParameters.groupBy(_._1).map { case (k, v) => k -> v.map(_._2) }
      val uri = path.foldLeft(baseUrl){ case (uri, segment) => uri / segment }.setQueryParams(queryMap)

      val request = org.http4s.Request(method = m,
                                       uri = uri,
                                       headers = headers)

      val reqAndMaybeAuth = auth.fold(request) {
        case Authorization.Basic(username, passwordOpt) => {
          val userpass = s"$username:${passwordOpt.getOrElse("")}"
          val token = java.util.Base64.getEncoder.encodeToString(userpass.getBytes(java.nio.charset.StandardCharsets.ISO_8859_1))
          request.putHeaders(org.http4s.Header("Authorization", s"Basic $token"))
        }
        case a => sys.error("Invalid authorization scheme[" + a.getClass + "]")
      }

      val reqAndMaybeAuthAndBody =
        if (formBody.nonEmpty) formBody.fold(scalaz.concurrent.Task.now(reqAndMaybeAuth))(reqAndMaybeAuth.withBody)
        else body.fold(scalaz.concurrent.Task.now(reqAndMaybeAuth))(reqAndMaybeAuth.withBody)

      asyncHttpClient.fetch(modifyRequest(reqAndMaybeAuthAndBody))(handler)
    }
  }

  object Client {



    implicit def circeJsonDecoder[A](implicit decoder: io.circe.Decoder[A]) = org.http4s.circe.jsonOf[A]

    private lazy val defaultAsyncHttpClient = PooledHttp1Client()

    def parseJson[T](
      className: String,
      r: org.http4s.Response
    )(implicit decoder: io.circe.Decoder[T]): scalaz.concurrent.Task[T] = r.attemptAs[T].run.flatMap {
      case scalaz.\/-(value) => scalaz.concurrent.Task.now(value)
      case scalaz.-\/(error) => scalaz.concurrent.Task.fail(new io.apibuilder.api.v0.errors.FailedRequest(r.status.code, s"Invalid json for class[" + className + "]", None, error))
    }
  }

  sealed trait Authorization extends _root_.scala.Product with _root_.scala.Serializable
  object Authorization {
    final case class Basic(username: String, password: Option[String] = None) extends Authorization
  }

  package interfaces {

    trait Client {
      def baseUrl: org.http4s.Uri
      def applications: io.apibuilder.api.v0.Applications
      def attributes: io.apibuilder.api.v0.Attributes
      def changes: io.apibuilder.api.v0.Changes
      def code: io.apibuilder.api.v0.Code
      def domains: io.apibuilder.api.v0.Domains
      def emailVerificationConfirmationForms: io.apibuilder.api.v0.EmailVerificationConfirmationForms
      def generatorServices: io.apibuilder.api.v0.GeneratorServices
      def generatorWithServices: io.apibuilder.api.v0.GeneratorWithServices
      def healthchecks: io.apibuilder.api.v0.Healthchecks
      def items: io.apibuilder.api.v0.Items
      def membershipRequests: io.apibuilder.api.v0.MembershipRequests
      def memberships: io.apibuilder.api.v0.Memberships
      def organizations: io.apibuilder.api.v0.Organizations
      def passwordResetRequests: io.apibuilder.api.v0.PasswordResetRequests
      def passwordResets: io.apibuilder.api.v0.PasswordResets
      def subscriptions: io.apibuilder.api.v0.Subscriptions
      def tokens: io.apibuilder.api.v0.Tokens
      def users: io.apibuilder.api.v0.Users
      def validations: io.apibuilder.api.v0.Validations
      def versions: io.apibuilder.api.v0.Versions
      def watches: io.apibuilder.api.v0.Watches
    }

  }

  trait Applications {
    /**
     * Search all applications. Results are always paginated.
     * 
     * @param orgKey The organization key for which to search applications
     * @param name The name of an application. Case in-sensitive. Exact match
     * @param guid The guid of an application. Exact match
     * @param key The key of an application. Case in-sensitive. Exact match
     * @param hasVersion If true, we return applications that have at least one version. If false, we
     *        return applications that have no versions in the system
     * @param limit The number of records to return
     * @param offset Used to paginate. First page of results is 0.
     */
    def get(
      orgKey: String,
      name: _root_.scala.Option[String] = None,
      guid: _root_.scala.Option[_root_.java.util.UUID] = None,
      key: _root_.scala.Option[String] = None,
      hasVersion: _root_.scala.Option[Boolean] = None,
      limit: Long = 25L,
      offset: Long = 0L,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[Seq[io.apibuilder.api.v0.models.Application]]

    /**
     * Create an application.
     */
    def post(
      orgKey: String,
      applicationForm: io.apibuilder.api.v0.models.ApplicationForm,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Application]

    /**
     * Updates an application.
     */
    def putByApplicationKey(
      orgKey: String,
      applicationKey: String,
      applicationForm: io.apibuilder.api.v0.models.ApplicationForm,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Application]

    /**
     * Deletes a specific application and its associated versions.
     */
    def deleteByApplicationKey(
      orgKey: String,
      applicationKey: String,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[Unit]

    /**
     * Moves application to a new organization.
     */
    def postMoveByApplicationKey(
      orgKey: String,
      applicationKey: String,
      moveForm: io.apibuilder.api.v0.models.MoveForm,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Application]
  }

  trait Attributes {
    /**
     * Search all attributes. Results are always paginated.
     * 
     * @param guid Find the watch with this guid.
     * @param name Find attributes with this name. Case in-sensitive. Exact match
     * @param limit The number of records to return
     * @param offset Used to paginate. First page of results is 0.
     */
    def get(
      guid: _root_.scala.Option[_root_.java.util.UUID] = None,
      name: _root_.scala.Option[String] = None,
      limit: Long = 25L,
      offset: Long = 0L,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[Seq[io.apibuilder.api.v0.models.Attribute]]

    /**
     * Returns the attribute with this name.
     */
    def getByName(
      name: String,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Attribute]

    /**
     * Create a new attribute.
     */
    def post(
      attributeForm: io.apibuilder.api.v0.models.AttributeForm,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Attribute]

    /**
     * Deletes the attribute with this name. Only the user who created an attribute can
     * delete it.
     */
    def deleteByName(
      name: String,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[Unit]
  }

  trait Changes {
    /**
     * @param orgKey Filter changes to those made for the organization with this key.
     * @param applicationKey Filter changes to those made for the application with this key.
     * @param limit The number of records to return
     * @param offset Used to paginate. First page of results is 0.
     */
    def get(
      orgKey: _root_.scala.Option[String] = None,
      applicationKey: _root_.scala.Option[String] = None,
      limit: Long = 25L,
      offset: Long = 0L,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[Seq[io.apibuilder.api.v0.models.Change]]
  }

  trait Code {
    /**
     * Generate code for a specific version of an application.
     * 
     * @param orgKey The organization key for which to generate code
     * @param applicationKey The application key for which to generate code
     * @param version The version of this application. Can be 'latest'
     * @param generatorKey The key of the generator to invoke
     */
    def get(
      orgKey: String,
      applicationKey: String,
      version: String,
      generatorKey: String,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Code]
  }

  trait Domains {
    /**
     * Add a domain to this organization
     */
    def post(
      orgKey: String,
      domain: io.apibuilder.api.v0.models.Domain,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Domain]

    /**
     * Remove this domain from this organization
     */
    def deleteByName(
      orgKey: String,
      name: String,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[Unit]
  }

  trait EmailVerificationConfirmationForms {
    /**
     * Validate an email address using a token.
     */
    def post(
      emailVerificationConfirmationForm: io.apibuilder.api.v0.models.EmailVerificationConfirmationForm,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[Unit]
  }

  trait GeneratorServices {
    /**
     * List all generator services
     * 
     * @param limit The number of records to return
     * @param offset Used to paginate. First page of results is 0.
     */
    def get(
      guid: _root_.scala.Option[_root_.java.util.UUID] = None,
      uri: _root_.scala.Option[String] = None,
      generatorKey: _root_.scala.Option[String] = None,
      limit: Long = 100L,
      offset: Long = 0L,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[Seq[io.apibuilder.api.v0.models.GeneratorService]]

    def getByGuid(
      guid: _root_.java.util.UUID,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.GeneratorService]

    def post(
      generatorServiceForm: io.apibuilder.api.v0.models.GeneratorServiceForm,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.GeneratorService]

    /**
     * Deletes a generator service.
     */
    def deleteByGuid(
      guid: _root_.java.util.UUID,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[Unit]
  }

  trait GeneratorWithServices {
    /**
     * List all available generators
     * 
     * @param guid Filter to generator with this guid
     * @param serviceGuid Filter to generator from this service
     * @param serviceUri Filter to generator from this service URI
     * @param attributeName Filter to generators that use this attribute
     * @param key Filter to generator with this key
     * @param limit The number of records to return
     * @param offset Used to paginate. First page of results is 0.
     */
    def get(
      guid: _root_.scala.Option[_root_.java.util.UUID] = None,
      serviceGuid: _root_.scala.Option[_root_.java.util.UUID] = None,
      serviceUri: _root_.scala.Option[String] = None,
      attributeName: _root_.scala.Option[String] = None,
      key: _root_.scala.Option[String] = None,
      limit: Long = 100L,
      offset: Long = 0L,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[Seq[io.apibuilder.api.v0.models.GeneratorWithService]]

    def getByKey(
      key: String,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.GeneratorWithService]
  }

  trait Healthchecks {
    def getHealthcheck(
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.generator.v0.models.Healthcheck]

    def getMigrate(
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[Map[String, String]]
  }

  trait Items {
    /**
     * @param q The search query. At the moment, we do case insensitive exact match search.
     * @param limit The number of records to return
     * @param offset Used to paginate. First page of results is 0.
     */
    def get(
      q: _root_.scala.Option[String] = None,
      limit: Long = 25L,
      offset: Long = 0L,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[Seq[io.apibuilder.api.v0.models.Item]]

    def getByGuid(
      guid: _root_.java.util.UUID,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Item]
  }

  trait MembershipRequests {
    /**
     * Search all membership requests. Results are always paginated.
     * 
     * @param limit The number of records to return
     * @param offset Used to paginate. First page of results is 0.
     */
    def get(
      orgGuid: _root_.scala.Option[_root_.java.util.UUID] = None,
      orgKey: _root_.scala.Option[String] = None,
      userGuid: _root_.scala.Option[_root_.java.util.UUID] = None,
      role: _root_.scala.Option[String] = None,
      limit: Long = 25L,
      offset: Long = 0L,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[Seq[io.apibuilder.api.v0.models.MembershipRequest]]

    /**
     * Create a membership request
     */
    def post(
      orgGuid: _root_.java.util.UUID,
      userGuid: _root_.java.util.UUID,
      role: String,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.MembershipRequest]

    /**
     * Accepts this membership request. User will become a member of the specified
     * organization.
     */
    def postAcceptByGuid(
      guid: _root_.java.util.UUID,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[Unit]

    /**
     * Declines this membership request. User will NOT become a member of the specified
     * organization.
     */
    def postDeclineByGuid(
      guid: _root_.java.util.UUID,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[Unit]
  }

  trait Memberships {
    /**
     * Search all memberships. Results are always paginated.
     * 
     * @param limit The number of records to return
     * @param offset Used to paginate. First page of results is 0.
     */
    def get(
      orgGuid: _root_.scala.Option[_root_.java.util.UUID] = None,
      orgKey: _root_.scala.Option[String] = None,
      userGuid: _root_.scala.Option[_root_.java.util.UUID] = None,
      role: _root_.scala.Option[String] = None,
      limit: Long = 25L,
      offset: Long = 0L,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[Seq[io.apibuilder.api.v0.models.Membership]]

    def getByGuid(
      guid: _root_.java.util.UUID,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Membership]

    def deleteByGuid(
      guid: _root_.java.util.UUID,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[Unit]
  }

  trait Organizations {
    /**
     * Search all organizations. Results are always paginated.
     * 
     * @param guid Finds the organization with this guid, if any
     * @param userGuid If specified, restricts to organizations that this user is specifically a member
     *        of (e.g. will exclude public organizations with which the user does not have a
     *        direct membership).
     * @param key Find organizations with this key. Case in-sensitive. Exact match
     * @param name Find organizations with this name. Case in-sensitive. Exact match
     * @param namespace Find organizations with this namespace. Case in-sensitive. Exact match
     * @param limit The number of records to return
     * @param offset Used to paginate. First page of results is 0.
     */
    def get(
      guid: _root_.scala.Option[_root_.java.util.UUID] = None,
      userGuid: _root_.scala.Option[_root_.java.util.UUID] = None,
      key: _root_.scala.Option[String] = None,
      name: _root_.scala.Option[String] = None,
      namespace: _root_.scala.Option[String] = None,
      limit: Long = 25L,
      offset: Long = 0L,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[Seq[io.apibuilder.api.v0.models.Organization]]

    /**
     * Returns the organization with this key.
     */
    def getByKey(
      key: String,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Organization]

    /**
     * Create a new organization.
     */
    def post(
      organizationForm: io.apibuilder.api.v0.models.OrganizationForm,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Organization]

    /**
     * Update an organization.
     */
    def putByKey(
      key: String,
      organizationForm: io.apibuilder.api.v0.models.OrganizationForm,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Organization]

    /**
     * Deletes an organization and all of its associated applications.
     */
    def deleteByKey(
      key: String,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[Unit]

    /**
     * Returns all attribute values for this organization. Results are always
     * paginated.
     * 
     * @param name Find the values for the attribute with this name.
     * @param limit The number of records to return
     * @param offset Used to paginate. First page of results is 0.
     */
    def getAttributesByKey(
      key: String,
      name: _root_.scala.Option[String] = None,
      limit: Long = 25L,
      offset: Long = 0L,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[Seq[io.apibuilder.api.v0.models.AttributeValue]]

    /**
     * Returns the attribute value with this name.
     */
    def getAttributesByKeyAndName(
      key: String,
      name: String,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.AttributeValue]

    /**
     * Create or update a new attribute value.
     */
    def putAttributesByKeyAndName(
      key: String,
      name: String,
      attributeValueForm: io.apibuilder.api.v0.models.AttributeValueForm,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.AttributeValue]

    /**
     * Deletes the attribute value with the specified name. Only the user who created
     * an attribute value can delete it.
     */
    def deleteAttributesByKeyAndName(
      key: String,
      name: String,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[Unit]
  }

  trait PasswordResetRequests {
    /**
     * Create a new password reset. This will send the user an email with a link to
     * reset their password.
     */
    def post(
      passwordResetRequest: io.apibuilder.api.v0.models.PasswordResetRequest,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[Unit]
  }

  trait PasswordResets {
    /**
     * Change the password for this token. If the token is invalid, has been used, or
     * otherwise no longer can be applied, errors will be returned as 409s. A 204
     * represents that the user has successfully changed their password.
     */
    def post(
      passwordReset: io.apibuilder.api.v0.models.PasswordReset,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.PasswordResetSuccess]
  }

  trait Subscriptions {
    /**
     * Search subscriptions. Always paginated.
     * 
     * @param guid Find the subscription with this guid.
     * @param organizationKey Find subscriptions for this organization.
     * @param userGuid Find subscriptions for this user.
     * @param publication Find subscriptions for this publication.
     * @param limit The number of records to return
     * @param offset Used to paginate. First page of results is 0.
     */
    def get(
      guid: _root_.scala.Option[_root_.java.util.UUID] = None,
      organizationKey: _root_.scala.Option[String] = None,
      userGuid: _root_.scala.Option[_root_.java.util.UUID] = None,
      publication: _root_.scala.Option[io.apibuilder.api.v0.models.Publication] = None,
      limit: Long = 25L,
      offset: Long = 0L,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[Seq[io.apibuilder.api.v0.models.Subscription]]

    /**
     * Returns information about a specific subscription.
     */
    def getByGuid(
      guid: _root_.java.util.UUID,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Subscription]

    /**
     * Create a new subscription.
     */
    def post(
      subscriptionForm: io.apibuilder.api.v0.models.SubscriptionForm,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Subscription]

    def deleteByGuid(
      guid: _root_.java.util.UUID,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[Unit]
  }

  trait Tokens {
    /**
     * @param limit The number of records to return
     * @param offset Used to paginate. First page of results is 0.
     */
    def getUsersByUserGuid(
      userGuid: _root_.java.util.UUID,
      guid: _root_.scala.Option[_root_.java.util.UUID] = None,
      limit: Long = 25L,
      offset: Long = 0L,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[Seq[io.apibuilder.api.v0.models.Token]]

    /**
     * Used to fetch the clear text token.
     */
    def getCleartextByGuid(
      guid: _root_.java.util.UUID,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.CleartextToken]

    /**
     * Create a new API token for this user
     */
    def post(
      tokenForm: io.apibuilder.api.v0.models.TokenForm,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Token]

    def deleteByGuid(
      guid: _root_.java.util.UUID,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[Unit]
  }

  trait Users {
    /**
     * Search for a specific user. You must specify at least 1 parameter - either a
     * guid, email or token - and will receive back either 0 or 1 users.
     * 
     * @param guid Find user with this guid. Exact match
     * @param email Find user with this email address. Case in-sensitive. Exact match
     * @param token Find the user with this API token. Exact match
     */
    def get(
      guid: _root_.scala.Option[_root_.java.util.UUID] = None,
      email: _root_.scala.Option[String] = None,
      token: _root_.scala.Option[String] = None,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[Seq[io.apibuilder.api.v0.models.User]]

    /**
     * Returns information about the user with this guid.
     */
    def getByGuid(
      guid: _root_.java.util.UUID,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.User]

    /**
     * Used to authenticate a user with an email address and password. Successful
     * authentication returns an instance of the user model. Failed authorizations of
     * any kind are returned as a generic error with code user_authorization_failed.
     */
    def postAuthenticate(
      email: String,
      password: String,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.User]

    /**
     * Create a new user.
     */
    def post(
      userForm: io.apibuilder.api.v0.models.UserForm,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.User]

    /**
     * Updates information about the user with the specified guid.
     */
    def putByGuid(
      guid: _root_.java.util.UUID,
      userUpdateForm: io.apibuilder.api.v0.models.UserUpdateForm,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.User]
  }

  trait Validations {
    def post(
      value: String,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Validation]
  }

  trait Versions {
    /**
     * Search all versions of this application. Results are always paginated.
     * 
     * @param orgKey The organization key for which to search versions
     * @param applicationKey The application key for which to search versions
     * @param limit The number of records to return
     * @param offset Used to paginate. First page of results is 0.
     */
    def getByApplicationKey(
      orgKey: String,
      applicationKey: String,
      limit: Long = 25L,
      offset: Long = 0L,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[Seq[io.apibuilder.api.v0.models.Version]]

    /**
     * Retrieve a specific version of an application.
     * 
     * @param version The version of tthis application to download, or the keyword latest to get the
     *        latest version
     */
    def getByApplicationKeyAndVersion(
      orgKey: String,
      applicationKey: String,
      version: String,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Version]

    /**
     * Create a new version for an application
     */
    def postByVersion(
      orgKey: String,
      version: String,
      versionForm: io.apibuilder.api.v0.models.VersionForm,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Version]

    /**
     * Upsert a version of an application
     */
    def putByApplicationKeyAndVersion(
      orgKey: String,
      applicationKey: String,
      version: String,
      versionForm: io.apibuilder.api.v0.models.VersionForm,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Version]

    /**
     * Deletes a specific version.
     */
    def deleteByApplicationKeyAndVersion(
      orgKey: String,
      applicationKey: String,
      version: String,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[Unit]
  }

  trait Watches {
    /**
     * Search attributes. Always paginated.
     * 
     * @param guid Find the watch with this guid.
     * @param userGuid Find attributes for this user.
     * @param organizationKey Find attributes for this organization.
     * @param applicationKey Find attributes for this application.
     * @param limit The number of records to return
     * @param offset Used to paginate. First page of results is 0.
     */
    def get(
      guid: _root_.scala.Option[_root_.java.util.UUID] = None,
      userGuid: _root_.scala.Option[_root_.java.util.UUID] = None,
      organizationKey: _root_.scala.Option[String] = None,
      applicationKey: _root_.scala.Option[String] = None,
      limit: Long = 25L,
      offset: Long = 0L,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[Seq[io.apibuilder.api.v0.models.Watch]]

    /**
     * Returns information about a specific watch.
     */
    def getByGuid(
      guid: _root_.java.util.UUID,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Watch]

    /**
     * Quick check if a user is watching a specific application.
     * 
     * @param userGuid The user for which we are checking. API returns false if the user guid is not
     *        provided
     */
    def getCheck(
      userGuid: _root_.scala.Option[_root_.java.util.UUID] = None,
      organizationKey: String,
      applicationKey: String,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[Boolean]

    /**
     * Create a new watch.
     */
    def post(
      watchForm: io.apibuilder.api.v0.models.WatchForm,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[io.apibuilder.api.v0.models.Watch]

    def deleteByGuid(
      guid: _root_.java.util.UUID,
      requestHeaders: Seq[(String, String)] = Nil
    ): scalaz.concurrent.Task[Unit]
  }

  package errors {

    import io.apibuilder.api.v0.models.json._
    import io.apibuilder.common.v0.models.json._
    import io.apibuilder.generator.v0.models.json._
    import io.apibuilder.spec.v0.models.json._

    final case class ErrorsResponse(
      response: org.http4s.Response,
      message: Option[String] = None
    ) extends Exception(message.getOrElse(response.status.code + ": " + response.body)){
      lazy val errors = _root_.io.apibuilder.api.v0.Client.parseJson[Seq[io.apibuilder.api.v0.models.Error]]("Seq[io.apibuilder.api.v0.models.Error]", response)
    }

    final case class UnitResponse(status: Int) extends Exception(s"HTTP $status")

    final case class FailedRequest(responseCode: Int, message: String, requestUri: Option[_root_.java.net.URI] = None, parent: Exception = null) extends _root_.java.lang.Exception(s"HTTP $responseCode: $message", parent)

  }
}