package io.apibuilder.http4s.test.server

import org.http4s.dsl._
import cats.effect._
import org.http4s.dsl.io._
import io.apibuilder.http4s.test.models.json._

private[server] object Matchers {

  implicit lazy val bigDecimalDateQueryParamDecoder: org.http4s.QueryParamDecoder[BigDecimal] =
    org.http4s.QueryParamDecoder.fromUnsafeCast[BigDecimal](p => BigDecimal(p.value))("BigDecimal")

  implicit lazy val instantQueryParamDecoder: org.http4s.QueryParamDecoder[java.time.Instant] =
    org.http4s.QueryParamDecoder.fromUnsafeCast[java.time.Instant](p => java.time.Instant.parse(p.value))("java.time.Instant")

  implicit lazy val localDateQueryParamDecoder: org.http4s.QueryParamDecoder[java.time.LocalDate] =
    org.http4s.QueryParamDecoder.fromUnsafeCast[java.time.LocalDate](p => java.time.LocalDate.parse(p.value))("java.time.LocalDate")

  implicit lazy val uuidQueryParamDecoder: org.http4s.QueryParamDecoder[java.util.UUID] =
    org.http4s.QueryParamDecoder.fromUnsafeCast[java.util.UUID](p => java.util.UUID.fromString(p.value))("java.util.UUID")


  object ApiVersion {
    val ApiVersionMajor = {
      import org.http4s.syntax.string._
      "X-Apidoc-Version-Major".ci
    }

    def apply(req: org.http4s.Message[cats.effect.IO]): Boolean = req.headers.get(ApiVersionMajor) match {
      case Some(v) if v.value == "0" => true
      case _ => false
    }
  }


}

trait ModelRoutes {
  import Matchers._

  implicit def circeJsonDecoder[A](implicit decoder: _root_.io.circe.Decoder[A]) = org.http4s.circe.jsonOf[cats.effect.IO, A]
  implicit def circeJsonEncoder[A](implicit encoder: _root_.io.circe.Encoder[A]) = org.http4s.circe.jsonEncoderOf[cats.effect.IO, A]

  sealed trait PostResponse

  object PostResponse {
    case class HTTP200(headers: Seq[org.http4s.Header] = Nil) extends PostResponse
  }

  def post(
    _req: org.http4s.Request[cats.effect.IO],
    id: String,
    model: io.apibuilder.http4s.test.models.Model,
    enum: io.apibuilder.http4s.test.models.Enum,
    opt: _root_.scala.Option[Int],
    list: Seq[String]
  ): cats.effect.IO[PostResponse]

  def apiVersionMatch(req: org.http4s.Message[cats.effect.IO]): Boolean = ApiVersion(req)

  def service() = org.http4s.HttpService[cats.effect.IO] {
    case _req @ POST -> Root / "test" if apiVersionMatch(_req) =>
      _req.decode[_root_.org.http4s.UrlForm] {
        req =>
          val responseOpt = for {
            id <- req.getFirst("id")
            model <- req.getFirst("model").flatMap(f => _root_.io.circe.parser.decode[io.apibuilder.http4s.test.models.Model](f).toOption)
            enum <- req.getFirst("enum").flatMap(f => _root_.io.circe.parser.decode[io.apibuilder.http4s.test.models.Enum](f).toOption)
            opt <- Some(req.getFirst("opt").flatMap(f => _root_.io.circe.parser.decode[Int](f).toOption))
            list <- Some(req.get("list"))
          } yield {
              post(_req, id, model, enum, opt, list).flatMap {
                case PostResponse.HTTP200(headers) => Ok().putHeaders(headers: _*)
              }
            }
          responseOpt.getOrElse(BadRequest())
      }
  }
}