/**
 * Generated by API Builder - https://www.apibuilder.io
 * Service version: 0.0.1-dev
 */
package io.gregor.time.types.v0.models {

  sealed trait DateTimeUnion extends _root_.scala.Product with _root_.scala.Serializable {
    def dateTimeUnionType: DateTimeUnionType

  }

  /**
   * Defines the valid dateTimeUnionType values for the type DateTimeUnion
   */
  sealed trait DateTimeUnionType extends _root_.scala.Product with _root_.scala.Serializable

  object DateTimeUnionType {

    case object DateTimeIso8601 extends DateTimeUnionType { override def toString = "date-time-iso8601" }
    case object DateIso8601 extends DateTimeUnionType { override def toString = "date-iso8601" }

    final case class UNDEFINED(override val toString: String) extends DateTimeUnionType

    val all: scala.List[DateTimeUnionType] = scala.List(DateTimeIso8601, DateIso8601)

    private[this] val byName: Map[String, DateTimeUnionType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): DateTimeUnionType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[DateTimeUnionType] = byName.get(value.toLowerCase)

  }
  final case class DateTimeModel(
    dateTime: _root_.java.time.Instant,
    date: _root_.java.time.LocalDate
  )

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union DateTimeUnion, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */

  final case class DateTimeUnionUndefinedType(
    description: String
  ) extends DateTimeUnion {
    override val dateTimeUnionType: DateTimeUnionType = DateTimeUnionType.UNDEFINED(description)
  }

  /**
   * Wrapper class to support the union types containing the
   * datatype[date-time-iso8601]
   */

  final case class DateTimeUnionInstant(
    value: _root_.java.time.Instant
  ) extends DateTimeUnion

  /**
   * Wrapper class to support the union types containing the datatype[date-iso8601]
   */

  final case class DateTimeUnionLocalDate(
    value: _root_.java.time.LocalDate
  ) extends DateTimeUnion

}

package io.gregor.time.types.v0.models {

  package object json {
    import io.circe.Decoder._
    import io.circe.Encoder._
    import scala.language.implicitConversions // See below - Make Scala 2.11 Either monadic
    import scala.util.Try
    import io.circe.{Json, JsonObject, Encoder, Decoder, DecodingFailure}
    import io.circe.syntax._
    import io.gregor.time.types.v0.models.json._

    // Make Scala 2.11 Either monadic
    private[v0] implicit def eitherOps[A,B](e: Either[A,B]) = cats.implicits.catsSyntaxEither(e)

    private[v0] implicit val decodeUUID: Decoder[_root_.java.util.UUID] =
      Decoder.decodeString.emapTry(str => Try(_root_.java.util.UUID.fromString(str)))

    private[v0] implicit val encodeUUID: Encoder[_root_.java.util.UUID] =
      Encoder.encodeString.contramap[_root_.java.util.UUID](uuid => uuid.toString)

    private[v0] implicit val decodeInstant: Decoder[_root_.java.time.Instant] =
      Decoder.decodeString.emapTry(str => Try(_root_.java.time.OffsetDateTime.parse(str).toInstant))

    private[v0] implicit val encodeInstant: Encoder[_root_.java.time.Instant] =
      Encoder.encodeString.contramap[_root_.java.time.Instant](_.toString)

    private[v0] implicit val decodeLocalDate: Decoder[_root_.java.time.LocalDate] =
      Decoder.decodeString.emapTry(str => Try(_root_.java.time.LocalDate.parse(str)))

    private[v0] implicit val encodeLocalDate: Encoder[_root_.java.time.LocalDate] =
      Encoder.encodeString.contramap[_root_.java.time.LocalDate](_.toString)

    implicit def decodeTimeTypesDateTimeModel: Decoder[DateTimeModel] = Decoder.instance { c =>
     for {
        dateTime <- c.downField("date-time").as[_root_.java.time.Instant]
        date <- c.downField("date").as[_root_.java.time.LocalDate]
      } yield {
        DateTimeModel(
          dateTime = dateTime,
          date = date
        )
      }
    }

    implicit def encodeTimeTypesDateTimeModel: Encoder[DateTimeModel] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("date-time" -> t.dateTime.asJson),
        Some("date" -> t.date.asJson)
      ).flatten)
    }

    implicit def decodeTimeTypesDateTimeUnionInstant: Decoder[DateTimeUnionInstant] = Decoder.instance { c =>
     for {
        value <- c.downField("value").as[_root_.java.time.Instant]
      } yield {
        DateTimeUnionInstant(
          value = value
        )
      }
    }

    implicit def encodeTimeTypesDateTimeUnionInstant: Encoder[DateTimeUnionInstant] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("value" -> t.value.asJson)
      ).flatten)
    }

    implicit def decodeTimeTypesDateTimeUnionLocalDate: Decoder[DateTimeUnionLocalDate] = Decoder.instance { c =>
     for {
        value <- c.downField("value").as[_root_.java.time.LocalDate]
      } yield {
        DateTimeUnionLocalDate(
          value = value
        )
      }
    }

    implicit def encodeTimeTypesDateTimeUnionLocalDate: Encoder[DateTimeUnionLocalDate] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("value" -> t.value.asJson)
      ).flatten)
    }

    implicit def decodeTimeTypesDateTimeUnion: Decoder[DateTimeUnion] = Decoder.instance { c =>
      c.get[Option[String]]("type") match {
        case Right(Some(s)) if s == "date-time-iso8601" => c.as[io.gregor.time.types.v0.models.DateTimeUnionInstant]
        case Right(Some(s)) if s == "date-iso8601" => c.as[io.gregor.time.types.v0.models.DateTimeUnionLocalDate]
        case Right(Some(s)) => Right(io.gregor.time.types.v0.models.DateTimeUnionUndefinedType(s))
        case _ => Left(DecodingFailure("Union[DateTimeUnion] requires a discriminator named 'type' - this field was not found in the Json", c.history))
      }
    }

    implicit def encodeTimeTypesDateTimeUnion: Encoder[DateTimeUnion] = Encoder.instance {
      case t: io.gregor.time.types.v0.models.DateTimeUnionInstant => t.asJson.mapObject(obj => ("type", Json.fromString("date-time-iso8601")) +: obj)
      case t: io.gregor.time.types.v0.models.DateTimeUnionLocalDate => t.asJson.mapObject(obj => ("type", Json.fromString("date-iso8601")) +: obj)
      case other => sys.error(s"The type[${other.getClass.getName}] has no JSON encoder")
    }
  }
}

package io.gregor.time.types.v0 {
import cats.effect._
import cats.implicits._
import io.circe.syntax._

  object Constants {

    val Namespace = "io.gregor.time.types.v0"
    val UserAgent = "apibuilder-play_2x_client-unknown"
    val Version = "0.0.1-dev"
    val VersionMajor = 0

  }

  class Client[F[_]: Sync](
    val baseUrl: org.http4s.Uri,
    auth: scala.Option[io.gregor.time.types.v0.Authorization] = None,
    defaultHeaders: Seq[(String, String)] = Nil,
    httpClient: org.http4s.client.Client[F]
  ) extends interfaces.Client[F] {
    import org.http4s.Response
    import io.gregor.time.types.v0.models.json._


    def dateTimeModels: DateTimeModels[F] = DateTimeModels

    object DateTimeModels extends DateTimeModels[F] {
      override def postByPathDateAndPathTime(
        pathDate: _root_.java.time.LocalDate,
        pathTime: _root_.java.time.Instant,
        queryDate: _root_.java.time.LocalDate,
        queryTime: _root_.java.time.Instant,
        dateTimeModel: io.gregor.time.types.v0.models.DateTimeModel,
        requestHeaders: Seq[(String, String)] = Nil
      ): F[io.gregor.time.types.v0.models.DateTimeModel] = {
        val urlPath = Seq("date_time_models", pathDate.toString, pathTime.toString)

        val (payload, formPayload) = (Some(dateTimeModel), None)

        val queryParameters = Seq(
          Some("query_date" -> queryDate.toString),
          Some("query_time" -> queryTime.toString)
        ).flatten

        _executeRequest[io.gregor.time.types.v0.models.DateTimeModel, io.gregor.time.types.v0.models.DateTimeModel]("POST", path = urlPath, body = payload, formBody = formPayload, queryParameters = queryParameters, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.gregor.time.types.v0.Client.parseJson[F, io.gregor.time.types.v0.models.DateTimeModel]("io.gregor.time.types.v0.models.DateTimeModel", r)
          case r => Sync[F].raiseError(new io.gregor.time.types.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200"))
        }
      }
    }

    private lazy val defaultApiHeaders = Seq(
      ("User-Agent", Constants.UserAgent),
      ("X-Apidoc-Version", Constants.Version),
      ("X-Apidoc-Version-Major", Constants.VersionMajor.toString)
    )

    def apiHeaders: Seq[(String, String)] = defaultApiHeaders

    def modifyRequest(request: org.http4s.Request[F]): org.http4s.Request[F] = request

    implicit def circeJsonEncoder[F[_]: Sync, A](implicit encoder: io.circe.Encoder[A]) = org.http4s.circe.jsonEncoderOf[F, A]

    def _executeRequest[T, U](
      method: String,
      path: Seq[String],
      queryParameters: Seq[(String, String)] = Nil,
      requestHeaders: Seq[(String, String)] = Nil,
      body: Option[T] = None,
      formBody : Option[org.http4s.UrlForm] = None
    )(handler: org.http4s.Response[F] => F[U]
    )(implicit encoder: io.circe.Encoder[T]): F[U] = {
      import org.http4s.QueryParamEncoder._

      val m = org.http4s.Method.fromString(method) match {
        case Right(m) => m
        case Left(e) => sys.error(e.toString)
      }

      val headers = org.http4s.Headers((
        apiHeaders ++
        defaultHeaders ++
        requestHeaders
      ).groupBy(_._1).map { case (k, l) => org.http4s.Header.Raw(org.typelevel.ci.CIString(k), l.last._2) }.toList)

      val queryMap = queryParameters.groupBy(_._1).map { case (k, v) => k -> v.map(_._2) }
      val uri = path.foldLeft(baseUrl){ case (uri, segment) => uri / segment }.setQueryParams(queryMap)

      val request = org.http4s.Request[F](method = m,
                                       uri = uri,
                                       headers = headers)

      val reqAndMaybeAuth = auth.fold(request) {
        case Authorization.Basic(username, passwordOpt) => {
          val userpass = s"$username:${passwordOpt.getOrElse("")}"
          val token = java.util.Base64.getEncoder.encodeToString(userpass.getBytes(java.nio.charset.StandardCharsets.ISO_8859_1))
          request.putHeaders(org.http4s.Header.Raw(org.typelevel.ci.CIString("Authorization"), s"Basic $token"))
        }
        case a => sys.error("Invalid authorization scheme[" + a.getClass + "]")
      }

      val reqAndMaybeAuthAndBody =
        if (formBody.nonEmpty) formBody.fold(reqAndMaybeAuth)(reqAndMaybeAuth.withEntity)
        else body.fold(reqAndMaybeAuth)(reqAndMaybeAuth.withEntity)

      httpClient.fetch(modifyRequest(reqAndMaybeAuthAndBody))(handler)
    }
  }

  object Client {
    import cats.effect._

    implicit def circeJsonDecoder[F[_]: Sync, A](implicit decoder: io.circe.Decoder[A]) = org.http4s.circe.jsonOf[F, A]

    def parseJson[F[_]: Sync, T](
      className: String,
      r: org.http4s.Response[F]
    )(implicit decoder: io.circe.Decoder[T]): F[T] = r.attemptAs[T].value.flatMap {
      case Right(value) => Sync[F].pure(value)
      case Left(error) => Sync[F].raiseError(new io.gregor.time.types.v0.errors.FailedRequest(r.status.code, s"Invalid json for class[" + className + "]", None, error))
    }
  }

  sealed trait Authorization extends _root_.scala.Product with _root_.scala.Serializable
  object Authorization {
    final case class Basic(username: String, password: Option[String] = None) extends Authorization
  }

  package interfaces {

    trait Client[F[_]] {
      def baseUrl: org.http4s.Uri
      def dateTimeModels: io.gregor.time.types.v0.DateTimeModels[F]
    }

  }

  trait DateTimeModels[F[_]] {
    def postByPathDateAndPathTime(
      pathDate: _root_.java.time.LocalDate,
      pathTime: _root_.java.time.Instant,
      queryDate: _root_.java.time.LocalDate,
      queryTime: _root_.java.time.Instant,
      dateTimeModel: io.gregor.time.types.v0.models.DateTimeModel,
      requestHeaders: Seq[(String, String)] = Nil
    ): F[io.gregor.time.types.v0.models.DateTimeModel]
  }

  package errors {

    final case class FailedRequest(responseCode: Int, message: String, requestUri: Option[_root_.java.net.URI] = None, parent: Exception = null) extends _root_.java.lang.Exception(s"HTTP $responseCode: $message", parent)

  }
}