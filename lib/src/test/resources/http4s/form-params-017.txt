package io.apibuilder.http4s.test.server

import org.http4s.dsl._

import io.apibuilder.http4s.test.models.json._

private[server] object Matchers {

  implicit lazy val bigDecimalDateQueryParamDecoder: org.http4s.QueryParamDecoder[BigDecimal] =
    org.http4s.QueryParamDecoder.fromUnsafeCast[BigDecimal](p => BigDecimal(p.value))("BigDecimal")

  implicit lazy val instantQueryParamDecoder: org.http4s.QueryParamDecoder[java.time.Instant] =
    org.http4s.QueryParamDecoder.fromUnsafeCast[java.time.Instant](p => java.time.Instant.parse(p.value))("java.time.Instant")

  implicit lazy val localDateQueryParamDecoder: org.http4s.QueryParamDecoder[java.time.LocalDate] =
    org.http4s.QueryParamDecoder.fromUnsafeCast[java.time.LocalDate](p => java.time.LocalDate.parse(p.value))("java.time.LocalDate")

  implicit lazy val uuidQueryParamDecoder: org.http4s.QueryParamDecoder[java.util.UUID] =
    org.http4s.QueryParamDecoder.fromUnsafeCast[java.util.UUID](p => java.util.UUID.fromString(p.value))("java.util.UUID")


  object ApiVersion {
    val ApiVersionMajor = {
      import org.http4s.syntax.string._
      "X-Apidoc-Version-Major".ci
    }

    def apply(req: org.http4s.Message): Boolean = req.headers.get(ApiVersionMajor) match {
      case Some(v) if v.value == "0" => true
      case _ => false
    }
  }


}

trait ModelRoutes {
  import Matchers._

  implicit def circeJsonDecoder[A](implicit decoder: _root_.io.circe.Decoder[A]) = org.http4s.circe.jsonOf[A]
  implicit def circeJsonEncoder[A](implicit encoder: _root_.io.circe.Encoder[A]) = org.http4s.circe.jsonEncoderOf[A]

  sealed trait PostResponse

  object PostResponse {
    case class HTTP200(headers: Seq[org.http4s.Header] = Nil) extends PostResponse
  }

  def post(
    _req: org.http4s.Request,
    id: String
  ): fs2.Task[PostResponse]

  def apiVersionMatch(req: org.http4s.Message): Boolean = ApiVersion(req)

  def service() = org.http4s.HttpService {
    case _req @ POST -> Root / "string" if apiVersionMatch(_req) =>
      _req.decode[_root_.org.http4s.UrlForm] {
        req =>
          val responseOpt = for {
            id <- req.getFirst("id")
          } yield {
              post(_req, id).flatMap {
                case PostResponse.HTTP200(headers) => Ok().putHeaders(headers: _*)
              }
            }
          responseOpt.getOrElse(BadRequest())
      }
  }
}