/**
 * Generated by API Builder - https://www.apibuilder.io
 * Service version: 0.0.1-dev
 */
package com.gilt.quality.v0.models {

  /**
   * @param adjournedAt Defaults to the time of the request
   */
  final case class AdjournForm(
    adjournedAt: _root_.scala.Option[_root_.org.joda.time.DateTime] = None
  )

  /**
   * Describe an agenda item for a meeting. Currently the only agenda items we have
   * are that a particular incident needs to be reviewed.
   *
   * @param id Internal unique identifier for this record.
   * @param meeting The meeting to which this agenda item belongs
   * @param incident Summary of the incident to review.
   * @param task What needs to be reviewed at this meeting for this incident.
   */
  final case class AgendaItem(
    id: Long,
    meeting: com.gilt.quality.v0.models.Meeting,
    incident: com.gilt.quality.v0.models.Incident,
    task: com.gilt.quality.v0.models.Task
  )

  final case class AgendaItemForm(
    meetingId: Long,
    incidentId: Long,
    task: com.gilt.quality.v0.models.Task
  )

  final case class AuthenticationForm(
    email: String
  )

  final case class EmailMessage(
    subject: String,
    body: String
  )

  /**
   * @param code Machine readable code for this specific error message
   * @param message Description of the error
   */
  final case class Error(
    code: String,
    message: String
  )

  /**
   * Stores metadata about external services that can be integrated with the quality
   * app
   */
  final case class ExternalService(
    id: Long,
    organization: com.gilt.quality.v0.models.Organization,
    name: com.gilt.quality.v0.models.ExternalServiceName,
    url: String,
    username: String
  )

  final case class ExternalServiceForm(
    name: com.gilt.quality.v0.models.ExternalServiceName,
    url: String,
    username: String,
    password: String
  )

  /**
   * Every n days (e.g. 30) we follow up to see if a given plan has been implemented.
   * This gives teams the ability to say: Yes, completed. Not yet. or No, won't do.
   * After 3 consecutive no replies, we assume not doing.
   *
   * @param key Unique token identifying this response
   */
  final case class Followup(
    key: String,
    plan: com.gilt.quality.v0.models.Plan,
    sentAt: _root_.org.joda.time.DateTime
  )

  /**
   * Every n days (e.g. 30) we follow up to see if a given plan has been implemented.
   * This gives teams the ability to say: Yes, completed. Not yet. or No, won't do.
   * After 3 consecutive no replies, we assume not doing.
   */
  final case class FollowupResponse(
    followup: com.gilt.quality.v0.models.Followup,
    response: com.gilt.quality.v0.models.Response,
    createdAt: _root_.org.joda.time.DateTime,
    createdBy: com.gilt.quality.v0.models.User
  )

  final case class Healthcheck(
    @deprecated("please use audience.label instead") status: String
  )

  /**
   * URLs to key icons used through the application
   *
   * @param smileyUrl URL for the smiley icon
   * @param frownyUrl URL for the frowny icon
   */
  final case class Icons(
    smileyUrl: String,
    frownyUrl: String
  )

  /**
   * A bug or error that affected public or internal users in a negative way
   *
   * @param id Internal unique identifier for this incident.
   * @param organization Organization to which this incident belongs
   * @param summary Summary of the incident.
   * @param description Full description of the incident
   * @param team Team responsible for resolution of this incident
   * @param tags Optional list of tags to apply to this incident
   */
  final case class Incident(
    id: Long,
    organization: com.gilt.quality.v0.models.Organization,
    summary: String,
    description: _root_.scala.Option[String] = None,
    @deprecated("to be removed in a future version") team: _root_.scala.Option[com.gilt.quality.v0.models.Team] = None,
    severity: com.gilt.quality.v0.models.Severity,
    @deprecated tags: _root_.scala.Option[Seq[String]] = None,
    plan: _root_.scala.Option[com.gilt.quality.v0.models.Plan] = None,
    createdAt: _root_.org.joda.time.DateTime
  )

  /**
   * @param teamKey Team responsible for resolution of this incident
   * @param summary Summary of the incident.
   * @param description Full description of the incident
   * @param tags Optional list of tags to apply to this incident
   */
  final case class IncidentForm(
    teamKey: _root_.scala.Option[String] = None,
    severity: com.gilt.quality.v0.models.Severity,
    summary: String,
    description: _root_.scala.Option[String] = None,
    tags: _root_.scala.Option[Seq[String]] = None
  )

  /**
   * Used to move an incident to another organization
   */
  final case class IncidentOrganizationChange(
    incidentId: Long,
    organizationKey: String
  )

  final case class IncidentSummary(
    id: Long,
    severity: com.gilt.quality.v0.models.Severity,
    summary: String
  )

  /**
   * Meetings happen on a regular schedule (e.g. thursdays from 11-12 EST). As
   * incidents are created, they are automatically assigned to the next meeting.
   * Incidents can then be reviewed from the context of a meeting, facilitating
   * online navigation. Incidents within a meeting can require one of two actions -
   * team assignment or plan review.
   *
   * @param id Internal unique identifier for this meeting.
   * @param organization Organization to which this meeting belongs
   * @param scheduledAt The date and time for which this meeting is scheduled.
   * @param adjournedAt The date and time at which this meeting was adjourned. This can be done
   *        explicitly by a person, or will automatically occur a few hours after the
   *        meeting's scheduled time.
   */
  final case class Meeting(
    id: Long,
    organization: com.gilt.quality.v0.models.Organization,
    scheduledAt: _root_.org.joda.time.DateTime,
    adjournedAt: _root_.scala.Option[_root_.org.joda.time.DateTime] = None
  )

  final case class MeetingForm(
    scheduledAt: _root_.org.joda.time.DateTime
  )

  /**
   * Used to enable pagination when walking through the issues in a particular
   * meeting. General idea is given a meeting id and an incident id, returns the
   * previous and next incident IDs, if any
   */
  final case class MeetingPager(
    meeting: com.gilt.quality.v0.models.Meeting,
    priorIncident: _root_.scala.Option[com.gilt.quality.v0.models.Incident] = None,
    nextIncident: _root_.scala.Option[com.gilt.quality.v0.models.Incident] = None
  )

  /**
   * Top level organization for which we are managing quality. Key entities like
   * teams and meetings are scoped to the organization.
   *
   * @param key Used as a unique key for this organization that is URL safe.
   * @param name The name of this organization.
   */
  final case class Organization(
    key: String,
    name: String
  )

  /**
   * @param key Defaults to a url friendy version of the name
   */
  final case class OrganizationForm(
    name: String,
    key: _root_.scala.Option[String] = None
  )

  /**
   * Details for how an incident will be resolved
   *
   * @param id Internal unique identifier for this incident.
   * @param body Full description of the incident
   * @param grade Grade given to this plan on a scale of 0 (bad) to 100 (good)
   */
  final case class Plan(
    id: Long,
    incidentId: Long,
    body: String,
    grade: _root_.scala.Option[Int] = None,
    createdAt: _root_.org.joda.time.DateTime
  )

  final case class PlanForm(
    incidentId: Long,
    body: String
  )

  /**
   * Statistics on each team's quality metrics, number of issues
   *
   * @param team Team for statistics.
   * @param totalGrades Number of graded plans given time span requested.
   * @param averageGrade Average grade for graded plans given time span requested.
   * @param totalOpenIncidents Number of incidents without a plan for this team.
   * @param totalIncidents Number of incidents reported in the time span requested.
   * @param totalPlans Number of plans attached to reported incidents in the time span requested.
   * @param plans Last plans to display grades for.
   */
  final case class Statistic(
    team: com.gilt.quality.v0.models.Team,
    totalGrades: Long,
    averageGrade: _root_.scala.Option[Int] = None,
    totalOpenIncidents: Long,
    totalIncidents: Long,
    totalPlans: Long,
    plans: _root_.scala.Option[Seq[com.gilt.quality.v0.models.Plan]] = None
  )

  /**
   * Represents a user that is currently subscribed to a publication
   *
   * @param id Internal unique identifier for this subscription record
   */
  final case class Subscription(
    id: Long,
    organization: com.gilt.quality.v0.models.Organization,
    user: com.gilt.quality.v0.models.User,
    publication: com.gilt.quality.v0.models.Publication
  )

  final case class SubscriptionForm(
    organizationKey: String,
    userGuid: _root_.java.util.UUID,
    publication: com.gilt.quality.v0.models.Publication
  )

  /**
   * A team is the main actor in the system. Teams have a unique key and own
   * incidents
   *
   * @param organization Organization to which this team belongs
   * @param key Unique identifier for this team
   * @param email Email address for members of this team. If provided, used to send updates on new
   *        incidents, meetings, etc.
   * @param icons Set of icons used on the site for this team (e.g. smiley and frowney faces).
   *        Teams inherit a default set of icons if not otherwise provided.
   */
  final case class Team(
    organization: com.gilt.quality.v0.models.Organization,
    key: String,
    email: _root_.scala.Option[String] = None,
    icons: com.gilt.quality.v0.models.Icons
  )

  /**
   * @param key Unique identifier for this team
   */
  final case class TeamForm(
    key: String,
    email: _root_.scala.Option[String] = None,
    smileyUrl: _root_.scala.Option[String] = None,
    frownyUrl: _root_.scala.Option[String] = None
  )

  final case class TeamMember(
    team: com.gilt.quality.v0.models.Team,
    user: com.gilt.quality.v0.models.User
  )

  /**
   * Statistics on each team's quality metrics, number of issues
   */
  final case class TeamMemberSummary(
    team: com.gilt.quality.v0.models.Team,
    numberMembers: Long
  )

  final case class UpdateTeamForm(
    email: _root_.scala.Option[String] = None,
    smileyUrl: _root_.scala.Option[String] = None,
    frownyUrl: _root_.scala.Option[String] = None
  )

  /**
   * A user is a top level person.
   *
   * @param guid Internal unique identifier for this user.
   */
  final case class User(
    guid: _root_.java.util.UUID,
    email: String
  )

  final case class UserForm(
    email: String
  )

  /**
   * An external service with which an organization can integrate.
   */
  sealed trait ExternalServiceName extends _root_.scala.Product with _root_.scala.Serializable

  object ExternalServiceName {

    /**
     * Atlassian JIRA. If integration is enabled, an incident can be created by listing
     * the jira ISSUE number directly.
     */
    case object Jira extends ExternalServiceName { override def toString = "jira" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends ExternalServiceName

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[ExternalServiceName] = scala.List(Jira)

    private[this]
    val byName: Map[String, ExternalServiceName] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ExternalServiceName = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ExternalServiceName] = byName.get(value.toLowerCase)

  }

  /**
   * A publication represents something that a user can subscribe to. An example
   * would be subscribing via email to the publication of all new incidents.
   */
  sealed trait Publication extends _root_.scala.Product with _root_.scala.Serializable

  object Publication {

    /**
     * Email notification whenever an incident is created.
     */
    case object IncidentsCreate extends Publication { override def toString = "incidents.create" }
    /**
     * Email notification whenever an incident is updated.
     */
    case object IncidentsUpdate extends Publication { override def toString = "incidents.update" }
    /**
     * Email notification whenever a plan is created.
     */
    case object PlansCreate extends Publication { override def toString = "plans.create" }
    /**
     * Email notification whenever a plan is updated.
     */
    case object PlansUpdate extends Publication { override def toString = "plans.update" }
    /**
     * Email notification whenever a meeting is adjourned.
     */
    case object MeetingsAdjourned extends Publication { override def toString = "meetings.adjourned" }
    /**
     * Email notification whenever a team that you are on is assigned to an incident.
     */
    case object IncidentsTeamUpdate extends Publication { override def toString = "incidents.team_update" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends Publication

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[Publication] = scala.List(IncidentsCreate, IncidentsUpdate, PlansCreate, PlansUpdate, MeetingsAdjourned, IncidentsTeamUpdate)

    private[this]
    val byName: Map[String, Publication] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): Publication = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[Publication] = byName.get(value.toLowerCase)

  }

  sealed trait Response extends _root_.scala.Product with _root_.scala.Serializable

  object Response {

    case object Complete extends Response { override def toString = "Complete" }
    case object NotYet extends Response { override def toString = "Not Yet" }
    case object WillNotComplete extends Response { override def toString = "Will not complete" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends Response

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[Response] = scala.List(Complete, NotYet, WillNotComplete)

    private[this]
    val byName: Map[String, Response] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): Response = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[Response] = byName.get(value.toLowerCase)

  }

  sealed trait Severity extends _root_.scala.Product with _root_.scala.Serializable

  object Severity {

    case object Low extends Severity { override def toString = "low" }
    case object High extends Severity { override def toString = "high" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends Severity

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[Severity] = scala.List(Low, High)

    private[this]
    val byName: Map[String, Severity] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): Severity = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[Severity] = byName.get(value.toLowerCase)

  }

  /**
   * Describes what needs to be reviewed about a specific incident
   */
  sealed trait Task extends _root_.scala.Product with _root_.scala.Serializable

  object Task {

    /**
     * Used in meetings to indicate that a team should be assigned to the incident or
     * that the group should review the team assignment to make sure it is correct.
     */
    case object ReviewTeam extends Task { override def toString = "review_team" }
    /**
     * Indicates that the incident plan should be reviewed and rated
     */
    case object ReviewPlan extends Task { override def toString = "review_plan" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends Task

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[Task] = scala.List(ReviewTeam, ReviewPlan)

    private[this]
    val byName: Map[String, Task] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): Task = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[Task] = byName.get(value.toLowerCase)

  }

}

package com.gilt.quality.v0.models {

  package object json {
    import play.api.libs.json.__
    import play.api.libs.json.JsString
    import play.api.libs.json.Writes
    import play.api.libs.functional.syntax._
    import com.gilt.quality.v0.models.json._

    private[v0] implicit val jsonReadsUUID = __.read[String].map { str =>
      _root_.java.util.UUID.fromString(str)
    }

    private[v0] implicit val jsonWritesUUID = new Writes[_root_.java.util.UUID] {
      def writes(x: _root_.java.util.UUID) = JsString(x.toString)
    }

    private[v0] implicit val jsonReadsJodaDateTime = __.read[String].map { str =>
      _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseDateTime(str)
    }

    private[v0] implicit val jsonWritesJodaDateTime = new Writes[_root_.org.joda.time.DateTime] {
      def writes(x: _root_.org.joda.time.DateTime) = {
        JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x))
      }
    }

    private[v0] implicit val jsonReadsJodaLocalDate = __.read[String].map { str =>
      _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseLocalDate(str)
    }

    private[v0] implicit val jsonWritesJodaLocalDate = new Writes[_root_.org.joda.time.LocalDate] {
      def writes(x: _root_.org.joda.time.LocalDate) = {
        JsString(_root_.org.joda.time.format.ISODateTimeFormat.date.print(x))
      }
    }

    implicit val jsonReadsQualityExternalServiceName = new play.api.libs.json.Reads[com.gilt.quality.v0.models.ExternalServiceName] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[com.gilt.quality.v0.models.ExternalServiceName] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(com.gilt.quality.v0.models.ExternalServiceName(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(com.gilt.quality.v0.models.ExternalServiceName(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesQualityExternalServiceName(obj: com.gilt.quality.v0.models.ExternalServiceName) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectExternalServiceName(obj: com.gilt.quality.v0.models.ExternalServiceName) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesQualityExternalServiceName: play.api.libs.json.Writes[ExternalServiceName] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.ExternalServiceName] {
        def writes(obj: com.gilt.quality.v0.models.ExternalServiceName) = {
          jsonWritesQualityExternalServiceName(obj)
        }
      }
    }

    implicit val jsonReadsQualityPublication = new play.api.libs.json.Reads[com.gilt.quality.v0.models.Publication] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[com.gilt.quality.v0.models.Publication] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(com.gilt.quality.v0.models.Publication(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(com.gilt.quality.v0.models.Publication(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesQualityPublication(obj: com.gilt.quality.v0.models.Publication) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectPublication(obj: com.gilt.quality.v0.models.Publication) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesQualityPublication: play.api.libs.json.Writes[Publication] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.Publication] {
        def writes(obj: com.gilt.quality.v0.models.Publication) = {
          jsonWritesQualityPublication(obj)
        }
      }
    }

    implicit val jsonReadsQualityResponse = new play.api.libs.json.Reads[com.gilt.quality.v0.models.Response] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[com.gilt.quality.v0.models.Response] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(com.gilt.quality.v0.models.Response(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(com.gilt.quality.v0.models.Response(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesQualityResponse(obj: com.gilt.quality.v0.models.Response) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectResponse(obj: com.gilt.quality.v0.models.Response) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesQualityResponse: play.api.libs.json.Writes[Response] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.Response] {
        def writes(obj: com.gilt.quality.v0.models.Response) = {
          jsonWritesQualityResponse(obj)
        }
      }
    }

    implicit val jsonReadsQualitySeverity = new play.api.libs.json.Reads[com.gilt.quality.v0.models.Severity] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[com.gilt.quality.v0.models.Severity] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(com.gilt.quality.v0.models.Severity(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(com.gilt.quality.v0.models.Severity(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesQualitySeverity(obj: com.gilt.quality.v0.models.Severity) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectSeverity(obj: com.gilt.quality.v0.models.Severity) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesQualitySeverity: play.api.libs.json.Writes[Severity] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.Severity] {
        def writes(obj: com.gilt.quality.v0.models.Severity) = {
          jsonWritesQualitySeverity(obj)
        }
      }
    }

    implicit val jsonReadsQualityTask = new play.api.libs.json.Reads[com.gilt.quality.v0.models.Task] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[com.gilt.quality.v0.models.Task] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(com.gilt.quality.v0.models.Task(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(com.gilt.quality.v0.models.Task(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesQualityTask(obj: com.gilt.quality.v0.models.Task) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectTask(obj: com.gilt.quality.v0.models.Task) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesQualityTask: play.api.libs.json.Writes[Task] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.Task] {
        def writes(obj: com.gilt.quality.v0.models.Task) = {
          jsonWritesQualityTask(obj)
        }
      }
    }

    implicit def jsonReadsQualityAdjournForm: play.api.libs.json.Reads[AdjournForm] = {
      (__ \ "adjourned_at").readNullable[_root_.org.joda.time.DateTime].map { x => new AdjournForm(adjournedAt = x) }
    }

    def jsObjectAdjournForm(obj: com.gilt.quality.v0.models.AdjournForm): play.api.libs.json.JsObject = {
      (obj.adjournedAt match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("adjourned_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x)))
      })
    }

    implicit def jsonWritesQualityAdjournForm: play.api.libs.json.Writes[AdjournForm] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.AdjournForm] {
        def writes(obj: com.gilt.quality.v0.models.AdjournForm) = {
          jsObjectAdjournForm(obj)
        }
      }
    }

    implicit def jsonReadsQualityAgendaItem: play.api.libs.json.Reads[AgendaItem] = {
      for {
        id <- (__ \ "id").read[Long]
        meeting <- (__ \ "meeting").read[com.gilt.quality.v0.models.Meeting]
        incident <- (__ \ "incident").read[com.gilt.quality.v0.models.Incident]
        task <- (__ \ "task").read[com.gilt.quality.v0.models.Task]
      } yield AgendaItem(id, meeting, incident, task)
    }

    def jsObjectAgendaItem(obj: com.gilt.quality.v0.models.AgendaItem): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsNumber(obj.id),
        "meeting" -> jsObjectMeeting(obj.meeting),
        "incident" -> jsObjectIncident(obj.incident),
        "task" -> play.api.libs.json.JsString(obj.task.toString)
      )
    }

    implicit def jsonWritesQualityAgendaItem: play.api.libs.json.Writes[AgendaItem] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.AgendaItem] {
        def writes(obj: com.gilt.quality.v0.models.AgendaItem) = {
          jsObjectAgendaItem(obj)
        }
      }
    }

    implicit def jsonReadsQualityAgendaItemForm: play.api.libs.json.Reads[AgendaItemForm] = {
      for {
        meetingId <- (__ \ "meeting_id").read[Long]
        incidentId <- (__ \ "incident_id").read[Long]
        task <- (__ \ "task").read[com.gilt.quality.v0.models.Task]
      } yield AgendaItemForm(meetingId, incidentId, task)
    }

    def jsObjectAgendaItemForm(obj: com.gilt.quality.v0.models.AgendaItemForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "meeting_id" -> play.api.libs.json.JsNumber(obj.meetingId),
        "incident_id" -> play.api.libs.json.JsNumber(obj.incidentId),
        "task" -> play.api.libs.json.JsString(obj.task.toString)
      )
    }

    implicit def jsonWritesQualityAgendaItemForm: play.api.libs.json.Writes[AgendaItemForm] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.AgendaItemForm] {
        def writes(obj: com.gilt.quality.v0.models.AgendaItemForm) = {
          jsObjectAgendaItemForm(obj)
        }
      }
    }

    implicit def jsonReadsQualityAuthenticationForm: play.api.libs.json.Reads[AuthenticationForm] = {
      (__ \ "email").read[String].map { x => new AuthenticationForm(email = x) }
    }

    def jsObjectAuthenticationForm(obj: com.gilt.quality.v0.models.AuthenticationForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "email" -> play.api.libs.json.JsString(obj.email)
      )
    }

    implicit def jsonWritesQualityAuthenticationForm: play.api.libs.json.Writes[AuthenticationForm] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.AuthenticationForm] {
        def writes(obj: com.gilt.quality.v0.models.AuthenticationForm) = {
          jsObjectAuthenticationForm(obj)
        }
      }
    }

    implicit def jsonReadsQualityEmailMessage: play.api.libs.json.Reads[EmailMessage] = {
      for {
        subject <- (__ \ "subject").read[String]
        body <- (__ \ "body").read[String]
      } yield EmailMessage(subject, body)
    }

    def jsObjectEmailMessage(obj: com.gilt.quality.v0.models.EmailMessage): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "subject" -> play.api.libs.json.JsString(obj.subject),
        "body" -> play.api.libs.json.JsString(obj.body)
      )
    }

    implicit def jsonWritesQualityEmailMessage: play.api.libs.json.Writes[EmailMessage] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.EmailMessage] {
        def writes(obj: com.gilt.quality.v0.models.EmailMessage) = {
          jsObjectEmailMessage(obj)
        }
      }
    }

    implicit def jsonReadsQualityError: play.api.libs.json.Reads[Error] = {
      for {
        code <- (__ \ "code").read[String]
        message <- (__ \ "message").read[String]
      } yield Error(code, message)
    }

    def jsObjectError(obj: com.gilt.quality.v0.models.Error): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code),
        "message" -> play.api.libs.json.JsString(obj.message)
      )
    }

    implicit def jsonWritesQualityError: play.api.libs.json.Writes[Error] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.Error] {
        def writes(obj: com.gilt.quality.v0.models.Error) = {
          jsObjectError(obj)
        }
      }
    }

    implicit def jsonReadsQualityExternalService: play.api.libs.json.Reads[ExternalService] = {
      for {
        id <- (__ \ "id").read[Long]
        organization <- (__ \ "organization").read[com.gilt.quality.v0.models.Organization]
        name <- (__ \ "name").read[com.gilt.quality.v0.models.ExternalServiceName]
        url <- (__ \ "url").read[String]
        username <- (__ \ "username").read[String]
      } yield ExternalService(id, organization, name, url, username)
    }

    def jsObjectExternalService(obj: com.gilt.quality.v0.models.ExternalService): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsNumber(obj.id),
        "organization" -> jsObjectOrganization(obj.organization),
        "name" -> play.api.libs.json.JsString(obj.name.toString),
        "url" -> play.api.libs.json.JsString(obj.url),
        "username" -> play.api.libs.json.JsString(obj.username)
      )
    }

    implicit def jsonWritesQualityExternalService: play.api.libs.json.Writes[ExternalService] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.ExternalService] {
        def writes(obj: com.gilt.quality.v0.models.ExternalService) = {
          jsObjectExternalService(obj)
        }
      }
    }

    implicit def jsonReadsQualityExternalServiceForm: play.api.libs.json.Reads[ExternalServiceForm] = {
      for {
        name <- (__ \ "name").read[com.gilt.quality.v0.models.ExternalServiceName]
        url <- (__ \ "url").read[String]
        username <- (__ \ "username").read[String]
        password <- (__ \ "password").read[String]
      } yield ExternalServiceForm(name, url, username, password)
    }

    def jsObjectExternalServiceForm(obj: com.gilt.quality.v0.models.ExternalServiceForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name.toString),
        "url" -> play.api.libs.json.JsString(obj.url),
        "username" -> play.api.libs.json.JsString(obj.username),
        "password" -> play.api.libs.json.JsString(obj.password)
      )
    }

    implicit def jsonWritesQualityExternalServiceForm: play.api.libs.json.Writes[ExternalServiceForm] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.ExternalServiceForm] {
        def writes(obj: com.gilt.quality.v0.models.ExternalServiceForm) = {
          jsObjectExternalServiceForm(obj)
        }
      }
    }

    implicit def jsonReadsQualityFollowup: play.api.libs.json.Reads[Followup] = {
      for {
        key <- (__ \ "key").read[String]
        plan <- (__ \ "plan").read[com.gilt.quality.v0.models.Plan]
        sentAt <- (__ \ "sent_at").read[_root_.org.joda.time.DateTime]
      } yield Followup(key, plan, sentAt)
    }

    def jsObjectFollowup(obj: com.gilt.quality.v0.models.Followup): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key),
        "plan" -> jsObjectPlan(obj.plan),
        "sent_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.sentAt))
      )
    }

    implicit def jsonWritesQualityFollowup: play.api.libs.json.Writes[Followup] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.Followup] {
        def writes(obj: com.gilt.quality.v0.models.Followup) = {
          jsObjectFollowup(obj)
        }
      }
    }

    implicit def jsonReadsQualityFollowupResponse: play.api.libs.json.Reads[FollowupResponse] = {
      for {
        followup <- (__ \ "followup").read[com.gilt.quality.v0.models.Followup]
        response <- (__ \ "response").read[com.gilt.quality.v0.models.Response]
        createdAt <- (__ \ "created_at").read[_root_.org.joda.time.DateTime]
        createdBy <- (__ \ "created_by").read[com.gilt.quality.v0.models.User]
      } yield FollowupResponse(followup, response, createdAt, createdBy)
    }

    def jsObjectFollowupResponse(obj: com.gilt.quality.v0.models.FollowupResponse): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "followup" -> jsObjectFollowup(obj.followup),
        "response" -> play.api.libs.json.JsString(obj.response.toString),
        "created_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.createdAt)),
        "created_by" -> jsObjectUser(obj.createdBy)
      )
    }

    implicit def jsonWritesQualityFollowupResponse: play.api.libs.json.Writes[FollowupResponse] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.FollowupResponse] {
        def writes(obj: com.gilt.quality.v0.models.FollowupResponse) = {
          jsObjectFollowupResponse(obj)
        }
      }
    }

    implicit def jsonReadsQualityHealthcheck: play.api.libs.json.Reads[Healthcheck] = {
      (__ \ "status").read[String].map { x => new Healthcheck(status = x) }
    }

    def jsObjectHealthcheck(obj: com.gilt.quality.v0.models.Healthcheck): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "status" -> play.api.libs.json.JsString(obj.status)
      )
    }

    implicit def jsonWritesQualityHealthcheck: play.api.libs.json.Writes[Healthcheck] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.Healthcheck] {
        def writes(obj: com.gilt.quality.v0.models.Healthcheck) = {
          jsObjectHealthcheck(obj)
        }
      }
    }

    implicit def jsonReadsQualityIcons: play.api.libs.json.Reads[Icons] = {
      for {
        smileyUrl <- (__ \ "smiley_url").read[String]
        frownyUrl <- (__ \ "frowny_url").read[String]
      } yield Icons(smileyUrl, frownyUrl)
    }

    def jsObjectIcons(obj: com.gilt.quality.v0.models.Icons): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "smiley_url" -> play.api.libs.json.JsString(obj.smileyUrl),
        "frowny_url" -> play.api.libs.json.JsString(obj.frownyUrl)
      )
    }

    implicit def jsonWritesQualityIcons: play.api.libs.json.Writes[Icons] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.Icons] {
        def writes(obj: com.gilt.quality.v0.models.Icons) = {
          jsObjectIcons(obj)
        }
      }
    }

    implicit def jsonReadsQualityIncident: play.api.libs.json.Reads[Incident] = {
      for {
        id <- (__ \ "id").read[Long]
        organization <- (__ \ "organization").read[com.gilt.quality.v0.models.Organization]
        summary <- (__ \ "summary").read[String]
        description <- (__ \ "description").readNullable[String]
        team <- (__ \ "team").readNullable[com.gilt.quality.v0.models.Team]
        severity <- (__ \ "severity").read[com.gilt.quality.v0.models.Severity]
        tags <- (__ \ "tags").readNullable[Seq[String]]
        plan <- (__ \ "plan").readNullable[com.gilt.quality.v0.models.Plan]
        createdAt <- (__ \ "created_at").read[_root_.org.joda.time.DateTime]
      } yield Incident(id, organization, summary, description, team, severity, tags, plan, createdAt)
    }

    def jsObjectIncident(obj: com.gilt.quality.v0.models.Incident): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsNumber(obj.id),
        "organization" -> jsObjectOrganization(obj.organization),
        "summary" -> play.api.libs.json.JsString(obj.summary),
        "severity" -> play.api.libs.json.JsString(obj.severity.toString),
        "created_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.createdAt))
      ) ++ (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.team match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("team" -> jsObjectTeam(x))
      }) ++
      (obj.tags match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("tags" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.plan match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("plan" -> jsObjectPlan(x))
      })
    }

    implicit def jsonWritesQualityIncident: play.api.libs.json.Writes[Incident] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.Incident] {
        def writes(obj: com.gilt.quality.v0.models.Incident) = {
          jsObjectIncident(obj)
        }
      }
    }

    implicit def jsonReadsQualityIncidentForm: play.api.libs.json.Reads[IncidentForm] = {
      for {
        teamKey <- (__ \ "team_key").readNullable[String]
        severity <- (__ \ "severity").read[com.gilt.quality.v0.models.Severity]
        summary <- (__ \ "summary").read[String]
        description <- (__ \ "description").readNullable[String]
        tags <- (__ \ "tags").readNullable[Seq[String]]
      } yield IncidentForm(teamKey, severity, summary, description, tags)
    }

    def jsObjectIncidentForm(obj: com.gilt.quality.v0.models.IncidentForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "severity" -> play.api.libs.json.JsString(obj.severity.toString),
        "summary" -> play.api.libs.json.JsString(obj.summary)
      ) ++ (obj.teamKey match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("team_key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.tags match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("tags" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesQualityIncidentForm: play.api.libs.json.Writes[IncidentForm] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.IncidentForm] {
        def writes(obj: com.gilt.quality.v0.models.IncidentForm) = {
          jsObjectIncidentForm(obj)
        }
      }
    }

    implicit def jsonReadsQualityIncidentOrganizationChange: play.api.libs.json.Reads[IncidentOrganizationChange] = {
      for {
        incidentId <- (__ \ "incident_id").read[Long]
        organizationKey <- (__ \ "organization_key").read[String]
      } yield IncidentOrganizationChange(incidentId, organizationKey)
    }

    def jsObjectIncidentOrganizationChange(obj: com.gilt.quality.v0.models.IncidentOrganizationChange): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "incident_id" -> play.api.libs.json.JsNumber(obj.incidentId),
        "organization_key" -> play.api.libs.json.JsString(obj.organizationKey)
      )
    }

    implicit def jsonWritesQualityIncidentOrganizationChange: play.api.libs.json.Writes[IncidentOrganizationChange] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.IncidentOrganizationChange] {
        def writes(obj: com.gilt.quality.v0.models.IncidentOrganizationChange) = {
          jsObjectIncidentOrganizationChange(obj)
        }
      }
    }

    implicit def jsonReadsQualityIncidentSummary: play.api.libs.json.Reads[IncidentSummary] = {
      for {
        id <- (__ \ "id").read[Long]
        severity <- (__ \ "severity").read[com.gilt.quality.v0.models.Severity]
        summary <- (__ \ "summary").read[String]
      } yield IncidentSummary(id, severity, summary)
    }

    def jsObjectIncidentSummary(obj: com.gilt.quality.v0.models.IncidentSummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsNumber(obj.id),
        "severity" -> play.api.libs.json.JsString(obj.severity.toString),
        "summary" -> play.api.libs.json.JsString(obj.summary)
      )
    }

    implicit def jsonWritesQualityIncidentSummary: play.api.libs.json.Writes[IncidentSummary] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.IncidentSummary] {
        def writes(obj: com.gilt.quality.v0.models.IncidentSummary) = {
          jsObjectIncidentSummary(obj)
        }
      }
    }

    implicit def jsonReadsQualityMeeting: play.api.libs.json.Reads[Meeting] = {
      for {
        id <- (__ \ "id").read[Long]
        organization <- (__ \ "organization").read[com.gilt.quality.v0.models.Organization]
        scheduledAt <- (__ \ "scheduled_at").read[_root_.org.joda.time.DateTime]
        adjournedAt <- (__ \ "adjourned_at").readNullable[_root_.org.joda.time.DateTime]
      } yield Meeting(id, organization, scheduledAt, adjournedAt)
    }

    def jsObjectMeeting(obj: com.gilt.quality.v0.models.Meeting): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsNumber(obj.id),
        "organization" -> jsObjectOrganization(obj.organization),
        "scheduled_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.scheduledAt))
      ) ++ (obj.adjournedAt match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("adjourned_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x)))
      })
    }

    implicit def jsonWritesQualityMeeting: play.api.libs.json.Writes[Meeting] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.Meeting] {
        def writes(obj: com.gilt.quality.v0.models.Meeting) = {
          jsObjectMeeting(obj)
        }
      }
    }

    implicit def jsonReadsQualityMeetingForm: play.api.libs.json.Reads[MeetingForm] = {
      (__ \ "scheduled_at").read[_root_.org.joda.time.DateTime].map { x => new MeetingForm(scheduledAt = x) }
    }

    def jsObjectMeetingForm(obj: com.gilt.quality.v0.models.MeetingForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "scheduled_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.scheduledAt))
      )
    }

    implicit def jsonWritesQualityMeetingForm: play.api.libs.json.Writes[MeetingForm] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.MeetingForm] {
        def writes(obj: com.gilt.quality.v0.models.MeetingForm) = {
          jsObjectMeetingForm(obj)
        }
      }
    }

    implicit def jsonReadsQualityMeetingPager: play.api.libs.json.Reads[MeetingPager] = {
      for {
        meeting <- (__ \ "meeting").read[com.gilt.quality.v0.models.Meeting]
        priorIncident <- (__ \ "prior_incident").readNullable[com.gilt.quality.v0.models.Incident]
        nextIncident <- (__ \ "next_incident").readNullable[com.gilt.quality.v0.models.Incident]
      } yield MeetingPager(meeting, priorIncident, nextIncident)
    }

    def jsObjectMeetingPager(obj: com.gilt.quality.v0.models.MeetingPager): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "meeting" -> jsObjectMeeting(obj.meeting)
      ) ++ (obj.priorIncident match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("prior_incident" -> jsObjectIncident(x))
      }) ++
      (obj.nextIncident match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("next_incident" -> jsObjectIncident(x))
      })
    }

    implicit def jsonWritesQualityMeetingPager: play.api.libs.json.Writes[MeetingPager] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.MeetingPager] {
        def writes(obj: com.gilt.quality.v0.models.MeetingPager) = {
          jsObjectMeetingPager(obj)
        }
      }
    }

    implicit def jsonReadsQualityOrganization: play.api.libs.json.Reads[Organization] = {
      for {
        key <- (__ \ "key").read[String]
        name <- (__ \ "name").read[String]
      } yield Organization(key, name)
    }

    def jsObjectOrganization(obj: com.gilt.quality.v0.models.Organization): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key),
        "name" -> play.api.libs.json.JsString(obj.name)
      )
    }

    implicit def jsonWritesQualityOrganization: play.api.libs.json.Writes[Organization] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.Organization] {
        def writes(obj: com.gilt.quality.v0.models.Organization) = {
          jsObjectOrganization(obj)
        }
      }
    }

    implicit def jsonReadsQualityOrganizationForm: play.api.libs.json.Reads[OrganizationForm] = {
      for {
        name <- (__ \ "name").read[String]
        key <- (__ \ "key").readNullable[String]
      } yield OrganizationForm(name, key)
    }

    def jsObjectOrganizationForm(obj: com.gilt.quality.v0.models.OrganizationForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name)
      ) ++ (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesQualityOrganizationForm: play.api.libs.json.Writes[OrganizationForm] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.OrganizationForm] {
        def writes(obj: com.gilt.quality.v0.models.OrganizationForm) = {
          jsObjectOrganizationForm(obj)
        }
      }
    }

    implicit def jsonReadsQualityPlan: play.api.libs.json.Reads[Plan] = {
      for {
        id <- (__ \ "id").read[Long]
        incidentId <- (__ \ "incident_id").read[Long]
        body <- (__ \ "body").read[String]
        grade <- (__ \ "grade").readNullable[Int]
        createdAt <- (__ \ "created_at").read[_root_.org.joda.time.DateTime]
      } yield Plan(id, incidentId, body, grade, createdAt)
    }

    def jsObjectPlan(obj: com.gilt.quality.v0.models.Plan): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsNumber(obj.id),
        "incident_id" -> play.api.libs.json.JsNumber(obj.incidentId),
        "body" -> play.api.libs.json.JsString(obj.body),
        "created_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.createdAt))
      ) ++ (obj.grade match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("grade" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonWritesQualityPlan: play.api.libs.json.Writes[Plan] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.Plan] {
        def writes(obj: com.gilt.quality.v0.models.Plan) = {
          jsObjectPlan(obj)
        }
      }
    }

    implicit def jsonReadsQualityPlanForm: play.api.libs.json.Reads[PlanForm] = {
      for {
        incidentId <- (__ \ "incident_id").read[Long]
        body <- (__ \ "body").read[String]
      } yield PlanForm(incidentId, body)
    }

    def jsObjectPlanForm(obj: com.gilt.quality.v0.models.PlanForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "incident_id" -> play.api.libs.json.JsNumber(obj.incidentId),
        "body" -> play.api.libs.json.JsString(obj.body)
      )
    }

    implicit def jsonWritesQualityPlanForm: play.api.libs.json.Writes[PlanForm] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.PlanForm] {
        def writes(obj: com.gilt.quality.v0.models.PlanForm) = {
          jsObjectPlanForm(obj)
        }
      }
    }

    implicit def jsonReadsQualityStatistic: play.api.libs.json.Reads[Statistic] = {
      for {
        team <- (__ \ "team").read[com.gilt.quality.v0.models.Team]
        totalGrades <- (__ \ "total_grades").read[Long]
        averageGrade <- (__ \ "average_grade").readNullable[Int]
        totalOpenIncidents <- (__ \ "total_open_incidents").read[Long]
        totalIncidents <- (__ \ "total_incidents").read[Long]
        totalPlans <- (__ \ "total_plans").read[Long]
        plans <- (__ \ "plans").readNullable[Seq[com.gilt.quality.v0.models.Plan]]
      } yield Statistic(team, totalGrades, averageGrade, totalOpenIncidents, totalIncidents, totalPlans, plans)
    }

    def jsObjectStatistic(obj: com.gilt.quality.v0.models.Statistic): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "team" -> jsObjectTeam(obj.team),
        "total_grades" -> play.api.libs.json.JsNumber(obj.totalGrades),
        "total_open_incidents" -> play.api.libs.json.JsNumber(obj.totalOpenIncidents),
        "total_incidents" -> play.api.libs.json.JsNumber(obj.totalIncidents),
        "total_plans" -> play.api.libs.json.JsNumber(obj.totalPlans)
      ) ++ (obj.averageGrade match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("average_grade" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.plans match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("plans" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesQualityStatistic: play.api.libs.json.Writes[Statistic] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.Statistic] {
        def writes(obj: com.gilt.quality.v0.models.Statistic) = {
          jsObjectStatistic(obj)
        }
      }
    }

    implicit def jsonReadsQualitySubscription: play.api.libs.json.Reads[Subscription] = {
      for {
        id <- (__ \ "id").read[Long]
        organization <- (__ \ "organization").read[com.gilt.quality.v0.models.Organization]
        user <- (__ \ "user").read[com.gilt.quality.v0.models.User]
        publication <- (__ \ "publication").read[com.gilt.quality.v0.models.Publication]
      } yield Subscription(id, organization, user, publication)
    }

    def jsObjectSubscription(obj: com.gilt.quality.v0.models.Subscription): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsNumber(obj.id),
        "organization" -> jsObjectOrganization(obj.organization),
        "user" -> jsObjectUser(obj.user),
        "publication" -> play.api.libs.json.JsString(obj.publication.toString)
      )
    }

    implicit def jsonWritesQualitySubscription: play.api.libs.json.Writes[Subscription] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.Subscription] {
        def writes(obj: com.gilt.quality.v0.models.Subscription) = {
          jsObjectSubscription(obj)
        }
      }
    }

    implicit def jsonReadsQualitySubscriptionForm: play.api.libs.json.Reads[SubscriptionForm] = {
      for {
        organizationKey <- (__ \ "organization_key").read[String]
        userGuid <- (__ \ "user_guid").read[_root_.java.util.UUID]
        publication <- (__ \ "publication").read[com.gilt.quality.v0.models.Publication]
      } yield SubscriptionForm(organizationKey, userGuid, publication)
    }

    def jsObjectSubscriptionForm(obj: com.gilt.quality.v0.models.SubscriptionForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "organization_key" -> play.api.libs.json.JsString(obj.organizationKey),
        "user_guid" -> play.api.libs.json.JsString(obj.userGuid.toString),
        "publication" -> play.api.libs.json.JsString(obj.publication.toString)
      )
    }

    implicit def jsonWritesQualitySubscriptionForm: play.api.libs.json.Writes[SubscriptionForm] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.SubscriptionForm] {
        def writes(obj: com.gilt.quality.v0.models.SubscriptionForm) = {
          jsObjectSubscriptionForm(obj)
        }
      }
    }

    implicit def jsonReadsQualityTeam: play.api.libs.json.Reads[Team] = {
      for {
        organization <- (__ \ "organization").read[com.gilt.quality.v0.models.Organization]
        key <- (__ \ "key").read[String]
        email <- (__ \ "email").readNullable[String]
        icons <- (__ \ "icons").read[com.gilt.quality.v0.models.Icons]
      } yield Team(organization, key, email, icons)
    }

    def jsObjectTeam(obj: com.gilt.quality.v0.models.Team): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "organization" -> jsObjectOrganization(obj.organization),
        "key" -> play.api.libs.json.JsString(obj.key),
        "icons" -> jsObjectIcons(obj.icons)
      ) ++ (obj.email match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("email" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesQualityTeam: play.api.libs.json.Writes[Team] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.Team] {
        def writes(obj: com.gilt.quality.v0.models.Team) = {
          jsObjectTeam(obj)
        }
      }
    }

    implicit def jsonReadsQualityTeamForm: play.api.libs.json.Reads[TeamForm] = {
      for {
        key <- (__ \ "key").read[String]
        email <- (__ \ "email").readNullable[String]
        smileyUrl <- (__ \ "smiley_url").readNullable[String]
        frownyUrl <- (__ \ "frowny_url").readNullable[String]
      } yield TeamForm(key, email, smileyUrl, frownyUrl)
    }

    def jsObjectTeamForm(obj: com.gilt.quality.v0.models.TeamForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key)
      ) ++ (obj.email match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("email" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.smileyUrl match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("smiley_url" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.frownyUrl match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("frowny_url" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesQualityTeamForm: play.api.libs.json.Writes[TeamForm] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.TeamForm] {
        def writes(obj: com.gilt.quality.v0.models.TeamForm) = {
          jsObjectTeamForm(obj)
        }
      }
    }

    implicit def jsonReadsQualityTeamMember: play.api.libs.json.Reads[TeamMember] = {
      for {
        team <- (__ \ "team").read[com.gilt.quality.v0.models.Team]
        user <- (__ \ "user").read[com.gilt.quality.v0.models.User]
      } yield TeamMember(team, user)
    }

    def jsObjectTeamMember(obj: com.gilt.quality.v0.models.TeamMember): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "team" -> jsObjectTeam(obj.team),
        "user" -> jsObjectUser(obj.user)
      )
    }

    implicit def jsonWritesQualityTeamMember: play.api.libs.json.Writes[TeamMember] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.TeamMember] {
        def writes(obj: com.gilt.quality.v0.models.TeamMember) = {
          jsObjectTeamMember(obj)
        }
      }
    }

    implicit def jsonReadsQualityTeamMemberSummary: play.api.libs.json.Reads[TeamMemberSummary] = {
      for {
        team <- (__ \ "team").read[com.gilt.quality.v0.models.Team]
        numberMembers <- (__ \ "number_members").read[Long]
      } yield TeamMemberSummary(team, numberMembers)
    }

    def jsObjectTeamMemberSummary(obj: com.gilt.quality.v0.models.TeamMemberSummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "team" -> jsObjectTeam(obj.team),
        "number_members" -> play.api.libs.json.JsNumber(obj.numberMembers)
      )
    }

    implicit def jsonWritesQualityTeamMemberSummary: play.api.libs.json.Writes[TeamMemberSummary] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.TeamMemberSummary] {
        def writes(obj: com.gilt.quality.v0.models.TeamMemberSummary) = {
          jsObjectTeamMemberSummary(obj)
        }
      }
    }

    implicit def jsonReadsQualityUpdateTeamForm: play.api.libs.json.Reads[UpdateTeamForm] = {
      for {
        email <- (__ \ "email").readNullable[String]
        smileyUrl <- (__ \ "smiley_url").readNullable[String]
        frownyUrl <- (__ \ "frowny_url").readNullable[String]
      } yield UpdateTeamForm(email, smileyUrl, frownyUrl)
    }

    def jsObjectUpdateTeamForm(obj: com.gilt.quality.v0.models.UpdateTeamForm): play.api.libs.json.JsObject = {
      (obj.email match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("email" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.smileyUrl match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("smiley_url" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.frownyUrl match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("frowny_url" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesQualityUpdateTeamForm: play.api.libs.json.Writes[UpdateTeamForm] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.UpdateTeamForm] {
        def writes(obj: com.gilt.quality.v0.models.UpdateTeamForm) = {
          jsObjectUpdateTeamForm(obj)
        }
      }
    }

    implicit def jsonReadsQualityUser: play.api.libs.json.Reads[User] = {
      for {
        guid <- (__ \ "guid").read[_root_.java.util.UUID]
        email <- (__ \ "email").read[String]
      } yield User(guid, email)
    }

    def jsObjectUser(obj: com.gilt.quality.v0.models.User): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "guid" -> play.api.libs.json.JsString(obj.guid.toString),
        "email" -> play.api.libs.json.JsString(obj.email)
      )
    }

    implicit def jsonWritesQualityUser: play.api.libs.json.Writes[User] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.User] {
        def writes(obj: com.gilt.quality.v0.models.User) = {
          jsObjectUser(obj)
        }
      }
    }

    implicit def jsonReadsQualityUserForm: play.api.libs.json.Reads[UserForm] = {
      (__ \ "email").read[String].map { x => new UserForm(email = x) }
    }

    def jsObjectUserForm(obj: com.gilt.quality.v0.models.UserForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "email" -> play.api.libs.json.JsString(obj.email)
      )
    }

    implicit def jsonWritesQualityUserForm: play.api.libs.json.Writes[UserForm] = {
      new play.api.libs.json.Writes[com.gilt.quality.v0.models.UserForm] {
        def writes(obj: com.gilt.quality.v0.models.UserForm) = {
          jsObjectUserForm(obj)
        }
      }
    }
  }
}