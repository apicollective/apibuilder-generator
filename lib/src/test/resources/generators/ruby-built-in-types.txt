# Generated by API Builder - https://www.apibuilder.io
# Service version: 0.0.1-dev

require 'cgi'
require 'net/http'
require 'net/https'
require 'uri'
require 'base64'

require 'date'
require 'rubygems'
require 'json'
require 'bigdecimal'

module Apibuilder

  class Client

    module Constants

      NAMESPACE = 'apibuilder' unless defined?(Constants::NAMESPACE)
      USER_AGENT = 'apibuilder-play_2x_client-unknown' unless defined?(Constants::USER_AGENT)
      VERSION = '0.0.1-dev' unless defined?(Constants::VERSION)
      VERSION_MAJOR = 0 unless defined?(VERSION_MAJOR)

    end

    attr_reader :url

    def initialize(url, opts={})
      @url = HttpClient::Preconditions.assert_class('url', url, String)
      @base_url = URI(url)
      @authorization = HttpClient::Preconditions.assert_class_or_nil('authorization', opts.delete(:authorization), HttpClient::Authorization)
      @default_headers = HttpClient::Preconditions.assert_class('default_headers', opts.delete(:default_headers) || {}, Hash)
      @http_handler = opts.delete(:http_handler) || HttpClient::DefaultHttpHandler.new

      HttpClient::Preconditions.assert_empty_opts(opts)
      HttpClient::Preconditions.check_state(url.match(/http.+/i), "URL[%s] must start with http" % url)
    end

    def request(path=nil)
      HttpClient::Preconditions.assert_class_or_nil('path', path, String)
      request = HttpClient::Request.new(@http_handler, @base_url, path.to_s).with_header('User-Agent', Constants::USER_AGENT).with_header('X-Apidoc-Version', Constants::VERSION).with_header('X-Apidoc-Version-Major', Constants::VERSION_MAJOR)

      @default_headers.each do |key, value|
        request = request.with_header(key, value)
      end

      if @authorization
        request = request.with_auth(@authorization)
      end

      request
    end

    def arrays
      @arrays ||= ::Apibuilder::Clients::Arrays.new(self)
    end

    def optarrays
      @optarrays ||= ::Apibuilder::Clients::Optarrays.new(self)
    end

    def optionals
      @optionals ||= ::Apibuilder::Clients::Optionals.new(self)
    end

    def requireds
      @requireds ||= ::Apibuilder::Clients::Requireds.new(self)
    end
  end

  module Clients

    class Arrays

      def initialize(client)
        @client = HttpClient::Preconditions.assert_class('client', client, ::Apibuilder::Client)
      end

      def get
        r = @client.request("/arrays").get
        ::Apibuilder::Models::Array.new(r)
      end

    end

    class Optarrays

      def initialize(client)
        @client = HttpClient::Preconditions.assert_class('client', client, ::Apibuilder::Client)
      end

      def get
        r = @client.request("/optarrays").get
        ::Apibuilder::Models::Optarray.new(r)
      end

    end

    class Optionals

      def initialize(client)
        @client = HttpClient::Preconditions.assert_class('client', client, ::Apibuilder::Client)
      end

      def get
        r = @client.request("/optionals").get
        ::Apibuilder::Models::Optional.new(r)
      end

    end

    class Requireds

      def initialize(client)
        @client = HttpClient::Preconditions.assert_class('client', client, ::Apibuilder::Client)
      end

      def get
        r = @client.request("/requireds").get
        ::Apibuilder::Models::Required.new(r)
      end

    end

  end

  module Models

    class Array

      attr_reader :boolean, :dateiso8601, :datetimeiso8601, :decimal, :double, :integer, :json, :long, :object, :string, :uuid

      def initialize(incoming={})
        opts = HttpClient::Helper.symbolize_keys(incoming)
        HttpClient::Preconditions.require_keys(opts, [:boolean, :dateiso8601, :datetimeiso8601, :decimal, :double, :integer, :json, :long, :object, :string, :uuid], 'Array')
        @boolean = HttpClient::Preconditions.assert_class('boolean', opts.delete(:boolean), Array).map { |v| HttpClient::Preconditions.assert_boolean('boolean', v) }
        @dateiso8601 = HttpClient::Preconditions.assert_class('dateiso8601', opts.delete(:dateiso8601), Array).map { |v| HttpClient::Preconditions.assert_class('dateiso8601', HttpClient::Helper.to_date_iso8601(v), Date) }
        @datetimeiso8601 = HttpClient::Preconditions.assert_class('datetimeiso8601', opts.delete(:datetimeiso8601), Array).map { |v| HttpClient::Preconditions.assert_class('datetimeiso8601', HttpClient::Helper.to_date_time_iso8601(v), DateTime) }
        @decimal = HttpClient::Preconditions.assert_class('decimal', opts.delete(:decimal), Array).map { |v| HttpClient::Preconditions.assert_class('decimal', HttpClient::Helper.to_big_decimal(v), BigDecimal) }
        @double = HttpClient::Preconditions.assert_class('double', opts.delete(:double), Array).map { |v| HttpClient::Preconditions.assert_class('double', v, Numeric) }
        @integer = HttpClient::Preconditions.assert_class('integer', opts.delete(:integer), Array).map { |v| HttpClient::Preconditions.assert_class('integer', v, Integer) }
        @json = HttpClient::Preconditions.assert_class('json', opts.delete(:json), Array).map { |v| HttpClient::Preconditions.assert_class('json', v, BasicObject) }
        @long = HttpClient::Preconditions.assert_class('long', opts.delete(:long), Array).map { |v| HttpClient::Preconditions.assert_class('long', v, Integer) }
        @object = HttpClient::Preconditions.assert_class('object', opts.delete(:object), Array).map { |v| HttpClient::Preconditions.assert_class('object', HttpClient::Helper.to_object(v), Hash) }
        @string = HttpClient::Preconditions.assert_class('string', opts.delete(:string), Array).map { |v| HttpClient::Preconditions.assert_class('string', v, String) }
        @uuid = HttpClient::Preconditions.assert_class('uuid', opts.delete(:uuid), Array).map { |v| HttpClient::Preconditions.assert_class('uuid', HttpClient::Helper.to_uuid(v), String) }
      end

      def to_json
        JSON.dump(to_hash)
      end

      def copy(incoming={})
        Array.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
      end

      def to_hash
        {
          :boolean => boolean,
          :dateiso8601 => dateiso8601,
          :datetimeiso8601 => datetimeiso8601,
          :decimal => decimal.to_f.to_s,
          :double => double,
          :integer => integer,
          :json => json,
          :long => long,
          :object => object,
          :string => string,
          :uuid => uuid
        }
      end

    end

    class Optarray

      attr_reader :boolean, :dateiso8601, :datetimeiso8601, :decimal, :double, :integer, :json, :long, :object, :string, :uuid

      def initialize(incoming={})
        opts = HttpClient::Helper.symbolize_keys(incoming)
        @boolean = (x = opts.delete(:boolean); x.nil? ? nil : HttpClient::Preconditions.assert_class('boolean', x, Array).map { |v| HttpClient::Preconditions.assert_boolean('boolean', v) })
        @dateiso8601 = (x = opts.delete(:dateiso8601); x.nil? ? nil : HttpClient::Preconditions.assert_class('dateiso8601', x, Array).map { |v| HttpClient::Preconditions.assert_class('dateiso8601', HttpClient::Helper.to_date_iso8601(v), Date) })
        @datetimeiso8601 = (x = opts.delete(:datetimeiso8601); x.nil? ? nil : HttpClient::Preconditions.assert_class('datetimeiso8601', x, Array).map { |v| HttpClient::Preconditions.assert_class('datetimeiso8601', HttpClient::Helper.to_date_time_iso8601(v), DateTime) })
        @decimal = (x = opts.delete(:decimal); x.nil? ? nil : HttpClient::Preconditions.assert_class('decimal', x, Array).map { |v| HttpClient::Preconditions.assert_class('decimal', HttpClient::Helper.to_big_decimal(v), BigDecimal) })
        @double = (x = opts.delete(:double); x.nil? ? nil : HttpClient::Preconditions.assert_class('double', x, Array).map { |v| HttpClient::Preconditions.assert_class('double', v, Numeric) })
        @integer = (x = opts.delete(:integer); x.nil? ? nil : HttpClient::Preconditions.assert_class('integer', x, Array).map { |v| HttpClient::Preconditions.assert_class('integer', v, Integer) })
        @json = (x = opts.delete(:json); x.nil? ? nil : HttpClient::Preconditions.assert_class('json', x, Array).map { |v| HttpClient::Preconditions.assert_class('json', v, BasicObject) })
        @long = (x = opts.delete(:long); x.nil? ? nil : HttpClient::Preconditions.assert_class('long', x, Array).map { |v| HttpClient::Preconditions.assert_class('long', v, Integer) })
        @object = (x = opts.delete(:object); x.nil? ? nil : HttpClient::Preconditions.assert_class('object', x, Array).map { |v| HttpClient::Preconditions.assert_class('object', HttpClient::Helper.to_object(v), Hash) })
        @string = (x = opts.delete(:string); x.nil? ? nil : HttpClient::Preconditions.assert_class('string', x, Array).map { |v| HttpClient::Preconditions.assert_class('string', v, String) })
        @uuid = (x = opts.delete(:uuid); x.nil? ? nil : HttpClient::Preconditions.assert_class('uuid', x, Array).map { |v| HttpClient::Preconditions.assert_class('uuid', HttpClient::Helper.to_uuid(v), String) })
      end

      def to_json
        JSON.dump(to_hash)
      end

      def copy(incoming={})
        Optarray.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
      end

      def to_hash
        {
          :boolean => boolean.nil? ? nil : boolean,
          :dateiso8601 => dateiso8601.nil? ? nil : dateiso8601,
          :datetimeiso8601 => datetimeiso8601.nil? ? nil : datetimeiso8601,
          :decimal => decimal.nil? ? nil : decimal.to_f.to_s,
          :double => double.nil? ? nil : double,
          :integer => integer.nil? ? nil : integer,
          :json => json.nil? ? nil : json,
          :long => long.nil? ? nil : long,
          :object => object.nil? ? nil : object,
          :string => string.nil? ? nil : string,
          :uuid => uuid.nil? ? nil : uuid
        }
      end

    end

    class Optional

      attr_reader :boolean, :dateiso8601, :datetimeiso8601, :decimal, :double, :integer, :json, :long, :object, :string, :uuid

      def initialize(incoming={})
        opts = HttpClient::Helper.symbolize_keys(incoming)
        @boolean = (x = opts.delete(:boolean); x.nil? ? nil : HttpClient::Preconditions.assert_boolean('boolean', x))
        @dateiso8601 = (x = opts.delete(:dateiso8601); x.nil? ? nil : HttpClient::Preconditions.assert_class('dateiso8601', HttpClient::Helper.to_date_iso8601(x), Date))
        @datetimeiso8601 = (x = opts.delete(:datetimeiso8601); x.nil? ? nil : HttpClient::Preconditions.assert_class('datetimeiso8601', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
        @decimal = (x = opts.delete(:decimal); x.nil? ? nil : HttpClient::Preconditions.assert_class('decimal', HttpClient::Helper.to_big_decimal(x), BigDecimal))
        @double = (x = opts.delete(:double); x.nil? ? nil : HttpClient::Preconditions.assert_class('double', x, Numeric))
        @integer = (x = opts.delete(:integer); x.nil? ? nil : HttpClient::Preconditions.assert_class('integer', x, Integer))
        @json = (x = opts.delete(:json); x.nil? ? nil : HttpClient::Preconditions.assert_class('json', x, BasicObject))
        @long = (x = opts.delete(:long); x.nil? ? nil : HttpClient::Preconditions.assert_class('long', x, Integer))
        @object = (x = opts.delete(:object); x.nil? ? nil : HttpClient::Preconditions.assert_class('object', HttpClient::Helper.to_object(x), Hash))
        @string = (x = opts.delete(:string); x.nil? ? nil : HttpClient::Preconditions.assert_class('string', x, String))
        @uuid = (x = opts.delete(:uuid); x.nil? ? nil : HttpClient::Preconditions.assert_class('uuid', HttpClient::Helper.to_uuid(x), String))
      end

      def to_json
        JSON.dump(to_hash)
      end

      def copy(incoming={})
        Optional.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
      end

      def to_hash
        {
          :boolean => boolean,
          :dateiso8601 => dateiso8601,
          :datetimeiso8601 => datetimeiso8601,
          :decimal => decimal.to_f.to_s,
          :double => double,
          :integer => integer,
          :json => json,
          :long => long,
          :object => object,
          :string => string,
          :uuid => uuid
        }
      end

    end

    class Required

      attr_reader :boolean, :dateiso8601, :datetimeiso8601, :decimal, :double, :integer, :json, :long, :object, :string, :uuid

      def initialize(incoming={})
        opts = HttpClient::Helper.symbolize_keys(incoming)
        HttpClient::Preconditions.require_keys(opts, [:boolean, :dateiso8601, :datetimeiso8601, :decimal, :double, :integer, :json, :long, :object, :string, :uuid], 'Required')
        @boolean = HttpClient::Preconditions.assert_boolean('boolean', opts.delete(:boolean))
        @dateiso8601 = HttpClient::Preconditions.assert_class('dateiso8601', HttpClient::Helper.to_date_iso8601(opts.delete(:dateiso8601)), Date)
        @datetimeiso8601 = HttpClient::Preconditions.assert_class('datetimeiso8601', HttpClient::Helper.to_date_time_iso8601(opts.delete(:datetimeiso8601)), DateTime)
        @decimal = HttpClient::Preconditions.assert_class('decimal', HttpClient::Helper.to_big_decimal(opts.delete(:decimal)), BigDecimal)
        @double = HttpClient::Preconditions.assert_class('double', opts.delete(:double), Numeric)
        @integer = HttpClient::Preconditions.assert_class('integer', opts.delete(:integer), Integer)
        @json = HttpClient::Preconditions.assert_class('json', opts.delete(:json), BasicObject)
        @long = HttpClient::Preconditions.assert_class('long', opts.delete(:long), Integer)
        @object = HttpClient::Preconditions.assert_class('object', HttpClient::Helper.to_object(opts.delete(:object)), Hash)
        @string = HttpClient::Preconditions.assert_class('string', opts.delete(:string), String)
        @uuid = HttpClient::Preconditions.assert_class('uuid', HttpClient::Helper.to_uuid(opts.delete(:uuid)), String)
      end

      def to_json
        JSON.dump(to_hash)
      end

      def copy(incoming={})
        Required.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
      end

      def to_hash
        {
          :boolean => boolean,
          :dateiso8601 => dateiso8601,
          :datetimeiso8601 => datetimeiso8601,
          :decimal => decimal.to_f.to_s,
          :double => double,
          :integer => integer,
          :json => json,
          :long => long,
          :object => object,
          :string => string,
          :uuid => uuid
        }
      end

    end

  end

  # ===== END OF SERVICE DEFINITION =====
  module HttpClient

    class HttpHandler

      # Returns a client instance to use
      #
      # @param base_uri The base URI for this API
      # @param path the Requested full http path (including any query strings)
      def instance(base_uri, path)
        raise "Override in subclass"
      end

    end

    class HttpHandlerInstance

      # Executes a request. The provided request object will be an
      # instance of Net::HTTP (e.g. Net::HTTP::Get)
      def execute(request)
        raise "Override in subclass"
      end

    end

    class DefaultHttpHandler < HttpHandler

      def instance(base_uri, path)
        DefaultHttpHandlerInstance.new(base_uri)
      end

    end

    class DefaultHttpHandlerInstance < HttpHandlerInstance

      attr_reader :client

      def initialize(base_uri)
        @base_uri = Preconditions.assert_class('base_uri', base_uri, URI)
        @client = Net::HTTP.new(@base_uri.host, @base_uri.port)
        if @base_uri.scheme == "https"
          configure_ssl
        end
      end

      def execute(request)
        response = begin
                     @client.request(request)
                   rescue SocketError => e
                     raise StandardError.new("Error accessing uri[#{full_uri(request.path)}]: #{e}")
                   end

        case response
        when Net::HTTPSuccess
          response.body
        else
          body = response.body rescue nil
          raise HttpClient::ServerError.new(response.code.to_i, response.message, :body => body, :uri => full_uri(request.path).to_s)
        end
      end

      def full_uri(path)
        path.start_with?(@base_uri.to_s) ? path : File.join(@base_uri.to_s, path)
      end

      # Called to configure SSL if the base uri requires it
      def configure_ssl
        @client.use_ssl = true
        @client.verify_mode = OpenSSL::SSL::VERIFY_PEER
        @client.cert_store = OpenSSL::X509::Store.new
        @client.cert_store.set_default_paths
      end

    end

    class Request

      attr_reader :base_uri, :path, :full_uri

      def initialize(http_handler, base_uri, path)
        @http_handler = http_handler
        @base_uri = Preconditions.assert_class('base_uri', base_uri, URI)
        @path = Preconditions.assert_class('path', path, String)
        @full_uri = @base_uri.to_s + @path
        @params = nil
        @body = nil
        @auth = nil
        @headers = {}
        @header_keys_lower_case = []
      end

      def with_header(name, value)
        Preconditions.check_not_blank('name', name, "Header name is required")
        Preconditions.check_not_blank('value', value, "Header value is required")
        Preconditions.check_state(!@headers.has_key?(name),
                                  "Duplicate header named[%s]" % name)
        @headers[name] = value
        @header_keys_lower_case << name.downcase
        self
      end

      def with_auth(auth)
        Preconditions.assert_class('auth', auth, HttpClient::Authorization)
        Preconditions.check_state(@auth.nil?, "auth previously set")

        if auth.scheme.name == AuthScheme::BASIC.name
          @auth = auth
        else
          raise "Auth Scheme[#{auth.scheme.name}] not supported"
        end
        self
      end

      def with_query(params)
        Preconditions.assert_class('params', params, Hash)
        Preconditions.check_state(@params.nil?, "Already have query parameters")
        @params = params
        self
      end

      # Wrapper to set Content-Type header to application/json and set
      # the provided json document as the body
      def with_json(json)
        @headers['Content-Type'] ||= 'application/json; charset=UTF-8'
        with_body(json)
      end

      def with_body(body)
        Preconditions.check_not_blank('body', body)
        @body = body
        self
      end

      def get(&block)
        do_request(Net::HTTP::Get, &block)
      end

      def delete(&block)
        do_request(Net::HTTP::Delete, &block)
      end

      def options(&block)
        do_request(Net::HTTP::Options, &block)
      end

      def post(&block)
        do_request(Net::HTTP::Post, &block)
      end

      def put(&block)
        do_request(Net::HTTP::Put, &block)
      end

      class PATCH < Net::HTTP::Put
        METHOD = "PATCH"
      end

      def patch(&block)
        do_request(PATCH, &block)
      end

      def do_request(klass)
        Preconditions.assert_class('klass', klass, Class)

        uri = @full_uri.dup
        if q = to_query(@params)
          uri += "?%s" % q
        end

        request = klass.send(:new, uri)

        curl = ['curl']
        if klass != Net::HTTP::Get
          curl << "-X%s" % klass.name.split("::").last.upcase
        end

        if @body
          # DEBUG tmpfile = "/tmp/rest_client.tmp"
          # DEBUG File.open(tmpfile, "w") { |os| os << @body.to_s }
          # DEBUG curl << "-d@%s" % tmpfile
          request.body = @body
        end

        if @auth
          curl << "-u \"%s:%s\"" % [@auth.username, @auth.password]
          Preconditions.check_state(!@header_keys_lower_case.include?("authorization"),
                                    "Cannot specify both an Authorization header and an auth instance")
          user_pass = "%s:%s" % [@auth.username, @auth.password]
          encoded = Base64.encode64(user_pass).to_s.split("\n").map(&:strip).join
          request.add_field("Authorization", "Basic %s" % encoded)
        end

        @headers.each { |key, value|
          curl <<  "-H \"%s: %s\"" % [key, value]
          request.add_field(key, value)
        }

        curl << "'%s%s'" % [@base_uri, path]
        # DEBUG puts curl.join(" ")

        raw_response = @http_handler.instance(@base_uri, request.path).execute(request)
        response = raw_response.to_s == "" ? nil : JSON.parse(raw_response)

        if block_given?
          yield response
        else
          response
        end
      end

      private
      def to_query(params={})
        parts = (params || {}).map { |k,v|
          if v.is_a?(Enumerable)
            v.map { |el| "%s=%s" % [k, CGI.escape(el.to_s)] }
          else
            "%s=%s" % [k, CGI.escape(v.to_s)]
          end
        }
        parts.empty? ? nil : parts.join("&")
      end

    end

    class ServerError < StandardError

      attr_reader :code, :details, :body, :uri

      def initialize(code, details, incoming={})
        opts = HttpClient::Helper.symbolize_keys(incoming)
        @code = HttpClient::Preconditions.assert_class('code', code, Integer)
        @details = HttpClient::Preconditions.assert_class('details', details, String)
        @body = HttpClient::Preconditions.assert_class_or_nil('body', opts.delete(:body), String)
        @uri = HttpClient::Preconditions.assert_class_or_nil('uri', opts.delete(:uri), String)
        HttpClient::Preconditions.assert_empty_opts(opts)
        super(self.message)
      end

      def message
        m = "%s %s" % [@code, @details]
        if @body
          m << ": %s" % @body
        end
        m
      end

      def body_json
        @body ? JSON.parse(@body) : nil
      end

    end

    class PreconditionException < StandardError

      attr_reader :message

      def initialize(message)
        super(message)
        @message = message
      end

    end

    module Preconditions

      def Preconditions.check_argument(expression, error_message=nil)
        if !expression
          raise PreconditionException.new(error_message || "check_argument failed")
        end
        nil
      end

      def Preconditions.check_state(expression, error_message=nil)
        if !expression
          raise PreconditionException.new(error_message || "check_state failed")
        end
        nil
      end

      def Preconditions.check_not_nil(field_name, reference, error_message=nil)
        if reference.nil?
          raise PreconditionException.new(error_message || "argument for %s cannot be nil" % field_name)
        end
        reference
      end

      def Preconditions.check_not_blank(field_name, reference, error_message=nil)
        if reference.to_s.strip == ""
          raise PreconditionException.new(error_message || "argument for %s cannot be blank" % field_name)
        end
        reference
      end

      # Throws an error if opts is not empty. Useful when parsing
      # arguments to a function
      def Preconditions.assert_empty_opts(opts)
        if !opts.empty?
          raise PreconditionException.new("Invalid opts: #{opts.keys.inspect}\n#{opts.inspect}")
        end
      end

      # Requires that the provided hash has the specified keys.
      # @param fields A list of symbols
      def Preconditions.require_keys(hash, fields, error_prefix=nil)
        missing = fields.select { |f| !hash.has_key?(f) }
        if !missing.empty?
          msg = "Missing required fields: " + missing.join(", ")
          raise PreconditionException.new(error_prefix.empty? ? msg : "#{error_prefix}: #{msg}")
        end
      end

      # Asserts that value is not nill and is_?(klass). Returns
      # value. Common use is
      #
      # amount = Preconditions.assert_class('amount', amount, BigDecimal)
      def Preconditions.assert_class(field_name, value, klass)
        Preconditions.check_not_nil('field_name', field_name)
        Preconditions.check_not_nil('klass', klass)
        Preconditions.check_not_nil('value', value, "Value for %s cannot be nil. Expected an instance of class %s" % [field_name, klass.name])
        Preconditions.check_state(value.is_a?(klass),
                                  "Value for #{field_name} is of type[#{value.class}] - class[#{klass}] is required. value[#{value.inspect.to_s}]")
        value
      end

      def Preconditions.assert_class_or_nil(field_name, value, klass)
        if !value.nil?
          Preconditions.assert_class(field_name, value, klass)
        end
      end

      def Preconditions.assert_boolean(field_name, value)
        Preconditions.check_not_nil('field_name', field_name)
        Preconditions.check_not_nil('value', value, "Value for %s cannot be nil. Expected an instance of TrueClass or FalseClass" % field_name)
        Preconditions.check_state(value.is_a?(TrueClass) || value.is_a?(FalseClass),
                                  "Value for #{field_name} is of type[#{value.class}] - class[TrueClass or FalseClass] is required. value[#{value.inspect.to_s}]")
        value
      end

      def Preconditions.assert_boolean_or_nil(field_name, value)
        if !value.nil?
          Preconditions.assert_boolean(field_name, value)
        end
      end

      def Preconditions.assert_collection_of_class(field_name, values, klass)
        Preconditions.assert_class(field_name, values, Array)
        values.each { |v| Preconditions.assert_class(field_name, v, klass) }
      end

      def Preconditions.assert_hash_of_class(field_name, hash, klass)
        Preconditions.assert_class(field_name, hash, Hash)
        values.each { |k, v| Preconditions.assert_class(field_name, v, klass) }
      end

    end

    class AuthScheme

      attr_reader :name

      def initialize(name)
        @name = HttpClient::Preconditions.check_not_blank('name', name)
      end

      BASIC = AuthScheme.new("basic") unless defined?(BASIC)

    end

    class Authorization

      attr_reader :scheme, :username, :password

      def initialize(scheme, username, opts={})
        @scheme = HttpClient::Preconditions.assert_class('schema', scheme, AuthScheme)
        @username = HttpClient::Preconditions.check_not_blank('username', username, "username is required")
        @password = HttpClient::Preconditions.assert_class_or_nil('password', opts.delete(:password), String)
        HttpClient::Preconditions.assert_empty_opts(opts)
      end

      def Authorization.basic(username, password=nil)
        Authorization.new(AuthScheme::BASIC, username, :password => password)
      end

    end

    module Helper

      def Helper.symbolize_keys(hash)
        Preconditions.assert_class('hash', hash, Hash)
        new_hash = {}
        hash.each { |k, v|
          new_hash[k.to_sym] = v
        }
        new_hash
      end

      def Helper.to_big_decimal(value)
        value ? BigDecimal.new(value.to_s) : nil
      end

      def Helper.to_object(value)
        value ? (value.is_a?(Hash) ? value : JSON.parse(value)) : nil
      end

      def Helper.to_uuid(value)
        Preconditions.check_state(value.nil? || value.match(/^\w\w\w\w\w\w\w\w\-\w\w\w\w\-\w\w\w\w\-\w\w\w\w\-\w\w\w\w\w\w\w\w\w\w\w\w$/),
                                  "Invalid guid[%s]" % value)
        value
      end

      def Helper.to_date_iso8601(value)
        if value.is_a?(Date)
          value
        elsif value
          Date.parse(value.to_s)
        else
          nil
        end
      end

      def Helper.to_date_time_iso8601(value)
        if value.is_a?(DateTime)
          value
        elsif value
          DateTime.parse(value.to_s)
        else
          nil
        end
      end

      def Helper.date_iso8601_to_string(value)
        value.nil? ? nil : value.strftime('%Y-%m-%d')
      end

      def Helper.date_time_iso8601_to_string(value)
        value.nil? ? nil : value.strftime('%Y-%m-%dT%H:%M:%S%z')
      end

      TRUE_STRINGS = ['t', 'true', 'y', 'yes', 'on', '1', 'trueclass'] unless defined?(TRUE_STRINGS)
      FALSE_STRINGS = ['f', 'false', 'n', 'no', 'off', '0', 'falseclass'] unless defined?(FALSE_STRINGS)

      def Helper.to_boolean(field_name, value)
        string = value.to_s.strip.downcase
        if TRUE_STRINGS.include?(string)
          true
        elsif FALSE_STRINGS.include?(string)
          false
        elsif string != ""
          raise PreconditionException.new("Unsupported boolean value[#{string}]. For true, must be one of: #{TRUE_STRINGS.inspect}. For false, must be one of: #{FALSE_STRINGS.inspect}")
        else
          nil
        end
      end

    end

  end
end